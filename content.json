{"meta":{"title":"aJream","subtitle":"","description":"aJream的个人博客","author":"aJream","url":"https://blog.ajream.top","root":"/"},"pages":[{"title":"","date":"2024-03-31T14:49:40.667Z","updated":"2024-03-31T14:49:40.667Z","comments":true,"path":"about/index.html","permalink":"https://blog.ajream.top/about/","excerpt":"","text":"我的建站史 2023-09 主题再次更改，使用volantis 2022-06 主题butterfly改为stellar 2021-07 暑假期间了解到GitHub pages可以搭建个人网站，遂使用Hexo+Butterfly搭建了第一个博客 博客镜像部署在不同平台的博客专属域名VercelNetlifyGithub Pages 我的其它平台博客博客园我在博客园的博客CSDN我在CSDN的博客知乎我的知乎"},{"title":"所有分类","date":"2024-03-31T14:49:40.667Z","updated":"2024-03-31T14:49:40.667Z","comments":true,"path":"categories/index.html","permalink":"https://blog.ajream.top/categories/","excerpt":"","text":""},{"title":"友链","date":"2024-03-31T14:49:40.667Z","updated":"2024-03-31T14:49:40.667Z","comments":true,"path":"friends/index.html","permalink":"https://blog.ajream.top/friends/","excerpt":"","text":"ThanksvolantisMHuiGinkssColsrch大神们Akilarの糖果屋Jerry優萌初華の霜月琉璃DearXuan小伙伴们~感谢小伙伴们带来的干货🎉ReverseSacle是非题solstice23’s Blog宫水三叶の刷题日记北辰の小栈百里飞洋の博客免费clash节点 本站信息 1234title: AJream&#x27;s Blogurl: https://blog.ajream.topavatar: https://gitcode.net/m0_46079750/myimages/-/raw/master/pictures/2023/09/23_17_0_6_avatar.pngdescription: 欢饮光临小A的博客！"},{"title":"所有笔记","date":"2024-03-31T14:49:40.671Z","updated":"2024-03-31T14:49:40.671Z","comments":true,"path":"notes/index.html","permalink":"https://blog.ajream.top/notes/","excerpt":"","text":"嵌入式 51单片机学习笔记【学习使用的板子为清翔单片机开发板】 stm32单片机学习笔记【学习使用的板子为普中stm32开发板】 esp8266 智能家居项目 Java Java基础学习"},{"title":"所有标签","date":"2024-03-31T14:49:40.687Z","updated":"2024-03-31T14:49:40.687Z","comments":true,"path":"tags/index.html","permalink":"https://blog.ajream.top/tags/","excerpt":"","text":""},{"title":"","date":"2024-03-31T14:49:40.667Z","updated":"2024-03-31T14:49:40.667Z","comments":true,"path":"notes/51/mcu51_1/index.html","permalink":"https://blog.ajream.top/notes/51/mcu51_1/","excerpt":"","text":"点亮第一个led灯 新建工程 选择固件 新建代码源文件 添加如下代码 12345678#include &lt;reg52.h&gt; //引用51头文件sbit LED = P1^1;void main()&#123; LED = 0; //点亮LED2 &#125; 编译前要先配置，让编译器在编译完成后输出hex文件，hex文件用来烧录进单片机里面 编译 上传（烧录） 到此第一个点灯小程序结束 流水灯 按照之前的步骤再建立一个新工程，写下如下代码： 12345678910111213141516171819202122232425262728#include &lt;reg52.h&gt; //包含51头文件#include &lt;intrins.h&gt; //包含移位标准库函数头文件#define uint unsigned int#define uchar unsigned charuchar temp; //LED灯相关变量//延时函数void delay(uint z)&#123; uint x, y; for(x = z; x &gt; 0; x--) for(y = 114; y &gt; 0 ; y--); &#125; void main()&#123; temp = 0xfe; P1 = temp; //1111 1110 初值LED1亮 delay(1000);//毫秒级延时 100毫秒 while(1) &#123; temp = _cror_(temp, 1);//循环左移 P1 = temp;//移位完成后赋值给P1 每个一个灯点亮 delay(1000);//毫秒级延时 100毫秒 &#125; &#125; 说明： intrins.h 头文件包含移位函数 ：右移_cror_()、 左移_corl_() 蜂鸣器 蜂鸣器分有源与无源蜂鸣器 有源指内部自带震荡源，只要提供电压即可响，但由于其震荡源震动频率固定，因此只能产生一种频率的声音 无源蜂鸣器指内部没有震荡源，需要提供变化的电压（方波）才能让其响 一个蜂鸣器的简单驱动电路： 12345678910111213141516171819202122#include &lt;reg52.h&gt; //包含51头文件#include &lt;intrins.h&gt;//包含移位标准库函数头文件#define uint unsigned intsbit beep = P2^3;//蜂鸣器void delay(uint z)&#123; uint x,y; for(x = z; x &gt; 0; x--) for(y = 114; y &gt; 0 ; y--); &#125; void main()&#123; while(1) &#123; beep = ~beep;// 蜂鸣器发出滴滴声 delay(100); &#125; &#125; 数码管 原理 单个数码管结构原理： 多个数码管： 说明： 74HC573是个锁存器，原理如下： 当控制端LE为高电平时，输出端Q的数据随输入端D的数据变化而变化 当控制端LE为低电平时，输入端D的数据变化，Q端会保持之前的状态 在这幅图 用到2片74HC573模块，上面一片是用来控制哪一个数码管使用，下面那一片用来控制显示的字符 在这8个数码管中，左边是低位，右边是高位，这是共阴极数码管，比如位选输入“0xFE”（即1111 1110），最左边这个数码管就被选中了。 数码管的每一段都接到地，给对应的段提供高电平就能点亮它，其数码表如下 12340x3F, 0x06, 0x5B, 0x4F, 0x66, 0x6D, 0x7D, 0x07, 0x7F, 0x6F// 0 1 2 3 4 5 6 7 8 9 0x77, 0x7C, 0x39, 0x5E, 0x79, 0x71, 0x76, 0x38, 0x40, 0x00//A B C D E F H L - 熄灭 数码管静态显示 123456789101112131415161718192021#include &lt;reg52.h&gt;#include &lt;intrins.h&gt;#define uint unsigned int#define uchar unsigned charsbit DU = P2^6;//数码管段选sbit WE = P2^7;//数码管位选void main()//main函数自身会循环&#123; WE = 1;//打开位选锁存器 P0 = 0XFE; //1111 1110 选通最左边的数码管 WE = 0;//锁存位选数据 DU = 1;//打开段选锁存器 P0 = 0X5b;//1101 1011 显示“1” DU = 0;//锁存段选数据 while(1);&#125; 数码管动态显示 要让多个数码管同时显示，如果用静态显示的方式，每个数码管都要8根线连接，n个数码管就要 n*8根线，比较耗费资源，因此使用动态扫描的方式进行显示，即快速扫描每一个数码管，分别让它们进行显示，只要足够快，由于视觉暂留效应，人的大脑会以为这是同时显示，实际上每个时刻只有一个数码管进行了显示 这个代码用来控制3个数码管来显示一个三位数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;reg52.h&gt;//包含51头文件#include &lt;intrins.h&gt;//包含移位标准库函数头文件#define uint unsigned int#define uchar unsigned charsbit DU = P2^6;//数码管段选sbit WE = P2^7;//数码管段选//共阴数码管段选表0-9uchar code tabel[]= &#123;0x3F, 0x06, 0x5B, 0x4F, 0x66, 0x6D, 0x7D, 0x07, 0x7F, 0x6F,&#125;;void delay(uint z)&#123; uint x,y; for(x = z; x &gt; 0; x--) for(y = 114; y &gt; 0 ; y--); &#125; //设计一个函数用于显示三位的数字numbervoid display(uchar number)&#123; uchar bai, shi, ge; bai = number / 100; //百位 shi = number % 100 / 10; //十位 ge = number % 10; //个位 P0 = 0XFF;//清除断码 WE = 1;//打开位选锁存器 P0 = 0XFE; //1111 1110 WE = 0;//锁存位选数据 DU = 1;//打开段选锁存器 P0 = tabel[bai];// DU = 0;//锁存段选数据 delay(5); //第二位数码管 P0 = 0XFF;//清除断码 WE = 1;//打开位选锁存器 P0 = 0XFD; //1111 1101 WE = 0;//锁存位选数据 DU = 1;//打开段选锁存器 P0 = tabel[shi];// DU = 0;//锁存段选数据 delay(5); //第三位数码管 P0 = 0XFF;//清除断码 WE = 1;//打开位选锁存器 P0 = 0XFB; //1111 1011 WE = 0;//锁存位选数据 DU = 1;//打开段选锁存器 P0 = tabel[ge];// DU = 0;//锁存段选数据 delay(5);&#125;void main()//main函数自身会循环&#123; while(1) &#123; display(185); //数码管显示185 &#125; &#125; 键盘 非编码键盘分为独立键盘和矩阵键盘 独立键盘 对于独立键盘而言，例如，当S2按键按下时，P30被拉低，变为低电平，因此要判断S2是否被按下，只需要不断检测 P30是否为低电平即可 【注意】 按键消抖，最简单的是延时10~20ms后再检查其状态是否变化 松手检测 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/********************************************************************************* 按下开发板S2按键数码管值+1，最大到9 按下S3按下，值-1，最小减到0**********************************************************************************/#include &lt;reg52.h&gt;#include &lt;intrins.h&gt;#define uint unsigned int#define uchar unsigned charsbit DU = P2^6;//数码管段选sbit WE = P2^7;//数码管段选sbit key_s2 = P3^0;//独立按键S2sbit key_s3 = P3^1;//独立按键S3uchar num;//数码管显示的值//共阴数码管段选表0-9uchar code tabel[]= &#123;0x3F, 0x06, 0x5B, 0x4F, 0x66, 0x6D, 0x7D, 0x07, 0x7F, 0x6F,&#125;;//毫秒级延时函数定义void delay(uint z)&#123; uint x,y; for(x = z; x &gt; 0; x--) for(y = 114; y &gt; 0 ; y--); &#125; void main()//main函数自身会循环&#123; WE = 1;//打开位选锁存器 P0 = 0XFE; //1111 1110 WE = 0;//锁存位选数据 while(1) &#123; if(key_s2 == 0)//判断S2是否被按下 &#123; delay(20);//按键消抖 if(key_s2 == 0) &#123; if(num != 9)//如果值不等于9则+1，功能把值限定为小于9 num++; while(!key_s2);//松手检测 &#125; &#125; if(key_s3 == 0)//判断S3是否被按下 &#123; delay(20);//按键消抖 if(key_s3 == 0) &#123; if(num &gt; 0) //如果大于0则执行减一 num--; while(!key_s3);//松手检测 &#125; &#125; //松手之后刷新显示 DU = 1;//打开段选锁存器 P0 = tabel[num];// DU = 0;//锁存段选数据 &#125; &#125; 矩阵键盘 判断矩阵按键中某个按键是否按下可采用先列扫描再行扫描的方式 列扫描：先给P37, P36, P35, P34高电平，同时给P33,P32,P31,P30低电平，即传送 “0xF0”（11110000）过去，如果【S6】(或S10/S14/S18)按下，则P34就会被拉低，P3的引脚数据变为“0xE0”（1110 0000），S7按下，P35被拉低，变为“0xD1”（1101 0000），因此只要判断P3这一变量的数据变化即可判断是哪一列被按下了； 行扫描：给P3发送“0x0F”(0000 1111)，如果是【S6】按下，则P30被拉低，P3数据变为“0x0E”（0000 1110），如果是【S10】按下，P3数据变为“0x0D”（0000 1101），这样就可以判断出是哪个按键按下。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889/********************************************************************************** 【程序功能】： 4*4矩阵键盘与4位独立键盘识别 * 【使用说明】： 按下矩阵键盘和独立键盘任意键，数码管显示相应数值 初始显示“-”横**********************************************************************************/#include &lt;reg52.h&gt;//包含51头文件#include &lt;intrins.h&gt;//包含移位标准库函数头文件#define uint unsigned int#define uchar unsigned charsbit DU = P2^6;//数码管段选sbit WE = P2^7;//数码管段选uchar num;//数码管显示的值uchar KeyValue = 20;//按键值 显示-//共阴数码管段选表uchar code tabel[]= &#123;0x3F, 0x06, 0x5B, 0x4F, 0x66, 0x6D, 0x7D, 0x07, 0x7F,0x6F, 0x77, 0x7C, 0x39, 0x5E, 0x79, 0x71, 0x76, 0x38, 0x37, 0x3E, 0x40, 0x00 &#125;; //0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F,H,L,,n,u,-,熄灭void delay(uint z)&#123; uint x,y; for(x = z; x &gt; 0; x--) for(y = 114; y &gt; 0 ; y--); &#125; void KeyScan()&#123; //4*4矩阵键盘扫描 P3 = 0XF0;//列扫描 if(P3 != 0XF0)//判断按键是否被按下 &#123; delay(10);//软件消抖10ms if(P3 != 0XF0)//判断按键是否被按下 &#123; switch(P3) //判断那一列被按下 &#123; case 0xe0: KeyValue = 0; break;//第一列被按下 case 0xd0: KeyValue = 1; break;//第二列被按下 case 0xb0: KeyValue = 2; break;//第三列被按下 case 0x70: KeyValue = 3; break;//第四列被按下 &#125; P3 = 0X0F;//行扫描 switch(P3) //判断那一行被按下 &#123; case 0x0e: KeyValue = KeyValue; break;//第一行被按下 case 0x0d: KeyValue = KeyValue + 4; break;//第二行被按下 case 0x0b: KeyValue = KeyValue + 8; break;//第三行被按下 case 0x07: KeyValue = KeyValue + 12; break;//第四行被按下 &#125; while(P3 != 0X0F);//松手检测 &#125; &#125; P3 = 0XFF;//独立按键扫描 if(P3 != 0XFF) &#123; delay(10);//软件消抖10ms if(P3 != 0XFF) &#123; switch(P3) //判断那一行被按下 &#123; case 0xfe: KeyValue = 16; break;//S2被按下 case 0xfd: KeyValue = 17; break;//S3被按下 case 0xfb: KeyValue = 18; break;//S4被按下 case 0xf7: KeyValue = 19; break;//S5被按下 &#125; while(P3 != 0XFF);//松手检测 &#125; &#125;&#125;void main()//main函数自身会循环&#123; WE = 1;//打开位选锁存器 P0 = 0XFE; //1111 1110 WE = 0;//锁存位选数据 DU = 1;//打开段选锁存器 while(1) &#123; KeyScan();//20个按键键盘扫描 P0 = tabel[KeyValue];//显示按键值 &#125; &#125; 总结：先列扫描，再行扫描；或者先行扫描，再列扫描"},{"title":"","date":"2024-03-31T14:49:40.667Z","updated":"2024-03-31T14:49:40.667Z","comments":true,"path":"notes/51/mcu51_2/index.html","permalink":"https://blog.ajream.top/notes/51/mcu51_2/","excerpt":"","text":"定时计数器 51单片机有2个16位定时器/计数器：定时器T0（T0为P3.4）和定时器T1（T1为P3.5） 这里所说的16位是指定时/计数器内部分别有16位的计数寄存器。 当工作在定时模式时，每经过一个机器周期（约1.085us）内部的16位计数寄存器的值就会加1，当这个寄存器装满时溢出。 可以算出工作在定时模式时最高单次定时时间：65535*1.085us 当工作在计数器模式时，T0(P3.4引脚)或T1（P3.5引脚）每来一个脉冲计数寄存器加1 使用定时-计数器 （一）启动定时计数器 T0/T1的启动由控制寄存器是TCON（可位寻址）控制，如下图（IE1/IE0/IT1/IT0先不用看） 总结：TRx用来启动定时计数器Tx，TFx用来判断什么时候溢出（Tx表示是T0还是T1） （二）设定定时计数器的工作模式 这一步由寄存器TMOD（不可位寻址）控制 第7位和第3位（GATE位）：置1时只有外部引脚INT1/INT0为高电平、且开启了定时计数器（TRx=1）时，定时计数器才会开始计数 第6位和第2位（C/T位）：为1时表示工作在计数模式（外部来一个脉冲就+1），为0表示工作在定时模式 M1/M0位：用于选择定时计数器是计数方式（前面说过，这是16位定时计数器，但不一定全部16位都用，可以只用其中几位），有4种方式： M1 M0 工作方式及说明（TLx、THx分别表示Tx定时计数器【共16位】的低8位、高8位） 0 0 13位计数方式，TLx用低5位，THx的8位全用，总共13位，可以从0计数到：213−1=81912^{13}-1=8191213−1=8191 0 1 16位计数方式，即TLx的8位，THx的8位全部使用，计数值0~65535 1 0 8位自动重装载方式，溢出时自动将THx的值装载到TLx里面 1 1 如果是T1此时该定时计数器失效；如果是T0，这时T0的高8位TH0作为T1使用（由TR1、TF1启动、判断溢出），但只能计数到（28−1=2552^8-1=25528−1=255），TL0还是自己（T0）使用（由TR0、TF0启动、判断溢出） （三）查询定时计数器是否溢出 上面（第一点）：TFx溢出时会被硬件自动置为1， 但前提是使用了中断函数，否则可以用程序清0 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596/******************************************************************* 【程序功能】： 定时器0工作模式1 16位定时模式，数码管动态显示0-10，秒表。 *******************************************************************/#include &lt;reg52.h&gt;#include &lt;intrins.h&gt;#define uint unsigned int#define uchar unsigned charsbit DU = P2^6;//数码管段选sbit WE = P2^7;//数码管段选//共阴数码管段选表0-9uchar code tabel[]= &#123;0x3F, 0x06, 0x5B, 0x4F, 0x66, 0x6D, 0x7D, 0x07, 0x7F, 0x6F,&#125;;void delay(uint z)&#123; uint x,y; for(x = z; x &gt; 0; x--) for(y = 114; y &gt; 0 ; y--); &#125; void display(uchar i)&#123; uchar bai, shi, ge; bai = i / 100; //236 / 100 = 2 shi = i % 100 / 10; //236 % 100 / 10 = 3 ge = i % 10;//236 % 10 =6 //第一位数码管 P0 = 0XFF;//清除断码 WE = 1;//打开位选锁存器 P0 = 0XFE; //1111 1110 WE = 0;//锁存位选数据 DU = 1;//打开段选锁存器 P0 = tabel[bai];// DU = 0;//锁存段选数据 delay(5); //第二位数码管 P0 = 0XFF;//清除断码 WE = 1;//打开位选锁存器 P0 = 0XFD; //1111 1101 WE = 0;//锁存位选数据 DU = 1;//打开段选锁存器 P0 = tabel[shi];// DU = 0;//锁存段选数据 delay(5); //第三位数码管 P0 = 0XFF;//清除断码 WE = 1;//打开位选锁存器 P0 = 0XFB; //1111 1011 WE = 0;//锁存位选数据 DU = 1;//打开段选锁存器 P0 = tabel[ge];// DU = 0;//锁存段选数据 delay(5);&#125;//定时器T0初始化void T0_init()&#123; TR0 = 1; //启动定时器0 TMOD = 0X01; //定时器工作模式1，16位定时器计数模式 TH0 = 0x4b; TL0 = 0xfd; //定时50ms //0x4bfd即19453，共计数65535-19453+1 = 46083次，耗时46083*1.085us = 50 ms&#125;void main()//main函数自身会循环&#123; uchar mSec, Sec;//毫秒和秒储存变量 T0_init();//定时器T0初始化 while(1) &#123; if(TF0 == 1)//判断是否溢出 &#123; TF0 = 0;//软件清零溢出标志位 TH0 = 0x4b; TL0 = 0xfd; //定时50ms mSec++;//50ms到 if(mSec == 20) &#123; mSec = 0; Sec++;//1秒时间到 &#125; &#125; display(Sec); //数码管显示函数 if(Sec &gt; 10) Sec = 0;//秒清零 &#125; &#125; 方式1初值计算方法，假如定时t(单位：us)，使用T0: 则： 123TH0 = (65535 - t / 1.085) / 256TL0 = (65535 - t / 1.085) % 256四舍五入取整后转换为16进制 中断系统 主程序正在执行某一事件，突然发生一个紧急事件，需要中断当前正在执行的程序，去处理这一紧急事件，这就是中断 引起CPU中断的根源，称为中断源。中断源向CPU提出的中断请求。CPU暂时中断原来的事务A，转去处理事件B。对事件B处理完毕后，再回到原来被中断的地方（即断点），称为中断返回。实现上述中断功能的部件称为中断系统（中断机构）。 51子系列存在5个中断源： 外部中断源2个 INT0——由P3.2端口线引入，低电平或下降沿引起。 INT1——由P3.3端口线引入，低电平或下降沿引起。 这两个外部中断源标志和它们的触发方式控制位由特殊功能寄存器TCON的低4位控制 内部中断源3个 T0——定时器/计数器0中断，由T0回零溢出引起。 T1——定时器/计数器1中断，由T1回零溢出引起。 TI/RI——串行I/O中断，串行端口完成一帧字符发送/接收后引起。 这3个内部中断源的控制位分别锁存在特殊功能寄存器TCON和SCON中。 使用中断 如何使用中断，有3大步骤： （一）允许产生中断 要允许产生中断首先要配置中断允许寄存器IE和XICON (可位寻址表示每一位都已经用变量定义好了，比如第7位是EA) 总结：要允许中断，必须先开启总中断EA=1，再开启对应模块的中断 （二）设置什么时候响应中断 什么时候响应中断由控制寄存器TCON控制 TFx：当计数值溢出时，就会向cpu发出中断请求，然后自动进入对应的中断处理函数，然后TFx由硬件自动清0 其它IEx, ITx也差不多是这样 （三）产生中断后你要干什么——中断处理函数 中断处理函数的功能就是当产生中断后你要干什么，这个函数有格式要求，不需要主动调用，由cpu响应中断时自动调用： 格式如下： 12345void 函数名() interrupt 中断入口号 //中断处理函数，加关键字interrupt和入口号0/1/2/3/4&#123; //中断处理语句&#125; 中断优先级： 如果有多个中断同时产生，该调用哪个中断处理函数呢，因此引出了中断优先级这个概念 中断优先级级别越高，就越先被执行 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293/*定时器0, 工作模式1, 16位定时计数数码管动态显示0-10，每隔1秒显示一次*/#include &lt;reg52.h&gt;#include &lt;intrins.h&gt;#define uint unsigned int#define uchar unsigned charsbit DU = P2^6;//数码管段选sbit WE = P2^7;//数码管段选sbit key_s2 = P3^0;//独立按键S2sbit key_s3 = P3^1;//独立按键S3uchar num;//数码管显示的值uchar mSec, Sec;//毫秒和秒储存变量//共阴数码管段选表0-9uchar code SMGduan[]= &#123;0x3F, 0x06, 0x5B, 0x4F, 0x66, 0x6D, 0x7D, 0x07, 0x7F, 0x6F,&#125;;//数码管位选码uchar code SMGwei[] = &#123;0xfe, 0xfd, 0xfb&#125;;void delay(uint z)&#123; uint x,y; for(x = z; x &gt; 0; x--) for(y = 114; y &gt; 0 ; y--); &#125; void display(uchar i)&#123; static uchar wei; P0 = 0XFF;//清除断码 WE = 1;//打开位选锁存器 P0 = SMGwei[wei]; WE = 0;//锁存位选数据 switch(wei) &#123; case 0: DU = 1; P0 = SMGduan[i / 100]; DU = 0; break; case 1: DU = 1; P0 = SMGduan[i % 100 / 10]; DU = 0; break; case 2: DU = 1; P0 = SMGduan[i % 10]; DU = 0; break; &#125; wei++; if(wei == 3) wei = 0;&#125;//定时器0初始化void T0_init()&#123; EA = 1; //打开总中断 ET0 = 1;//打开定时器0中断 TR0 = 1; //启动定时器0 TMOD = 0X01; //定时器工作模式1，16位定时模式 TH0 = 0xED; TL0 = 0xFF; //定时5ms&#125;void main() //主程序执行按键扫描&#123; T0_init();//定时器0初始化 while(1) &#123; if(key_s2 == 0)//判断S2是否被按下 &#123; delay(20);//按键消抖 if(key_s2 == 0) &#123; if(num != 120) num++; while(!key_s2);//松手检测 &#125; &#125; if(key_s3 == 0)//判断S3是否被按下 &#123; delay(20);//按键消抖 if(key_s3 == 0) &#123; if(num &gt; 0) num--; while(!key_s3);//松手检测 &#125; &#125; &#125; &#125; //定时器0中断处理函数void timer0() interrupt 1 //T0中断入口为1&#123; TH0 = 0xED; TL0 = 0xFF; //定时5ms display(num); //数码管显示s&#125;"},{"title":"","date":"2024-03-31T14:49:40.667Z","updated":"2024-03-31T14:49:40.667Z","comments":true,"path":"notes/51/mcu51_3/index.html","permalink":"https://blog.ajream.top/notes/51/mcu51_3/","excerpt":"","text":"串口通信 原理简介 通信有并行通信和串行通信两种方式。在多微机系统以及现代测控系统中信息的交换多采用串行通信方式 并行通信 并行通信通常是将数据字节的各位用多条数据线同时进行传送 特点：并行通信控制简单、传输速度快；由于传输线较多，长距离传送时成本高且接收方的各位同时接收存在困难。 串行通信 串行通信是使用一条数据线，将数据一位一位地依次传输，每一位数据占据一个固定的时间长度。其只需要少数几条线就可以在系统间交换信息。 同步、异步通信 串行通信又分 同步、异步两种 同步：接收方与发送方时钟一致 异步：双方使用各自的时钟，但应该尽可能保持一致 数据传输方向 单工：一台设备只能收/发 半双工：同一时间只能收或发 全双工：可同时进行收发 奇偶校验 在发送数据时，数据位尾随的1位为奇偶校验位（1或0）。 奇校验时，数据中“1”的个数与校验位“1”的个数之和应为奇数； 偶校验时，数据中“1”的个数与校验位“1”的个数之和应为偶数。接收字符时，对“1”的个数进行校验，若发现不一致，则说明传输数据过程中出现了差错。 代码和校验 代码和校验是发送方将所发数据块求和（或各字节异或），产生一个字节的校验字符（校验和）附加到数据块末尾。接收方接收数据同时对数据块（除校验字节外）求和（或各字节异或），将所得的结果与发送方的“校验和”进行比较，相符则无差错，否则即认为传送过程中出现了差错。 循环冗余校验 这种校验是通过某种数学运算实现有效信息与校验位之间的循环校验，常用于对磁盘信息的传输、存储区的完整性校验等。这种校验方法纠错能力强，广泛应用于同步通信中。 使用串口进行数据发送和接收 初始化配置 打开总中断和串口中断 **选择串口工作方式（配置串口控制寄存器SCON）**不懂就先选方式1 允许串口接收（配置串口控制寄存器SCON） 配置波特率 假如选择波特率为9600，根据下面的公式计算出定时计数器的初值，SMOD没有配置默认为0，fosc为频率11.0592MHz，定时计数器选择工作方式2（8位自动重装），计算得到初值为253，即0xFD 代码如下： 123456789101112void UARTInit()&#123; EA = 1; //打开总中断 ES = 1; //打开串口中断 SM0 = 0; SM1 = 1; //串口工作方式1,8位UART波特率可变 REN = 1;//串口允许接收 TR1 = 1;//启动定时器1 TMOD |= 0x20;//定时器1，工作模式2 8位自动重装 TH1 = 0xfd; TL1 = 0xfd;//设置比特率9600&#125; 说明：TMOD |= 1， 使用了 |= 运算符，因为这里使用T1定时器，在前面实际还有关于定时器T0的配置，要让T0, T1同时工作， 就要同时设置T1和T0的工作方式 这是T0的初始化： 1234567891011121314void T0_init()&#123; EA = 1; //打开总中断 ET0 = 1;//打开定时器0中断 TR0 = 1; //启动定时器0 REN = 1;//允许串口接收 TMOD |= 0X01; //定时器工作模式1，16位定时模式 TH0 = 0xED; TL0 = 0xFF; //定时5ms&#125;void UARTInit()&#123;//......&#125; 发送、接收数据 接收：通过读取接收缓冲器SBUF中的数据 发送：通过往发送缓冲器SBUF写入数据 发送、接收缓冲器物理上是相互独立的，但它们占用同一地址0x99 RI、TI看这2幅图，如下 12345678910111213void UART() interrupt 4&#123; uchar temp; if(RI) //判断接收是否完成 &#123; num = SBUF; //读SBUF，读出串口接收到的数据 RI = 0; //软件清零接收标志位 temp = num; SBUF = ++temp; //写SBUF，把要发送的数据送给发送缓存器 &#125; if(TI) //判断是否发送完成 TI = 0; //清零发送完成标志位 &#125; 完整代码：使用串口接收数据，用数码管显示，然后把数据+1后发出 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;reg52.h&gt;#include &lt;intrins.h&gt;#define uint unsigned int#define uchar unsigned charsbit DU = P2^6;//数码管段选sbit WE = P2^7;//数码管段选uchar num;//数码管显示的值//共阴数码管段选表0-9uchar code SMGduan[]= &#123;0x3F, 0x06, 0x5B, 0x4F, 0x66, 0x6D, 0x7D, 0x07, 0x7F, 0x6F,&#125;;//数码管位选码uchar code SMGwei[] = &#123;0xfe, 0xfd, 0xfb&#125;;void display(uchar i)&#123; static uchar wei; P0 = 0XFF;//清除断码 WE = 1;//打开位选锁存器 P0 = SMGwei[wei]; WE = 0;//锁存位选数据 switch(wei) &#123; case 0: DU = 1; P0 = SMGduan[i / 100]; DU = 0; break; case 1: DU = 1; P0 = SMGduan[i % 100 / 10]; DU = 0; break; case 2: DU = 1; P0 = SMGduan[i % 10]; DU = 0; break; &#125; wei++; if(wei == 3) wei = 0;&#125;//定时器0初始化void T0_init()&#123; EA = 1; //打开总中断 ET0 = 1;//打开定时器0中断 TR0 = 1; //启动定时器0 REN = 1;//允许串口接收 TMOD |= 0X01; //定时器工作模式1，16位定时模式 TH0 = 0xED; TL0 = 0xFF; //定时5ms&#125;//串口初始化void UART_init()&#123; EA = 1; //打开总中断 ES = 1; //打开串口中断 SM0 = 0; SM1 = 1;//串口工作方式1,8位UART波特率可变 REN = 1;//串口允许接收 TR1 = 1;//启动定时器1 TMOD |= 0x20;//定时器1，工作模式2 8位自动重装 TH1 = 0xfd; TL1 = 0xfd;//设置比特率9600&#125;void main()//main函数自身会循环&#123; T0_init();//定时器0初始化 UART_init();//串口初始化 while(1); &#125; //定时器0中断函数void t0() interrupt 1&#123; TH0 = 0xED; TL0 = 0xFF; //定时5ms display(num); //数码管显示函数 &#125;//串口中断函数void UART() interrupt 4&#123; uchar temp; if(RI)//判断接收是否完成 &#123; num = SBUF;//读SBUF，读出串口接收到的数据 RI = 0;//软件清零接收标志位 temp = num;// SBUF = ++temp;//写SBUF，把要发送的数据送给发送缓存器 &#125; if(TI)//判断是否发送完成 TI = 0;//清零发送完成标志位 &#125;"},{"title":"","date":"2024-03-31T14:49:40.667Z","updated":"2024-03-31T14:49:40.667Z","comments":true,"path":"notes/51/mcu51_4/index.html","permalink":"https://blog.ajream.top/notes/51/mcu51_4/","excerpt":"","text":"目前常用的微机与外设之间进行数据传输的串行总线主要有UART、1-wire、I2C和SPI总线 UART:是以异步方式进行通信（一条数据输入线，一条数据输出线）。 1-wire：即单线总线，又叫单总线(只有一条线)。 I2C：同步串行2线方式进行通信（一条时钟线，一条数据线）。 SPI：同步串行3线方式进行通信（一条时钟线，一条数据输入线，一条数据输出线）。 原理 IIC串行总线，只有两根双向信号线。一根是数据线SDA，另一根是时钟线SCL 如下图所示，IIC总线上可以挂多个器件，而每个器件都有唯一的地址，这样可以标识通信目标。数据的通信的方式采用主从方式，主机负责主动联系从机，而从机则被动回应数据 在多主机系统中，可能同时有几个主机企图启动总线传送数据。为了避免混乱，I2C总线要通过总线仲裁，以决定由哪一台主机控制总线。 在80C51单片机应用系统的串行总线扩展中，我们经常遇到的是以80C51单片机为主机，其它接口器件为从机的单主机情况 总线“线与关系”：I2C总线通过上拉电阻接正电源。当总线空闲时，两根线均为高电平。连到总线上的任一器件输出的低电平，都将使总线的信号变低， 即SDA = SDA1 &amp; SDA2 &amp; SDA3 &amp; ..., SCL=SCL1 &amp; SCL2 &amp; SCL3 &amp; ... 起始信号和终止信号 SCL线为高电平期间，SDA线由高电平向低电平的变化表示起始信号； SCL线为高电平期间，SDA线由低电平向高电平的变化表示终止信号。 数据位有效性 SCL为高电平期间，数据线上的数据必须保持稳定 只有SCL信号为低电平期间，SDA状态才允许变化。 IIC总线的传送与应答 每一个字节必须保证是8位长度。数据传送时，先传送最高位（MSB），每一个被传送的字节最后面都必须跟随一位应答位（即一帧共有9位） 主机通过从机发出的应答位来判断从机是否成功接收数据: 从机正忙于其他事情，发出应答1，表示没有收到 当从机空闲可以接收该字节数据时，从机会发出应答0 当主机接收数据时，它收到最后一个数据字节后，必须向从机发出一个结束传送的信号。这个信号是由对从机的“非应答”来实现的。然后，从机释放SDA线，以允许主机产生终止信号。 数据帧格式 在起始信号后必须传送一个从机的地址（7位），第8位是数据的传送方向位（R/T），用&quot;0&quot;表示主机发送数据（T），&quot;1&quot;表示主机接收数据（R）。 每次数据传送总是由主机产生的终止信号结束。但是，若主机希望继续占用总线进行新的数据传送，则可以不产生终止信号，马上再次发出起始信号对另一从机进行寻址。 软件模拟IIC总线传送数据 主机可以采用不带IIC总线接口的单片机，如80C51、STC89C52等单片机，利用软件实现IIC总线的数据传送，即软件与硬件结合的信号模拟。 为保证数据的可靠性，I2C总线的数据传送有严格的时序要求。I2C总线的起始信号、终止信号、发送“0”及发送“1”的模拟时序 ： 模拟的代码如下： 12345678910111213141516171819//起始信号void I2cStart()&#123; SCL = 1; SDA = 1; delay5us(); //SDA在拉低低之前，应该先保持高电平时间&gt;4us,这里用5us SDA = 0; delay5us(); //SDA保持低电平时间&gt;4us,这里用5us&#125;//终止信号void I2cStop()&#123; SCL = 0; SDA = 0; SCL = 1; delay5us(); SDA = 1; delay5us();&#125; 第3、4个图表示先将SCL拉高5us，然后读取并返回SDA的值，读取后将SCL拉低，代码如下 123456789101112131415//主机读取从机的应答bit ReadACK()&#123; SCL = 1; delay5us(); if(SDA)&#123; SCL = 0; return(1); &#125; else&#123; SCL = 0; return(0); &#125;&#125; 发送数据i，在SCL为低时，将SDA拉高或拉低（根据发送的数据确定，如果发送1，则拉高，反之拉低）；然后将SCL拉高，保持5us，再将SCL拉低，这样就发送了一位（bit）数据，最后释放总线 123456789101112//主机发送应答void SendACK(bit i)&#123; SCL = 0; if(i) SDA = 1; else SDA = 0; SCL = 1; delay5us(); SCL = 0; //拉低时钟总线 SDA = 1; //释放数据总线&#125; 串行EEPROM的扩展 Ateml公司的AT24C系列： AT24C01：128字节（128×8位） AT24C02：256字节（256×8位） AT24C04：512字节（512×8位）AT24C08：1K字节（1K×8位） AT24C16：2K字节（2K×8位） 写入过程 **获取地址码：**AT24C系列E2PROM芯片地址的固定部分为1010，而当A2、A1、A0引脚接高、低电平后就得到确定的3位编码。形成的7位编码即为该器件的地址码。例如在开发板中A2, A1, A0都接地，则这7位码为 1010000 **写操作：**单片机进行写操作时，首先发送该器件的7位地址码和写方向位“0”（共8位，即一个字节），发送完后释放SDA线并在SCL线上产生第9个时钟信号。被选中的存储器器件在确认是自己的地址后，在SDA线上产生一个应答信号作为相应，单片机收到应答后就可以传送数据了。 传送数据： 这个过程单片机首先发送一个字节被写入器件的存储区首地址，收到存储器器件的应答后，单片机就逐个发送各数据字节，但每发送一个字节后都要等待应答。 AT24C系列器件片内地址在接收到每一个数据字节地址后自动加1（表示相对之前写入的位置往后移一位） 当要写入的数据传送完后，单片机应发出终止信号以结束写入操作。写入n个字节的数据格式如下： 说明：S为起始信号，然后是7位地址码+ 0（0表示写操作），然后写入第一个数据存放位置的首地址，后面的写入的数据自动往后移动一位，写入1Byte数据后，器件发送应答A确认已写入，最后如果写入完成后发送终止信号P。 注意：在芯片的“一次装载字节数”（不同芯片字节数不同）限度内，只需输入首地址。装载字节数超过芯片的“一次装载字节数”时，数据地址将“上卷”，前面的数据将被覆盖。 读出过程 单片机先发送该器件的7位地址码和写方向位“0”（“伪写”），发送完后释放SDA线并在SCL线上产生第9个时钟信号。被选中的存储器器件在确认是自己的地址后，在SDA线上产生一个应答信号作为回应。 然后，再发一个字节的要读出器件的存储区的首地址，收到应答后，单片机要重复一次起始信号并发出器件地址和读方向位（“1”），收到器件应答后就可以读出数据字节，每读出一个字节，单片机都要回复应答信号。 当最后一个字节数据读完后，单片机应返回以“非应答”（高电平），并发出终止信号以结束读出操作。 完整代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268/********************************************************************************** 【实验平台】： 清翔 QX-MCS51 单片机开发板* 【外部晶振】： 11.0592mhz * 【主控芯片】： STC89C52* 【编译环境】： Keil μVisio4 * 【程序功能】： IIC通信，AT24C02读写数据，数码管显示数据。 **********************************************************************************/#include &lt;reg52.h&gt;#include &lt;intrins.h&gt;#define uint unsigned int#define uchar unsigned char#define At24c02ADDR 0XA0 //AT24C02硬件地址#define I2cRead 1 //I2C读方向位#define I2cWrite 0 //I2C写方向位sbit DU = P2^6;//数码管段选sbit WE = P2^7;//数码管段选sbit SCL = P2^1;//I2C时钟总线sbit SDA = P2^0;//I2C数据总线uchar num;//数码管显示的值bit AckFlag;//应答标志位//共阴数码管段选表0-9uchar code SMGduan[]= &#123;0x3F, 0x06, 0x5B, 0x4F, 0x66, 0x6D, 0x7D, 0x07, 0x7F, 0x6F,&#125;;//数码管位选码uchar code SMGwei[] = &#123;0xfe, 0xfd, 0xfb&#125;;/*====================================函数 ： delay(uint z)参数 ：z 延时毫秒设定，取值范围0-65535返回值 ：无描述 ：12T/Fosc11.0592M毫秒级延时====================================*/void delay(uint z)&#123; uint x,y; for(x = z; x &gt; 0; x--) for(y = 114; y &gt; 0 ; y--); &#125; /*====================================函数 ：display(uchar i)参数 ：i 显示数值，取值范围0-255返回值 ：无描述 ：三位共阴数码管动态显示====================================*/void display(uchar i)&#123; static uchar wei; P0 = 0XFF;//清除断码 WE = 1;//打开位选锁存器 P0 = SMGwei[wei]; WE = 0;//锁存位选数据 switch(wei)&#123; case 0: DU = 1; P0 = SMGduan[i / 100]; DU = 0; break; case 1: DU = 1; P0 = SMGduan[i % 100 / 10]; DU = 0; break; case 2: DU = 1; P0 = SMGduan[i % 10]; DU = 0; break; &#125; wei++; if(wei == 3) wei = 0;&#125;//定时器0初始化void timer0Init()&#123; EA = 1; //打开总中断 ET0 = 1;//打开定时器0中断 TR0 = 1; //启动定时器0 TMOD |= 0X01; //定时器工作模式1，16位定时模式 TH0 = 0xED; TL0 = 0xFF; //定时5ms&#125;/****************************************************IIC通信代码****************************************************//*====================================函数 ：delay5us()参数 ：无返回值 ：无描述 ：5us延时函数====================================*/void delay5us()&#123; _nop_();&#125;/*====================================函数 ：I2cStart()参数 ：无返回值 ：无描述 ：I2C总线起始信号====================================*/void I2cStart()&#123;//时钟总线为高电平期间数据总线又高变低产生起始型号 SCL = 1; SDA = 1; delay5us();//状态保持5us SDA = 0; delay5us();//状态保持5us &#125;/*====================================函数 ：I2cStop()参数 ：无返回值 ：无描述 ：I2C总线停止信号====================================*/void I2cStop()&#123;//时钟总线为高电平期间，数据总线从高变低产生终止信号 SCL = 0; SDA = 0; SCL = 1; delay5us();//状态保持5us SDA = 1; delay5us();//状态保持5us &#125;/*====================================函数 ：ReadACK()参数 ：无返回值 ：1非应答，0应答描述 ：I2C总线读从机应答信号====================================*/bit ReadACK()&#123; SCL = 0; //拉低时钟总线，允许从机控制SDA SCL = 1; //拉高，读SDA delay5us(); if(SDA)&#123; //NOACK SCL = 0; return(1); //返回1 &#125; else&#123; //ACK SCL = 0; return(0); //返回0 &#125;&#125;/*====================================函数 ：SendACK(bit i)参数 ：1主机发送非应答，0发送应答返回值 ：无描述 ：主机发送应答信号====================================*/void SendACK(bit i)&#123; SCL = 0;//拉低时钟总线，允许主机控制SDA if(i) //发非应答 SDA = 1; else //发应答 SDA = 0; SCL = 1; //拉高总线，让从机读SDA delay5us();//保持5us SCL = 0; //拉低时钟总线，允许SDA释放 SDA = 1;//释放数据总线&#125;/*====================================函数 ：I2cSendByte(uchar DAT)参数 ：DAT需要发送的数据返回值 ：无描述 ：I2C发送一个字节数据====================================*/void I2cSendByte(uchar DAT)&#123; uchar i; for(i=0; i&lt;8; i++)&#123; //分别写8次，每次写1位 SCL = 0;//拉低时钟总线，允许SDA变化 if(DAT &amp; 0x80)//先写数据最高位 SDA = 1; //写1 else SDA = 0; //写0 SCL = 1; //拉高时钟，让从机读SDA DAT &lt;&lt;= 1; //为发送下一位左移1位 &#125; SCL = 0; //拉低时钟总线，允许SDA释放 SDA = 1;//释放数据总线&#125;/*====================================函数 ：At24c02Write(uchar ADDR, DAT)参数 ：ADDR 单元地址0-255，DAT 需要输入的数据0-255返回值 ：无描述 ：At24c02指定单元写入一个字节数据====================================*/void At24c02Write(uchar ADDR, DAT)&#123; I2cStart();//I2C起始信号 I2cSendByte(At24c02ADDR + I2cWrite);//发送器件地址加读写方向位 if(ReadACK()) //读从机应答 AckFlag = 1; //NOACK else AckFlag = 0; //ACK I2cSendByte(ADDR);//发送储存单元地址字节 if(ReadACK())//读从机应答 AckFlag = 1; //NOACK else AckFlag = 0; //ACK I2cSendByte(DAT);//发送一字节数据 if(ReadACK())//读从机应答 AckFlag = 1; //NOACK else AckFlag = 0; //ACK I2cStop(); //I2C停止信号&#125;/*====================================函数 ：I2cReadByte()参数 ：无返回值 ：返回读出的一字节数据描述 ：I2C总线读一字节数据====================================*/uchar I2cReadByte()&#123; uchar i, DAT; for(i=0; i&lt;8; i++)&#123; //分别读8次，每次读一位 DAT &lt;&lt;= 1; //数据左移1位，准备接收一位 SCL = 0; //拉低时钟总线，允许从机控制SDA变化 SCL = 1; //拉高时钟总线，读取SDA上的数据 if(SDA) DAT |= 0X01; //为1则写1，否则不行执行写1，通过左移补0 &#125; return(DAT); //返回读出的数据&#125;/*====================================函数 ：At24c02Read(uchar ADDR)参数 ：ADDR 单元地址 0-255返回值 ：返回指定单元的数据描述 ：读AT24C02指定单元内数据====================================*/uchar At24c02Read(uchar ADDR)&#123; uchar DAT; I2cStart();//I2C起始信号 I2cSendByte(At24c02ADDR + I2cWrite);//发送器件地址加读写方向位 if(ReadACK())//读从机应答 AckFlag = 1; //NOACK else AckFlag = 0; //ACK I2cSendByte(ADDR);//I2C发送一个字节 ReadACK();//读从机应答 I2cStart();//再次产生I2C起始信号 I2cSendByte(At24c02ADDR + I2cRead);//发送器件地址加读写方向位 读 if(ReadACK())//读从机应答 AckFlag = 1; //NOACK else AckFlag = 0; //ACK DAT = I2cReadByte();//读一字节 SendACK(1);//主机发送非应答 I2cStop(); //I2C停止信号 return(DAT);//返回读出数据 &#125;void main()//main函数自身会循环&#123; timer0Init();//定时器0初始化 EA = 0;//屏蔽中断 At24c02Write(3, 188);//给第3单元写入数据“188” delay(1);//延时等待AT24C02处理 num = At24c02Read(3);//读出第3单元内数据送给显示变量 if(AckFlag)//当从机非应答 P1 = 0;//亮P1所有灯 else P1 = 0XFF;//灭P1所有灯 EA = 1;//开中断 while(1);&#125; //定时器0中断函数void timer0() interrupt 1 &#123; TH0 = 0xED; TL0 = 0xFF; //定时5ms display(num); //数码管显示函数 &#125;"},{"title":"","date":"2024-03-31T14:49:40.667Z","updated":"2024-03-31T14:49:40.667Z","comments":true,"path":"notes/51/mcu51_5/index.html","permalink":"https://blog.ajream.top/notes/51/mcu51_5/","excerpt":"","text":"逐次逼近式AD转换器 这是一个基本原理图 首先，内部产生一个参考电压Vref，然后与要进行测量的电压Vin进行比较，如果Vref&lt;=Vin，就产生一个“1”信号（否则产生“0”信号），并存储到N位寄存器的最高位，然重新生成参考电压信号Vref = Vref+0.5Vref，（如果前面产生的是“0”信号，则新的参考电压Vref = 0.5Vref），再与Vin比较，将比较结果（“0”或“1”存到寄存器的下一位），循环往复，直到N位寄存器全部存满数据，最后通过锁存器输出转化后的数字信号。 比如：Vin = 3.75V, Vref = 2.5V Vref=2.5 &lt; 3.75，因此寄存器最高位存储数据1，然后重新生成Vref = 2.5+0.5*2.5 = 3.75 此时Vref=3.75 == Vin, 返回比较结果1， 存储下来， 然后重新生成Vref = 3.75+3.75*0.5 = 5.6 此时Vref=5.6 &gt; Vin，返回比较结果0，存储下来。。。。。 最后结果是：1100 0000 PCF8591模块 简介 PCF8591 是单电源，低功耗8 位CMOS 数据采集器件，具有4 个模拟输入、一个输出和一个串行 I2C 总线接口； 3个地址引脚A0、A1 和 A2 用于编程硬件地址，允许将最多8个器件连接至I2C总线而不需要额外硬件； PCF8591由于其使用的简单方便和集成度高，在单片机应用系统中得到了广泛的应用。 特点： 单电源供电 工作电压：2.5 V ~ 6 V I2C总线串行输入/输出 通过3个硬件地址引脚编址 采样速率取决于 I2C 总线传输速率决定 4个模拟输入可编程为单端或差分输入 自动增量通道选择 8位逐次比较型 A/D 转换 管脚定义： AIN0~AIN3：模拟量输入通道 AOUT：模拟输出通道 A0~A2：硬件设备地址 VDD：电源正极 VSS：电源负极 VREF：参考电压输入。 EXT：振荡器输入时，内部/外部的切换开关。 OSC：振荡器输入/输出。 SCL：I2C BUS时钟输入。 SDA：I2C BUS 数据输入/输出。 AGND：模拟地，模拟信号和基准电源的参考地 开发板中的PCF8591接线： PCF8591地址 I2C 总线系统中的每一片PCF8591 通过发送有效地址到该器件来激活。该地址包括固定部分和可编程部分 可编程部分必须根据地址引脚A0、A1 和 A2 来设置，因此I2C系统中最多可接8个PCF8591 在I2C 总线协议中地址必须是起始条件后作为第一个字节发送。 地址字节的最后一位是用于设置以后数据传输方向的读/写位（1为读操作，0为写操作） PCF8591控制字节 发送到 PCF8591 的第二个字节将被存储在控制寄存器，用于控制器件功能。 控制寄存器的高半字节用于允许模拟输出，以及可以将模拟输入编程为单端或差分输入。 低半字节选择一个由高半字节定义的模拟输入通道。如果自动增量（auto-increment）标志置1，每次A/D 转换后通道号将自动增加。 例子 (一) 利用I2C通信，PCF8591模数/数模转换，读取通道2电位器模拟量，通过数码管显示 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353/********************************************************************************** 【作 者】： 清翔电子:向量* 【版 本】： V1.0* 【网 站】： http://www.qxmcu.com/ * 【淘宝店铺】： http://qxmcu.taobao.com/* 【实验平台】： 清翔 QX-MCS51 单片机开发板* 【外部晶振】： 11.0592mhz * 【主控芯片】： STC89C52* 【编译环境】： Keil μVisio4 * 【程序功能】： I2C通信，PCF8591模数/数模转换，读取通道2电位器模拟量，数码管 显示。 * 【使用说明】： 用手转动AD旁边的电位器头，数码管数值会随之变化。**********************************************************************************/#include &lt;reg52.h&gt;#include &lt;intrins.h&gt;#define PCF8591ADDR 0X90 //PCF8591地址#define I2cRead 1 //I2C读方向位#define I2cWrite 0 //I2C写方向位#define CH0 0 //AD通道0#define CH1 1 //AD通道1#define CH2 2 //AD通道2#define CH3 3 //AD通道3#define DAout 0x40 //DA输出命令#define MAIN_Fosc 11059200UL //宏定义主时钟HZ/*====================================使用typedef给已有数据类型取别名====================================*/typedef unsigned char INT8U;typedef unsigned char uchar;typedef unsigned char u8;typedef unsigned int INT16U;typedef unsigned int uint;typedef unsigned int u16;sbit DU = P2^6;//数码管段选sbit WE = P2^7;//数码管段选sbit SCL = P2^1; //I2C时钟总线sbit SDA = P2^0; //I2C数据总线uint num;//数码管显示的值bit AckFlag;//应答标志位//共阴数码管段选表0-9uchar code SMGduan[]= &#123;0x3F, 0x06, 0x5B, 0x4F, 0x66, 0x6D, 0x7D, 0x07, 0x7F, 0x6F,&#125;;//数码管位选码 //第1位 2位 3位 4位 5位 6位 7位 8位 uchar code SMGwei[] = &#123;0xfe, 0xfd, 0xfb, 0xf7, 0xef, 0xdf, 0xbf, 0x7f&#125;;//数码管位码/*====================================函数名 ：void delay(INT16U ms)参数 ：ms，毫秒延时形参返回值 ：无描述 ：12T 51单片机自适应主时钟毫秒级延时函数====================================*/void delay(INT16U ms)&#123; INT16U i; do&#123; i = MAIN_Fosc / 96000; while(--i); //96T per loop &#125;while(--ms);&#125;/*====================================函数 ：void delay5us()参数 ：无返回值 ：无描述 ：12T 51单片机5微秒延时函数自适应时钟====================================*/void delay5us()&#123; #if MAIN_Fosc == 11059200 _nop_(); #elif MAIN_Fosc == 12000000 _nop_(); #elif MAIN_Fosc == 22118400 _nop_(); _nop_(); _nop_(); #endif&#125;/*====================================函数 ：display(uchar i)参数 ：i 显示变量取值0-65535 返回值 ：无描述 ：数码管动态显示函数第一位显示小数点====================================*///void display(uint i)//&#123;// static uchar wei;// // P0 = 0XFF;//清除断码// WE = 1;//打开位选锁存器// P0 = SMGwei[wei];// WE = 0;//锁存位选数据//// switch(wei)// &#123;// case 0: DU = 1; P0 = SMGduan[i / 1000] | 0x80; DU = 0; break;//千位显示小数点// case 1: DU = 1; P0 = SMGduan[i % 1000 / 100]; DU = 0; break;//显示百位// case 2: DU = 1; P0 = SMGduan[i % 100 / 10]; DU = 0; break;//显示十位 // case 3: DU = 1; P0 = SMGduan[i % 10]; DU = 0; break;//显示个位 // &#125;// wei++;// if(wei == 4)// wei = 0;//&#125;/*====================================函数：display(INT16U Value)参数：Value,显示值 取值0-65535描述：共阴极数码管显示函数可显示一个字节的数====================================*/void display(INT16U Value) //注意由于需要显示的数大于一个字节所有形参需为int型&#123; //------------------------------ DU = 0; //关闭段选 P0 = SMGduan[Value/1000]|0x80; //数码管显示千位 DU = 1; //打开段选 DU = 0; //关闭段选 WE = 0; //关闭位选 P0 = SMGwei[0]; //第一位数码管 WE = 1; //打开位选 WE = 0; //关闭位选 delay(3);//------------------------------- DU = 0; P0 = SMGduan[Value%1000/100]; //显示百位 DU = 1; DU = 0; WE = 0; P0 = SMGwei[1]; //第二位数码管 WE = 1; WE = 0; delay(3);//------------------------------- DU = 0; P0 = SMGduan[Value%100/10]; //显示十位 DU = 1; DU = 0; WE = 0; P0 = SMGwei[2]; //第三位数码管 WE = 1; WE = 0; delay(3);//------------------------------- DU = 0; P0 = SMGduan[Value%10]; //显示个位 DU = 1; DU = 0; WE = 0; P0 = SMGwei[3]; //第四位数码管 WE = 1; WE = 0; delay(3);&#125;/****************************************************IIC通信代码****************************************************//*====================================函数 ：I2cStart()参数 ：无返回值 ：无描述 ：I2C总线起始信号====================================*/void I2cStart()&#123;//时钟总线为高电平期间数据总线又高变低产生起始型号 SCL = 1; SDA = 1; delay5us();//状态保持5us SDA = 0; delay5us();//状态保持5us &#125;/*====================================函数 ：I2cStop()参数 ：无返回值 ：无描述 ：I2C总线停止信号====================================*/void I2cStop()&#123;//时钟总线为高电平期间，数据总线从高变低产生终止信号 SCL = 0; SDA = 0; SCL = 1; delay5us();//状态保持5us SDA = 1; delay5us();//状态保持5us &#125;/*====================================函数 ：ReadACK()参数 ：无返回值 ：1非应答，0应答描述 ：I2C总线读从机应答信号====================================*/bit ReadACK()&#123; SCL = 0;//拉低时钟总线，允许从机控制SDA SCL = 1;//拉高，读SDA delay5us(); if(SDA)//NOACK &#123; SCL = 0; return(1);//返回1 &#125; else//ACK &#123; SCL = 0; return(0);//返回0 &#125;&#125;/*====================================函数 ：SendACK(bit i)参数 ：1主机发送非应答，0发送应答返回值 ：无描述 ：主机发送应答信号====================================*/void SendACK(bit i)&#123; SCL = 0;//拉低时钟总线，允许主机控制SDA if(i) //发非应答 SDA = 1; else //发应答 SDA = 0; SCL = 1; //拉高总线，让从机读SDA delay5us();//保持5us SCL = 0; //拉低时钟总线，允许SDA释放 SDA = 1;//释放数据总线&#125;/*====================================函数 ：I2cSendByte(uchar DAT)参数 ：DAT需要发送的数据返回值 ：无描述 ：I2C发送一个字节数据====================================*/void I2cSendByte(uchar DAT)&#123; uchar i; for(i=0; i&lt;8; i++) //分别写8次，每次写1位 &#123; SCL = 0;//拉低时钟总线，允许SDA变化 if(DAT &amp; 0x80)//先写数据最高位 SDA = 1; //写1 else SDA = 0; //写0 SCL = 1; //拉高时钟，让从机读SDA DAT &lt;&lt;= 1; //为发送下一位左移1位 &#125; SCL = 0; //拉低时钟总线，允许SDA释放 SDA = 1;//释放数据总线&#125;/*====================================函数 ：Pcf8591DA(uchar Ctrl, DAT)参数 ：Ctrl 8591控制字节，DAT 要写入的数据返回值 ：无描述 ：PCF8591数字量转模拟量输出====================================*///void Pcf8591DA(uchar Ctrl, DAT)//&#123;// I2cStart();//I2C起始信号// I2cSendByte(PCF8591ADDR + I2cWrite);//发送器件地址加读写方向位// if(ReadACK()) //读从机应答// AckFlag = 1; //NOACK// else// AckFlag = 0; //ACK// I2cSendByte(Ctrl);//发送控制字节// if(ReadACK())//读从机应答// AckFlag = 1; //NOACK// else// AckFlag = 0; //ACK// I2cSendByte(DAT);//发送一字节数据// if(ReadACK())//读从机应答// AckFlag = 1; //NOACK// else// AckFlag = 0; //ACK// I2cStop(); //I2C停止信号//&#125;/*====================================函数 ：I2cReadByte()参数 ：无返回值 ：返回读出的一字节数据描述 ：I2C总线读一字节数据====================================*/uchar I2cReadByte()&#123; uchar i, DAT; for(i=0; i&lt;8; i++)//分别读8次，每次读一位 &#123; DAT &lt;&lt;= 1; //数据左移1位，准备接收一位 SCL = 0; //拉低时钟总线，允许从机控制SDA变化 SCL = 1; //拉高时钟总线，读取SDA上的数据 if(SDA) DAT |= 0X01;//为1则写1，否则不行执行写1，通过左移补0 &#125; return(DAT); //返回读出的数据&#125;/*====================================函数 ：PCF8591Read(uchar Ctrl)参数 ：Ctrl 8591控制字节返回值 ：AD转出的数字量描述 ：读指定通道的输入的模拟量专为数字量====================================*/uchar PCF8591Read(uchar Ctrl)&#123; uchar DAT; I2cStart();//I2C起始信号 I2cSendByte(PCF8591ADDR + I2cWrite);//发送器件地址加读写方向位 if(ReadACK())//读从机应答 AckFlag = 1; //NOACK else AckFlag = 0; //ACK I2cSendByte(Ctrl);//发送控制字节 ReadACK();//读从机应答 I2cStart();//再次产生I2C起始信号 I2cSendByte(PCF8591ADDR + I2cRead);//发送器件地址加读写方向位 读 if(ReadACK())//读从机应答 AckFlag = 1; //NOACK else AckFlag = 0; //ACK DAT = I2cReadByte();//读一字节 SendACK(1);//主机发送非应答 I2cStop(); //I2C停止信号 return(DAT);//返回读出数据 &#125;void main()//main函数自身会循环&#123; while(1) &#123; num = (PCF8591Read(CH2) * 19.53 + 0.5);//读AD通道2，电位器值 // 5000mv/256约等于等于19.53 ，加0.5是小数四舍五入接近实际转换精度 display(num); //数码管显示函数 delay(5); &#125;&#125; (二) 使用I2C通信，PCF8591模数/数模转换，读取通道0光敏模拟量，输出模拟量控制LED10亮度变化 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296/********************************************************************************** 【作 者】： 清翔电子:向量* 【版 本】： V1.0* 【网 站】： http://www.qxmcu.com/ * 【淘宝店铺】： http://qxmcu.taobao.com/* 【实验平台】： 清翔 QX-MCS51 单片机开发板* 【外部晶振】： 11.0592mhz * 【主控芯片】： STC89C52* 【编译环境】： Keil μVisio4 * 【程序功能】： I2C通信，PCF8591模数/数模转换，读取通道0光敏模拟量，输出模拟量控制LED10 * 【使用说明】： 随着环境光线的变强LED10亮度增加，环境光变弱LED10亮度变暗 需要用跳线帽把DEN和DOUT短接（默认已短接）**********************************************************************************/#include &lt;reg52.h&gt;#include &lt;intrins.h&gt;#define uint unsigned int#define uchar unsigned char#define PCF8591ADDR 0X90 //PCF8591硬件地址#define I2cRead 1 //I2C读方向位#define I2cWrite 0 //I2C写方向位#define CH0 0 //AD通道0#define CH1 1 //AD通道1#define CH2 2 //AD通道2#define CH3 3 //AD通道3#define DAout 0x40 //DA输出命令sbit DU = P2^6;//数码管段选sbit WE = P2^7;//数码管段选sbit SCL = P2^1; //I2C时钟总线sbit SDA = P2^0; //I2C数据总线uchar num;//数码管显示的值bit AckFlag;//应答标志位//共阴数码管段选表0-9uchar code SMGduan[]= &#123;0x3F, 0x06, 0x5B, 0x4F, 0x66, 0x6D, 0x7D, 0x07, 0x7F, 0x6F,&#125;;//数码管位选码uchar code SMGwei[] = &#123;0xfe, 0xfd, 0xfb&#125;;/*====================================函数 ： delay(uint z)参数 ：z 延时毫秒设定，取值范围0-65535返回值 ：无描述 ：12T/Fosc11.0592M毫秒级延时====================================*/void delay(uint z)&#123; uint x,y; for(x = z; x &gt; 0; x--) for(y = 114; y &gt; 0 ; y--); &#125; /*====================================函数 ：display(uchar i)参数 ：i 显示数值，取值范围0-255返回值 ：无描述 ：三位共阴数码管动态显示====================================*/void display(uchar i)&#123; static uchar wei; P0 = 0XFF;//清除断码 WE = 1;//打开位选锁存器 P0 = SMGwei[wei]; WE = 0;//锁存位选数据 switch(wei) &#123; case 0: DU = 1; P0 = SMGduan[i / 100]; DU = 0; break; case 1: DU = 1; P0 = SMGduan[i % 100 / 10]; DU = 0; break; case 2: DU = 1; P0 = SMGduan[i % 10]; DU = 0; break; &#125; wei++; if(wei == 3) wei = 0;&#125;//定时器0初始化void timer0Init()&#123; EA = 1; //打开总中断 ET0 = 1;//打开定时器0中断 TR0 = 1; //启动定时器0 TMOD |= 0X01; //定时器工作模式1，16位定时模式 TH0 = 0xED; TL0 = 0xFF; //定时5ms&#125;/****************************************************IIC通信代码****************************************************//*====================================函数 ：delay5us()参数 ：无返回值 ：无描述 ：5us延时函数====================================*/void delay5us()&#123; _nop_();&#125;/*====================================函数 ：I2cStart()参数 ：无返回值 ：无描述 ：I2C总线起始信号====================================*/void I2cStart()&#123;//时钟总线为高电平期间数据总线又高变低产生起始型号 SCL = 1; SDA = 1; delay5us();//状态保持5us SDA = 0; delay5us();//状态保持5us &#125;/*====================================函数 ：I2cStop()参数 ：无返回值 ：无描述 ：I2C总线停止信号====================================*/void I2cStop()&#123;//时钟总线为高电平期间，数据总线从高变低产生终止信号 SCL = 0; SDA = 0; SCL = 1; delay5us();//状态保持5us SDA = 1; delay5us();//状态保持5us &#125;/*====================================函数 ：ReadACK()参数 ：无返回值 ：1非应答，0应答描述 ：I2C总线读从机应答信号====================================*/bit ReadACK()&#123; SCL = 0;//拉低时钟总线，允许从机控制SDA SCL = 1;//拉高，读SDA delay5us(); if(SDA)//NOACK &#123; SCL = 0; return(1);//返回1 &#125; else//ACK &#123; SCL = 0; return(0);//返回0 &#125;&#125;/*====================================函数 ：SendACK(bit i)参数 ：1主机发送非应答，0发送应答返回值 ：无描述 ：主机发送应答信号====================================*/void SendACK(bit i)&#123; SCL = 0;//拉低时钟总线，允许主机控制SDA if(i) //发非应答 SDA = 1; else //发应答 SDA = 0; SCL = 1; //拉高总线，让从机读SDA delay5us();//保持5us SCL = 0; //拉低时钟总线，允许SDA释放 SDA = 1;//释放数据总线&#125;/*====================================函数 ：I2cSendByte(uchar DAT)参数 ：DAT需要发送的数据返回值 ：无描述 ：I2C发送一个字节数据====================================*/void I2cSendByte(uchar DAT)&#123; uchar i; for(i=0; i&lt;8; i++) //分别写8次，每次写1位 &#123; SCL = 0;//拉低时钟总线，允许SDA变化 if(DAT &amp; 0x80)//先写数据最高位 SDA = 1; //写1 else SDA = 0; //写0 SCL = 1; //拉高时钟，让从机读SDA DAT &lt;&lt;= 1; //为发送下一位左移1位 &#125; SCL = 0; //拉低时钟总线，允许SDA释放 SDA = 1;//释放数据总线&#125;/*====================================函数 ：Pcf8591DA(uchar Ctrl, DAT)参数 ：Ctrl 8591控制字节，DAT 要写入的数据返回值 ：无描述 ：PCF8591数字量转模拟量输出====================================*/void Pcf8591DA(uchar Ctrl, DAT)&#123; I2cStart();//I2C起始信号 I2cSendByte(PCF8591ADDR + I2cWrite);//发送器件地址加读写方向位 if(ReadACK()) //读从机应答 AckFlag = 1; //NOACK else AckFlag = 0; //ACK I2cSendByte(Ctrl);//发送控制字节 if(ReadACK())//读从机应答 AckFlag = 1; //NOACK else AckFlag = 0; //ACK I2cSendByte(DAT);//发送一字节数据 if(ReadACK())//读从机应答 AckFlag = 1; //NOACK else AckFlag = 0; //ACK I2cStop(); //I2C停止信号&#125;/*====================================函数 ：I2cReadByte()参数 ：无返回值 ：返回读出的一字节数据描述 ：I2C总线读一字节数据====================================*/uchar I2cReadByte()&#123; uchar i, DAT; for(i=0; i&lt;8; i++)//分别读8次，每次读一位 &#123; DAT &lt;&lt;= 1; //数据左移1位，准备接收一位 SCL = 0; //拉低时钟总线，允许从机控制SDA变化 SCL = 1; //拉高时钟总线，读取SDA上的数据 if(SDA) DAT |= 0X01;//为1则写1，否则不行执行写1，通过左移补0 &#125; return(DAT); //返回读出的数据&#125;/*====================================函数 ：PCF8591Read(uchar Ctrl)参数 ：Ctrl 8591控制字节返回值 ：AD转出的数字量描述 ：读指定通道的输入的模拟量专为数字量====================================*/uchar PCF8591Read(uchar Ctrl)&#123; uchar DAT; I2cStart();//I2C起始信号 I2cSendByte(PCF8591ADDR + I2cWrite);//发送器件地址加读写方向位 if(ReadACK())//读从机应答 AckFlag = 1; //NOACK else AckFlag = 0; //ACK I2cSendByte(Ctrl);//发送控制字节 ReadACK();//读从机应答 I2cStart();//再次产生I2C起始信号 I2cSendByte(PCF8591ADDR + I2cRead);//发送器件地址加读写方向位 读 if(ReadACK())//读从机应答 AckFlag = 1; //NOACK else AckFlag = 0; //ACK DAT = I2cReadByte();//读一字节 SendACK(1);//主机发送非应答 I2cStop(); //I2C停止信号 return(DAT);//返回读出数据 &#125;void main()//main函数自身会循环&#123; timer0Init();//定时器0初始化 while(1) &#123; EA = 0;//屏蔽中断 num = PCF8591Read(CH0);//读AD通道0，光敏值 Pcf8591DA(DAout, ~num);//把光敏转出的数字量取反，输出模拟量控制LED10 EA = 1;//开中断 delay(5); &#125;&#125; //定时器0中断函数void timer0() interrupt 1&#123; TH0 = 0xED; TL0 = 0xFF; //定时5ms display(num); //数码管显示函数 &#125;"},{"title":"","date":"2024-03-31T14:49:40.667Z","updated":"2024-03-31T14:49:40.667Z","comments":true,"path":"notes/51/mcu51_6/index.html","permalink":"https://blog.ajream.top/notes/51/mcu51_6/","excerpt":"","text":"DS18B20介绍 DS18B20数字温度传感器是DALLAS公司生产的单总线器件，用它来组成一个测温系统具有线路简单，体积小，在一根通信线上可以挂很多这样的数字温度传感器，十分方便。 特点 通信采用1-Wire接口 n每个DS18B20都有唯一的64位序列码储存在板载ROM中 无需外部元件 可从数据线供电，电源范围为3.0V ~ 5.5V。 可测量的温度范围在-55℃ ~ +125℃ 在－10～＋85℃范围内精确度为±0.5℃ 温度计分辨率可设置为9~12位，12位时分辨率对应为0.0625℃ 单总线 DS18B20采用1-wire Bus传输数据，所有数据都在一条线上传输，因此单总线协议对时序要求非常严格以确保数据的完整性。 单总线信号类型: 复位脉冲、存在脉冲、写0、写1、读0、读1。 所有这些信号除存在脉冲由DS18B20发出的以外，其他信号都由总线控制器发出。并且，数据传输总是从最低有效位开始。 初始化时序 初始化时序里面包含了复位DS18B20和接收DS18B20返回的存在信号。 主机和DS18B20做任何通讯前都需要对其初始化。 初始化期间： 总线控制器拉低总线并保持480us以上，挂在总线上的器件将被复位 释放总线，等到15-60us，此时18B20将返回一个60~240us之间的低电平存在信号 写时序 写时序有2种写法：写0时序和写1时序。总线控制器通过写 1 时序写逻辑 1 到 DS18B20，写 0 时序写逻辑 0 到 DS18B20。 所有写时序必须持续 &gt;=60us，包括：两个写周期之间至少 1us 的恢复时间。当总线控制器把数据线从逻辑高电平拉到低电平的时候，写时序开始。 初始化写时序： 总线控制器要生产一个写时序，必须把数据线拉到低电平然后释放，在写时序开始后的 15us 释放总线。 当总线被释放的时候，5K 的上拉电阻将拉高总线。因此，如果总控制器要生成一个写 0 时序，必须把数据线拉到低电平并持续保持（至少 60us）。 进行写时序： 总线控制器初始化写时序后，DS18B20 在一个 15us 到 60us 的窗口内对 I/O 线采 样。如果线上是高电平，就是写1。如果线上是低电平，就是写0 读时序 先把总线拉低至少1us 在15us内选取1us进行读数据 在拉低的15us（包括上面2点所说的1us）内传输的数据是有效的 然后总线被释放 总时间必须&gt;=60us 读1的详细时序： TINIT,TRC 和 TSAMPLE 之和必须小于 15us 推荐的读1时序： 系统时间可以用下面办法达到最大： TINIT 和 TRC 保持时间尽可能小；把控制器采样时间放 到 15us 周期的最后。 数据获取 通过单线总线端口访问DS18B20的协议如下： 初始化 ROM操作指令 DS18B20功能指令、温度转换命令、读取暂存器命令 部分常用ROM指令如下： 例子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172#include &lt;reg52.h&gt;#include &lt;intrins.h&gt;#define MAIN_Fosc 11059200UL //宏定义主时钟HZ/*==================================== 自定义类型名====================================*/typedef unsigned char INT8U;typedef unsigned char uchar;typedef unsigned int INT16U;typedef unsigned int uint;/*==================================== 硬件接口位声明====================================*/sbit DS = P2^2; //DS18B20单总线sbit DU = P2^6; //数码管段选sbit WE = P2^7; //数码管位选/*====================================共阴极数码管段选码====================================*/uchar code table[]=&#123; //0 1 2 3 4 5 6 7 80x3F, 0x06, 0x5B, 0x4F, 0x66, 0x6D, 0x7D, 0x07, 0x7F,//9 A B C D E F - . 关显示0x6F, 0x77, 0x7C, 0x39, 0x5E, 0x79, 0x71, 0x40, 0x80, 0x00 &#125;;/*====================================数码管位选码====================================*/ //第1位 2位 3位 4位 5位 6位 7位 8位uchar code T_COM[] = &#123;0xfe, 0xfd, 0xfb, 0xf7, 0xef, 0xdf, 0xbf, 0x7f&#125;;//数码管位码/*====================================函数：void Delay_Ms(INT16U ms)参数：ms，毫秒延时形参描述：12T 51单片机自适应主时钟毫秒级延时函数====================================*/void Delay_Ms(INT16U ms)&#123; INT16U i; do&#123; i = MAIN_Fosc / 96000; while(--i); //96T per loop &#125;while(--ms);&#125;/*us延时函数，执行一次US--所需6.5us进入一次函数需要11.95us*/void Delay_us(uchar us)&#123; while(us--); &#125;/*====================================函数：void Display(INT16U Value)参数：Value,显示值 取值0-65535描述：共阴极数码管显示函数可显示一个字节的数====================================*/void Display(INT16U Value) //注意由于需要显示的数大于一个字节所有形参需为int型&#123; //------------------------------ DU = 0; //关闭段选 P0 = table[Value/100]; //数码管显示百位 DU = 1; //打开段选 DU = 0; //关闭段选 WE = 0; //关闭位选 P0 = T_COM[0]; //第一位数码管 WE = 1; //打开位选 WE = 0; //关闭位选 Delay_Ms(3);//------------------------------- DU = 0; P0 = table[Value%100/10]|0x80; //显示十位 DU = 1; DU = 0; WE = 0; P0 = T_COM[1]; //第二位数码管 WE = 1; WE = 0; Delay_Ms(3);//------------------------------- DU = 0; P0 = table[Value%10]; //显示个位 DU = 1; DU = 0; WE = 0; P0 = T_COM[2]; //第三位数码管 WE = 1; WE = 0; Delay_Ms(3);&#125;/*单总线初始化时序*/bit ds_init()&#123; bit i; DS = 1; _nop_(); DS = 0; Delay_us(75); //拉低总线499.45us 挂接在总线上的18B20将会全部被复位 DS = 1; //释放总线 Delay_us(4); //延时37.95us 等待18B20发回存在信号 i = DS; Delay_us(20); //141.95us DS = 1; _nop_(); return (i);&#125;/*写一个字节*/void write_byte(uchar dat)&#123; uchar i; for(i=0;i&lt;8;i++) &#123; DS = 0; _nop_();//产生些时序 DS = dat &amp; 0x01; Delay_us(10);//76.95us DS = 1; //释放总线准备下一次数据写入 _nop_(); dat &gt;&gt;= 1; &#125;&#125;uchar read_byte()&#123; uchar i, j, dat; for(i=0;i&lt;8;i++) &#123; DS = 0; _nop_();//产生读时序 DS = 1; _nop_();//释放总线 j = DS; Delay_us(10);//76.95us DS = 1; _nop_(); dat = (j&lt;&lt;7)|(dat&gt;&gt;1); &#125; return (dat);&#125;void main()&#123; uint i; uchar L, M;/* ds_init();//初始化DS18B20 write_byte(0xcc);//发送跳跃ROM指令 write_byte(0x4e);//写暂存器指令 write_byte(0x7f); write_byte(0xf7); write_byte(0x1f);//配置工作在9位模式下 ds_init();//初始化DS18B20 write_byte(0xcc);//发送跳跃ROM指令 write_byte(0x48);*/ while(1) &#123; ds_init();//初始化DS18B20 write_byte(0xcc);//发送跳跃ROM指令 write_byte(0x44);//发送温度转换指令 ds_init();//初始化DS18B20 write_byte(0xcc);//发送跳跃ROM指令 write_byte(0xbe);//读取DS18B20暂存器值 L = read_byte(); M = read_byte(); i = M; i &lt;&lt;= 8; i |= L; i = i * 0.0625 * 10 + 0.5; Display(i); &#125;&#125;"},{"title":"","date":"2024-03-31T14:49:40.667Z","updated":"2024-03-31T14:49:40.667Z","comments":true,"path":"notes/51/mcu51_7/index.html","permalink":"https://blog.ajream.top/notes/51/mcu51_7/","excerpt":"","text":"红外通信 红外遥控电路组成 一般而言，红外遥控系统由发射装置和接收装置两大部分组成 发射装置(例如遥控器)主要包括： 键盘电路 红外编码芯片 电源 红外发射电路 红外接收设备： 可由红外接收电路 红外解码芯片 电源 应用电路组成 信号调制和解调 为了使信号更好的传输，一般会把信号进行调制使频率变高，接收到后再通过解调等一系列步骤还原信号 NEC协议 NEC 标准下的编码表示 引导码高电平约 9000us 左右，低电平约4500us 左右 用户码16 位，数据码16 位，共32位 数据0 是用“高电平约 560us ＋ 低电平约 560us ”表示 数据1 是用“高电平约 560us ＋ 低电平约 1680us”表示 例子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125/*NEC协议红外通信单片机解码后通过串口以9600的比特率发送出去*/#include &lt;reg52.h&gt;/*==================================== 自定义类型名====================================*/typedef unsigned char INT8U;typedef unsigned char uchar;typedef unsigned int INT16U;typedef unsigned int uint;/*==================================== 硬件接口位声明====================================*/sbit IR = P3^2; //定义红外脉冲数据接口 外部中断O输入口uchar IRtime; //检测红外高电平持续时间（脉宽）uchar IRcord[4]; //此数组用于储存分离出来的4个字节的数据（用户码2个字节+键值码2个字节）uchar IRdata[33]; //此数组用于储存红外的33位数据（第一位为引导码用户码16+键值码16）bit IRpro_ok, IRok; //第一个用于红外接收4个字节完毕。IRok用为检测脉宽完毕void init() //初始化定时器0 和外部中断0&#123; TMOD = 0x22; //定时器0和定时器1工作方式2，8位自动重装 TH0 = 0x00; //高8位装入0那么定时器溢出一次的时间是256个机器周期 TL0 = 0x00; EA = 1; //总中断 ET0 = 1; //定时器0中断 TR0 = 1; //启动定时器0 IT0 = 1; //设置外部中断0为跳沿触发方式，来一个下降沿触发一次 EX0 = 1; //启动外部中断0 TH1 = 0xfd; //此溢出率为波特率9600 TL1 = 0xfd; TR1 = 1; //启动定时器1 SM1 = 1; //设置串口工作方式1，10位异步收发器&#125;void time0() interrupt 1 //定义定时器0&#123; IRtime++; //检测脉宽，1次为278us&#125;void int0() interrupt 0 //定义外部中断0&#123; static uchar i; // 声明静态变量（在跳出函数后在回来执行的时候不会丢失数值）i用于把33次高电平的持续时间存入IRdata static bit startflag; //开始储存脉宽标志位 if(startflag) //开始接收脉宽检测 &#123; if( (IRtime &lt; 53) &amp;&amp; (IRtime &gt;= 32) ) /*判断是否是引导码，底电平9000us+高4500us 这个自己可以算我以11.0592来算了NEC协议的引导码低8000-10000+高4000-5000 如果已经接收了引导码那么i不会被置0就会开始依次存入脉宽*/ i = 0; //如果是引导码那么执行i=0把他存到IRdata的第一个位 IRdata[i] = IRtime; //以T0的溢出次数来计算脉宽，把这个时间存到数组里面到后面判断 IRtime = 0; //计数清零，下一个下降沿的时候在存入脉宽 i++; //计数脉宽存入的次数 if(i == 33) //如果存入34次 数组的下标是从0开始i等于33表示执行了34次 &#123; IRok = 1; //那么表示脉宽检测完毕 i = 0; //把脉宽计数清零准备下次存入 &#125; &#125; else &#123; IRtime = 0; //引导码开始进入把脉宽计数清零开始计数 startflag = 1; //开始处理标志位置1 &#125;&#125;void IRcordpro() //提取它的33次脉宽进行数据解码&#123; uchar i, j, k, cord, value; /*i用于处理4个字节，j用于处理一个字节中每一位，k用于33次脉宽中的哪一位 cord用于取出脉宽的时间判断是否符合1的脉宽时间*/ k = 1; //从第一位脉宽开始取，丢弃引导码脉宽 for(i = 0; i &lt; 4; i++) &#123; for(j = 0; j &lt; 8; j++) &#123; cord = IRdata[k]; //把脉宽存入cord if(cord &gt; 5) //如果脉宽大于我11.0592的t0溢出率为约278us*5=1390那么判断为1 value = value | 0x80; /*接收的时候是先接收最低位， 把最低位先放到value的最高位在和0x08按位或一下 这样不会改变valua的其他位的数值只会让他最高位为1*/ if(j &lt; 7) &#123; value = value &gt;&gt; 1; //value位左移依次接收8位数据。 &#125; k++; //每执行一次脉宽位加1 &#125; IRcord[i] = value; //每处理完一个字节把它放入IRcord数组中。 value = 0; //清零value方便下次在存入数据 &#125; IRpro_ok = 1; //接收完4个字节后IRpro ok置1表示红外解码完成 &#125;void main()&#123; uchar i; init(); //执行初始化定时器0和外部中断0 while(1) //大循环 &#123; if(IRok) //判断脉宽是否检测完毕 &#123; IRcordpro();//根据脉宽解码出4个字节的数据 IRok = 0; //重新等待脉宽检测 if(IRpro_ok) //判断是否解码完毕 &#123; for(i = 0; i &lt; 4; i++) &#123; SBUF = IRcord[i]; while(!TI); TI = 0; &#125; IRpro_ok = 0; &#125; &#125; &#125;&#125;"},{"title":"","date":"2024-03-31T14:49:40.667Z","updated":"2024-03-31T14:49:40.667Z","comments":true,"path":"notes/51/mcu51_8/index.html","permalink":"https://blog.ajream.top/notes/51/mcu51_8/","excerpt":"","text":"DS1302 芯片功能 DS1302是美国DALLAS推出的一款高性能、低功耗的日历时钟芯片。 DS1302是一种串行接口的实时时钟，芯片内部具有可编程的日历时钟和31个字节的静态RAM，日历时钟可以自动进行闰年补偿，计时准确，接口简单，使用方便 工作电压范围2.5~5.5V，芯片自身还具有对备用电池进行涓流充电功能，可有效延长备用电池的使用寿命。 DS1302用于数据记录，能实现数据与该数据出现的时间同时记录，广泛应用于测量系统中。 引脚 VCC1：主电源 VCC2：备用电源 当VCC2大于VCC1+0.2V时，由VCC2向DS1302供电否则由VCC1向DS1302供电 SCLK：串行时钟输入端，控制数据输入与输出 I/O ：双向输入线 CE：使能端，CE为高时允许读写DS1302数据，为低时禁止读写 应用电路 开发板实际电路如下： 说明： DS1302和单片机的IO连接只需3条线： CE数据传输使能端、SCLK串行时钟输入端、I/O串行数据端 (开发板上把这3个引脚分别接到了j5排针上同时通过4.7K电阻上拉到VCC，我们实际使用DS1302芯片时需要用杜邦线把j5和相应的单片机IO链接上) 此外 X1、X2晶振引脚外接32.768KHZ圆形晶振，给时钟芯片提供工作频率 VCC2接的开发上的系统电源，VCC1接的预留电池座 DS1302第4脚接的系统GND DS1302的寄存器 如图所示，时钟日历包含在 7 个读/写寄存器内，读/写寄存器中的数据是 BCD 码。（4位BCD码最大表示9，不是15， 例如用BCD码表示10为 0001 0000） 秒寄存器（81h、80h）的BIT7定义为时钟暂停标志（CH）。当该位置为1时，时钟振荡器停止，DS1302处于低功耗状态；当该位置为0时，时钟开始运行。 小时寄存器（85h、84h）的BIT7用于定义DS1302是运行于12小时模式还是24小时模式，当为1时，选择12小时模式，此时BIT5为AM/PM位，在24小时模式时此位为小时数据位。 写保护寄存器（8Fh、8Eh）的BIT7是写保护位（WP），其它7位均为0。在任何对时钟或RAM读写操作之前，WP位必须为0。当WP位为1时，不能对任何时钟日历寄存器或RAM进行写操作。 使用对应指令即可读取或写入数据到相应寄存器，比如读取秒，用指令81h，读取分，用 83h, … 突发模式： 突发模式可以指定任 何的时钟/日历或者 RAM 寄存器为突发模式，和以前一样，第 6 位指定时钟或 RAM 而 0 位指定读或写。 突发模式的实质是指一次传送多个字节的时钟信号和 RAM 数据。如下图所示： 也就是说，如果发送BFh指令，DS1302会一次性把年月周日、时分秒发送过来,不需要像前面一个个指令来获取时间 DS1302时序 DS1302读写数据时序，数据的传输是从最低位开始（BIT0）。 数据是以位（BIT）为单位依次写入或读出，读写数据操作中SCLK上升沿时执行写入数据，下降沿时执行读出数据。 **读数据：**CE端从低到高的一个上升沿开始允许开始读数据，拉低CE端则禁止读写数据；开始的8个SCLK周期，写命令字节，数据的后8个SCLK 周期读出数据。 **写数据：**CE端从低到高的一个上升沿开始允许开始写数据，拉低CE端则禁止读写数据；开始的8个SCLK周期，写命令字节，数据的后8个SCLK 周期写入数据。 例子 数码管显示DS1302时钟 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208#include &lt;reg52.h&gt;#include &lt;intrins.h&gt;#define MAIN_Fosc 11059200UL //宏定义主时钟HZ/*==================================== 自定义类型名====================================*/typedef unsigned char INT8U;typedef unsigned char uchar;typedef unsigned int INT16U;typedef unsigned int uint;/*==================================== 硬件接口位声明====================================*/sbit TSCLK = P1^0;//时钟线 接到P10上用杜邦线sbit TIO = P1^1;//数据线，接到P11上sbit TRST = P1^2;//使能端，接到P12上sbit DU = P2^6; //数码管段选sbit WE = P2^7; //数码管位选/*====================================共阴极数码管段选码====================================*/uchar code table[]=&#123; //0 1 2 3 4 5 6 7 80x3F, 0x06, 0x5B, 0x4F, 0x66, 0x6D, 0x7D, 0x07, 0x7F,//9 A B C D E F - . 关显示0x6F, 0x77, 0x7C, 0x39, 0x5E, 0x79, 0x71, 0x40, 0x80, 0x00 &#125;;/*====================================数码管位选码====================================*/ //第1位 2位 3位 4位 5位 6位 7位 8位uchar code T_COM[] = &#123;0xfe, 0xfd, 0xfb, 0xf7, 0xef, 0xdf, 0xbf, 0x7f&#125;;//数码管位码/*====================================函数：void Delay_Ms(INT16U ms)参数：ms，毫秒延时形参描述：12T 51单片机自适应主时钟毫秒级延时函数====================================*/void Delay_Ms(INT16U ms)&#123; INT16U i; do&#123; i = MAIN_Fosc / 96000; while(--i); //96T per loop &#125;while(--ms);&#125;void Display(uchar Hour, Min, Sec)&#123; //------------------------------ DU = 0; P0 = table[Hour/10]; DU = 1; DU = 0; WE = 0; P0 = T_COM[0]; WE = 1; WE = 0; Delay_Ms(3);//------------------------------- DU = 0; P0 = table[Hour%10]|0x80; DU = 1; DU = 0; WE = 0; P0 = T_COM[1]; WE = 1; WE = 0; Delay_Ms(3);//------------------------------ DU = 0; P0 = table[Min/10]; DU = 1; DU = 0; WE = 0; P0 = T_COM[2]; WE = 1; WE = 0; Delay_Ms(3);//------------------------------- DU = 0; P0 = table[Min%10]|0x80; DU = 1; DU = 0; WE = 0; P0 = T_COM[3]; WE = 1; WE = 0; Delay_Ms(3);//------------------------------ DU = 0; P0 = table[Sec/10]; DU = 1; DU = 0; WE = 0; P0 = T_COM[4]; WE = 1; WE = 0; Delay_Ms(3);//------------------------------- DU = 0; P0 = table[Sec%10]; DU = 1; DU = 0; WE = 0; P0 = T_COM[5]; WE = 1; WE = 0; Delay_Ms(3);&#125;//写DS1302数据void Write_DS1302_DAT(uchar cmd, uchar dat)&#123; uchar i; TRST = 0; //拉低使能端 TSCLK = 0;//拉低数据总线 TRST = 1; //拉高使能端，产生上升沿开始写数据 for(i = 0; i &lt; 8; i++)//每次写1位，写8次 &#123; TSCLK = 0; //拉低时钟总线 TIO = cmd &amp; 0x01; //写1位数据，从最低位开始写 TSCLK = 1; //拉高时钟总线，产生上升沿数据被DS1302读走 cmd &gt;&gt;=1; //右移一位 &#125; for(i = 0; i &lt; 8; i++)//每次写1位，写8次 &#123; TSCLK = 0; //拉低时钟总线 TIO = dat &amp; 0x01; //写1位数据，从最低位开始写 TSCLK = 1; //拉高时钟总线，产生上升沿数据被DS1302读走 dat &gt;&gt;= 1; //右移一位 &#125;&#125;//读DS1302数据uchar Read_DS1302_DAT(uchar cmd)&#123; uchar i, dat; TRST = 0; //拉低使能端 TSCLK = 0; //拉低数据总线 TRST = 1; //拉高使能端，产生上升沿开始写数据 for(i = 0; i &lt; 8; i++)//每次写1位，写8次 &#123; TSCLK = 0; //拉低时钟总线 TIO = cmd &amp; 0x01;//写1位数据，从最低位开始写 TSCLK = 1; //拉高时钟总线，产生上升沿数据被DS1302读走 cmd &gt;&gt;=1; //右移一位 &#125; for(i = 0; i &lt; 8; i++)//每次读1位，读8次 &#123; TSCLK = 0; //拉低时钟总线,产生下降沿，DS1302把数据放到TIO上 dat &gt;&gt;= 1; //右移一位 if(TIO) dat |= 0x80;//读取数据，从最低位开始 TSCLK = 1; //拉高时钟总线，以备下一次产生下降沿 &#125; return dat; //返回读出数据&#125;//数据转BCD码uchar Dat_Chg_BCD(uchar dat)&#123; uchar dat1, dat2; dat1 = dat / 10; dat2 = dat % 10; dat2 = dat2 + dat1 * 16; return dat2;&#125;//BCD码转换为数据uchar BCD_Chg_Dat(uchar dat)&#123; uchar dat1, dat2; dat1 = dat / 16; dat2 = dat % 16; dat2 = dat2 + dat1 * 10; return dat2;&#125;void main()&#123; uchar i; uchar Sec, Min, Hour; Write_DS1302_DAT(0x8e, 0);//清除写保护 Write_DS1302_DAT(0x80, Dat_Chg_BCD(30));//30秒（并且进行BCD码转换） Write_DS1302_DAT(0x82, Dat_Chg_BCD(15));//15分 Write_DS1302_DAT(0x84, Dat_Chg_BCD(19));//19时 Write_DS1302_DAT(0x8e, 0x80);//开写保护 while(1) &#123; Write_DS1302_DAT(0x8e, 0); //清除写保护 Sec = BCD_Chg_Dat(Read_DS1302_DAT(0x81));//读秒寄存器（并且进行BCD码转换） Min = BCD_Chg_Dat(Read_DS1302_DAT(0x83));//读分寄存器 Hour = BCD_Chg_Dat(Read_DS1302_DAT(0x85));//读时寄存器 Write_DS1302_DAT(0x8e, 0x80);//开写保护 for(i = 0; i &lt; 50; i++) //循环显示时钟 Display(Hour, Min, Sec); &#125;&#125;"},{"title":"","date":"2024-03-31T14:49:40.667Z","updated":"2024-03-31T14:49:40.667Z","comments":true,"path":"notes/51/mcu51_9/index.html","permalink":"https://blog.ajream.top/notes/51/mcu51_9/","excerpt":"","text":"简单介绍 主要参数 显示容量：16X2个字符 芯片工作电压：4.5~5.5V， 最佳工作电压5.0V（2.0mA） 引脚说明 RS：为0时是指令输入，也就是表示显示在哪个“格子”的（1602有16X2共32个&quot;格子&quot;）; ​ 为1时表示数据输入，即每个”格子“显示的内容 R/W：为1时是读，0是写； E：读写数据时要置1 D0~D7：数据输入输出 基本操作 读写操作 读状态，输入：RS=0, RW=1, E=0; 此时输出数据D0~D7为状态字，每一位都有各自的状态； 其中D0-D6表示当前数据地址指针的数值，D7的状态表示读写操作使能，如果是1表示禁止读写，0表示允许读写； 写指令（即告诉1602要显示的位置）：RS=0, RW=0, E=高脉冲，D0-D7为指令码 读数据：RS=1, RW=1, E=1, 此时D0-D7输出数据 写数据：RS=1, RW=0, D0-D7表示要写入的数据，E=高脉冲 123456789101112131415161718192021222324252627282930313233void Read_Busy() //读状态判断是芯片否处于”忙“状态&#123; uchar busy; P0 = 0xff; RS = 0; RW = 1; do &#123; EN = 1; busy = P0; EN = 0; &#125;while(busy &amp; 0x80);&#125;//写LCD1602命令一个字节void Write_Cmd(uchar cmd)&#123; Read_Busy();//判断忙 RS = 0; RW = 0; P0 = cmd; EN = 1; EN = 0;&#125;//写一个字节数据void Write_Dat(uchar dat)&#123; Read_Busy(); RS = 1; RW = 0; P0 = dat; EN = 1; EN = 0;&#125; RAM地址映射 控制器内部自带了80X8位（即80Bytes）的RAM缓冲区，对应关系如下图： 注意：第10——27和50——67的地址上的字符是无法显示的，只能显示前面16X2个地址上所存放的字符 指令说明 初始化设置： 显示模式设置：指令码0x38（二进制是00111000），表示设置16X2显示，5X7点阵，8位数据接口 开/关光标设置：（配置时要转为16进制） 指令码（二进制形式）00001DCB D=1开显示，D=0关显示 C=1显示光标，C=0不显示光标 B=1光标闪烁，B=0不闪烁 指令码（二进制形式）000001NS N=1当读或写一个字符后地址和光标自动+1，N=0则为自动-1； S=1当写入一个字符整屏显示左移（N=1）或右移（N=0）达到光标不动屏幕移动的效果； S=0当写入一个字符，屏幕显示不移动 数据控制 控制器内部有地址指针，通过发送指令 80H+地址码 （地址码范围是0——27H，40H——67H） 即可访问地址上的数据，进而进行设置 其他指令： 时序图 读操作时序图 写操作时序图 时序参数 例子 控制LCD1602显示字符12345 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;reg52.h&gt;typedef unsigned char uchar;typedef unsigned int uint;sbit RS = P3^5;sbit RW = P3^6;sbit EN = P3^4;//判断液晶忙，如果忙则等待void Read_Busy()&#123; uchar busy; P0 = 0xff; RS = 0; RW = 1; do &#123; EN = 1; busy = P0; EN = 0; &#125;while(busy &amp; 0x80);&#125;//写LCD1602命令一个字节void Write_Cmd(uchar cmd)&#123; Read_Busy();//判断忙 RS = 0; RW = 0; P0 = cmd; EN = 1; EN = 0;&#125;//写一个字节数据void Write_Dat(uchar dat)&#123; Read_Busy(); RS = 1; RW = 0; P0 = dat; EN = 1; EN = 0;&#125;void main()&#123; Write_Cmd(0x38);//设置16*2显示 Write_Cmd(0x0f);//开显示，显示光标，光标闪烁 Write_Cmd(0x01);//清屏 Write_Cmd(0x06);//地址指针移位命令 Write_Cmd(0x80 | 0x06);//显示地址 Write_Dat(1 + &#x27;0&#x27;); //写入的字符要转换位ASCII码 Write_Dat(2 + &#x27;0&#x27;); Write_Dat(3 + &#x27;0&#x27;); Write_Dat(4 + &#x27;0&#x27;); Write_Dat(5 + &#x27;0&#x27;); while(1);&#125;"},{"title":"","date":"2024-03-31T14:49:40.667Z","updated":"2024-03-31T14:49:40.667Z","comments":true,"path":"notes/esp8266/esp8266_0/index.html","permalink":"https://blog.ajream.top/notes/esp8266/esp8266_0/","excerpt":"","text":"一般方法（要求网速较好） 打开ArduinoIDE，在 文件-&gt;首选项 的附加开发板管理器网址 添加下面地址： 1http://arduino.esp8266.com/stable/package_esp8266com_index.json 在工具-&gt;开发板-&gt;开发板管理器，搜索 esp8266，然后选择安装即可 特殊方法（适用于网络不好） 一般方法中如果因为网速过慢，可能在下载过程中会比较慢甚至出错，因此可以自己去GitHub下载对应文件再放到指定文件夹下即可 过程较为麻烦，不想看的直接看最后： 去earlephilhower下载下面这4个zip文件： 1234x86_64-w64-mingw32.xtensa-lx106-elf-1757bed.210717.zipx86_64-w64-mingw32.mkspiffs-7fefeac.210717.zippython3-3.7.2.post1-embed-win32v2a.zipx86_64-w64-mingw32.mklittlefs-943d2f7.210717.zip 去esp8266-Arduino下载esp8266-3.0.2.zip 克隆这个仓库，或者下载zip包 1https://github.com/esp8266/Arduino.git 解压后改名为esp8266，放到目录(没有的文件夹自己新建)： 1C:\\Users\\用户名\\Documents\\Arduino\\hardware\\esp8266com\\ 用第2步下载的zip包中的 libraries 文件夹来代替第3步下载的文件夹中 的libraries 将第一步下载的4个zip包分别重命名： 1234x86_64-w64-mingw32.xtensa-lx106-elf-1757bed.210717.zip --&gt; xtensa-lx106-elf.zipx86_64-w64-mingw32.mkspiffs-7fefeac.210717.zip --&gt; mkspiffs.zippython3-3.7.2.post1-embed-win32v2a.zip --&gt; python3.zipx86_64-w64-mingw32.mklittlefs-943d2f7.210717.zip --&gt; mklittlefs.zip 然后解压到在第三步的 tool文件夹中，下面是解压后： 我已经把这5步全部做完，放到压缩包 esp8266.zip 中，需要的可以去百度网盘下载【链接: https://pan.baidu.com/s/1UqUJXgvzQecXZjqRe_JLaA 提取码: 6xpa】，或者csdn下载【https://download.csdn.net/download/m0_46079750/20887320】，并解压到 下面的目录即可： 1C:\\Users\\用户名\\Documents\\Arduino\\hardware\\esp8266com\\"},{"title":"","date":"2024-03-31T14:49:40.671Z","updated":"2024-03-31T14:49:40.671Z","comments":true,"path":"notes/esp8266/esp8266_1/index.html","permalink":"https://blog.ajream.top/notes/esp8266/esp8266_1/","excerpt":"","text":"接入点模式：开发板作为路由器（网关），可以让其他设备连接 无线终端模式：开发板作为终端，可以连接路由器WiFi 说明：此处使用ArduinoIDE来进行开发。 注意：上传代码前必须把“串口监视器” 关闭，否则可能上传出错，因为端口被占用了 1、配置接入点模式 即开启 “热点” 导入 ESP8266WiFi.h库 配置WiFi名称（ssid）、密码（passwd）—— softAP() 123const char ssid[] = &quot;MyWiFi&quot;;const char passwd[] = &quot;12345678&quot;;WiFi.softAP(ssid, passwd); 获取开发板IP 1WiFi.softAPIP(); 完整code 1234567891011121314151617181920212223#include &lt;ESP8266WiFi.h&gt;char ssid[] = &quot;MyWiFi&quot;;char passwd[] = &quot;1234567890&quot;;void setup()&#123; Serial.begin(9600); Serial.print(&quot;wifi ssid: &quot;); Serial.println(ssid); Serial.print(&quot;wifi password: &quot;); Serial.println(passwd); WiFi.softAP(ssid, passwd); //开启接入点模式 Serial.print(&quot;IP Address: &quot;); Serial.println(WiFi.softAPIP()); //打印开发板的IP&#125;void loop()&#123; &#125; 2、配置无线终端模式 只有1个WiFi 将开发板连接WiFi 123//ssid、passwd均为字符串WiFi.mode(WIFI_STA);WiFi.begin(ssid, passwd); 多次尝试连接，直到连接上： 1234while(WiFi.status() != WL_CONNECTED )&#123; delay(1000); //....&#125; 连上WiFi后，获取wifi的ssid、开发板IP地址： 12WiFi.SSID(); //返回字符串WiFi.localIP(); //返回字符串 完整code： 1234567891011121314151617181920212223242526#include &lt;ESP8266WiFi.h&gt; // 本程序使用ESP8266WiFi库String ssid = &quot;aaa&quot;; String password = &quot;12345678&quot;; void setup() &#123; Serial.begin(9600); WiFi.begin(ssid, password); int i = 0; while (WiFi.status() != WL_CONNECTED) &#123; delay(1000); Serial.print(i++); Serial.print(&#x27; &#x27;); &#125; Serial.println(&quot;&quot;); Serial.print(&quot;Connecting to &quot;); Serial.println(ssid); Serial.println(&quot;IP address: &quot; ); Serial.println(WiFi.localIP()); &#125;void loop() &#123; &#125; 多个WiFi，自动连接最强信号的 先添加几个待选WiFi 1234567891011//导入库#include &lt;ESP8266WiFiMulti.h&gt;// 创建ESP8266WiFiMulti对象ESP8266WiFiMulti wifiMulti; //通过addAP()函数存储WiFi的ssid和密码wifiMulti.addAP(&quot;aaaa&quot;, &quot;11111111&quot;);wifiMulti.addAP(&quot;bbbb&quot;, &quot;22222222&quot;);wifiMulti.addAP(&quot;cccc&quot;, &quot;33333333&quot;); 多次尝试连接：wifiMulti.run() 12345 // 将会连接信号最强的那一个WiFi信号。while (wifiMulti.run() != WL_CONNECTED) &#123; delay(1000); Serial.print(&#x27;...&#x27;); &#125; 完整code： 123456789101112131415161718192021222324252627#include &lt;ESP8266WiFi.h&gt;#include &lt;ESP8266WiFiMulti.h&gt;ESP8266WiFiMulti wifiMulti; //创建对象void setup()&#123; Serial.begin(9600); wifiMulti.addAP(&quot;aaa&quot;, &quot;12345678&quot;); wifiMulti.addAP(&quot;bbb&quot;, &quot;12345678&quot;); wifiMulti.addAP(&quot;ccc&quot;, &quot;12345678&quot;); int i = 0; while (wifiMulti.run() != WL_CONNECTED)&#123; delay(1000); Serial.print(++i); Serial.print(&quot; &quot;); &#125; Serial.println(&quot;&quot;); Serial.print(&quot;IP Address: &quot;); Serial.println(WiFi.localIP()); &#125;void loop()&#123;&#125;"},{"title":"","date":"2024-03-31T14:49:40.671Z","updated":"2024-03-31T14:49:40.671Z","comments":true,"path":"notes/esp8266/esp8266_10/index.html","permalink":"https://blog.ajream.top/notes/esp8266/esp8266_10/","excerpt":"","text":"发布信息 mqtt客户端连接到服务端后即可发布信息，每条信息必须包含一个主题 服务端根据主题决定将信息转发给哪些客户端 发布信息时，会向服务端发送一个PUBLISH报文： topicName：主题名 qos：服务质量等级，分0、1、2共三个等级 packetId：报文标识符，用于区别不同报文 ​ 【注意】：报文标识符的内容与QoS级别有密不可分的关系。只有QoS级别大于0时，报文标识符才是非零数值。如果QoS等于0，报文标识符为0。 retainFlag：保留标志。 ​ 一般情况，客户端订阅某个主题的信息后，服务器不会立刻返回该主题的信息，要等服务器收到新信息时才会返回； ​ 特殊情况，我们要求客户端订阅一个主题后，服务器就要立刻返回新信息 payLoad：有效载荷，可以使用mqtt协议发送文本、图片等内容，这些内容是通过payLoad来发送的 dupFlag：重发标志。当接收方没有及时确认收到报文时，发送方会重复发送MQTT报文。在重复发送MQTT报文时，发送方会将此“重发标志”设置为true。 【注意】重发标志只在QoS级别大于0时使用。 订阅主题 当客户端连接到服务端后，除了可以发布消息，也可以接收消息，而客户端要想接收消息，首先要订阅该消息的主题。 客户端是通过向服务端发送SUBSCRIBE报文来实现订阅主题 【注意】一个SUBSCRIBE报文可以包含有单个或者多个订阅主题名。 qos：客户端在订阅主题时也可以明确QoS。服务端会根据SUBSCRIBE中的QoS来提供相应的服务保证。 MQTT设备可以通过**“报文标识符”**对MQTT报文进行甄别和管理。 订阅确认： 服务端接收到客户端的订阅报文后，会向客户端发送SUBACK报文确认订阅。 该报文包含**”订阅返回码“和”报文标识符“**两个信息 返回码 Return Code Response 0 订阅成功 – QoS 0 1 订阅成功- QoS 1 2 订阅成功- QoS 2 128 订阅失败 【注意】针对不同的主题订阅QoS，服务端的返回码会有所不同。 报文标识符：MQTT设备可以通过该标识符对报文进行管理。 取消订阅 客户端要取消订阅某主题时，可通过向服务端发送UNSUBSCRIBE 报文来实现。 UNSUBSCRIBE报文包含两个重要信息： packetId：“报文标识符” topic1、topic2、…… ：取消订阅的主题的名称 当服务端接收到UNSUBSCRIBE报文后，会向客户端发送取消订阅确认报文 – UNSUBACK报文。该报文含有客户端所发送的“取消订阅报文标识符”。 客户端接收到UNSUBACK报文后就可以确认取消主题订阅 ESP8266发布MQTT消息 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include &lt;ESP8266WiFi.h&gt;#include &lt;PubSubClient.h&gt;#include &lt;Ticker.h&gt;// 设置wifi接入信息(请根据您的WiFi信息进行修改)const char* ssid = &quot;RBook&quot;;const char* password = &quot;1719171945678&quot;;const char* mqttServer = &quot;test.ranye-iot.net&quot;;// 如以上MQTT服务器无法正常连接，请前往以下页面寻找解决方案// http://www.taichi-maker.com/public-mqtt-broker/Ticker ticker;WiFiClient wifiClient;PubSubClient mqttClient(wifiClient);int count; // Ticker计数用变量void setup() &#123; Serial.begin(9600); //设置ESP8266工作模式为无线终端模式 WiFi.mode(WIFI_STA); // 连接WiFi connectWifi(); // 设置MQTT服务器和端口号 mqttClient.setServer(mqttServer, 1883); // 连接MQTT服务器 connectMQTTServer(); // Ticker定时对象 ticker.attach(1, tickerCount); &#125;void loop() &#123; if (mqttClient.connected()) &#123; // 如果开发板成功连接服务器 // 每隔3秒钟发布一次信息 if (count &gt;= 3)&#123; pubMQTTmsg(); count = 0; &#125; // 保持心跳 mqttClient.loop(); &#125; else &#123; // 如果开发板未能成功连接服务器 connectMQTTServer(); // 则尝试连接服务器 &#125;&#125;void tickerCount()&#123; count++;&#125;void connectMQTTServer()&#123; // 根据ESP8266的MAC地址生成客户端ID（避免与其它ESP8266的客户端ID重名） String clientId = &quot;esp8266-&quot; + WiFi.macAddress(); // 连接MQTT服务器 if (mqttClient.connect(clientId.c_str())) &#123; Serial.println(&quot;MQTT Server Connected.&quot;); Serial.println(&quot;Server Address: &quot;); Serial.println(mqttServer); Serial.println(&quot;ClientId:&quot;); Serial.println(clientId); &#125; else &#123; Serial.print(&quot;MQTT Server Connect Failed. Client State:&quot;); Serial.println(mqttClient.state()); delay(3000); &#125; &#125;// 发布信息void pubMQTTmsg()&#123; static int value; // 客户端发布信息用数字 // 建立发布主题。主题名称以Taichi-Maker-为前缀，后面添加设备的MAC地址。 // 这么做是为确保不同用户进行MQTT信息发布时，ESP8266客户端名称各不相同， String topicString = &quot;Taichi-Maker-Pub-&quot; + WiFi.macAddress(); char publishTopic[topicString.length() + 1]; strcpy(publishTopic, topicString.c_str()); // 建立发布信息。信息内容以Hello World为起始，后面添加发布次数。 String messageString = &quot;Hello World &quot; + String(value++); char publishMsg[messageString.length() + 1]; strcpy(publishMsg, messageString.c_str()); // 实现ESP8266向主题发布信息 if(mqttClient.publish(publishTopic, publishMsg))&#123; Serial.println(&quot;Publish Topic:&quot;);Serial.println(publishTopic); Serial.println(&quot;Publish message:&quot;);Serial.println(publishMsg); &#125; else &#123; Serial.println(&quot;Message Publish Failed.&quot;); &#125;&#125;// ESP8266连接wifivoid connectWifi()&#123; WiFi.begin(ssid, password); //等待WiFi连接,成功连接后输出成功信息 while (WiFi.status() != WL_CONNECTED) &#123; delay(1000); Serial.print(&quot;.&quot;); &#125; Serial.println(&quot;&quot;); Serial.println(&quot;WiFi Connected!&quot;); Serial.println(&quot;&quot;); &#125;"},{"title":"","date":"2024-03-31T14:49:40.671Z","updated":"2024-03-31T14:49:40.671Z","comments":true,"path":"notes/esp8266/esp8266_11/index.html","permalink":"https://blog.ajream.top/notes/esp8266/esp8266_11/","excerpt":"","text":"主题 主题基本形式 ​ 主题基本形式就是一个字符串，比如：currentTime，carSpeed ​ 注意：主题区分大小写、可以用空格（但尽量不要用）、尽量使用英文字符 主题分级 ​ MQTT主题各个级别之间可以使用/来分隔。如：Tyler-1/motor/1/speed ​ 示例中一共有四级主题，分别是第1级 Tyler-1、第2级motor、第三级1、第4级speed。 主题通配符 ​ 当客户端订阅主题时，可以使用通配符同时订阅多个主题。通配符只能在订阅主题时使用 单级通配符: + 示例： 123456home/sensor/+/temperature# 可以表示：# home/sensor/aaa/temperature# home/sensor/bbb/temperature# ...... 多级通配符 :# 示例： 123456home/sensor/## 可以表示：# home/sensor/aaa# home/sensor/bbb/ccc# home/sensor/aaa/ccc 注意事项 以$开始的主题 以$开始的主题是MQTT服务端系统保留的特殊主题，不能随意订阅或者向其发布信息。如： 123456$SYS/broker/clients/connected$SYS/broker/clients/disconnected$SYS/broker/clients/total$SYS/broker/messages/sent$SYS/broker/uptime... 避免使用/作为主题的开头 主题中尽量不要使用空格 主题中尽量使用ASCII字符 建议在主题中嵌入客户端ID 【通过主题中的客户端ID内容，可以很容易的了解该主题信息是由哪一台设备所发布的】 ESP8266订阅主题"},{"title":"","date":"2024-03-31T14:49:40.671Z","updated":"2024-03-31T14:49:40.671Z","comments":true,"path":"notes/esp8266/esp8266_2/index.html","permalink":"https://blog.ajream.top/notes/esp8266/esp8266_2/","excerpt":"","text":"1、建立基本网络服务器 导入库文件 ESP8266WebServer.h 创建服务器对象 1ESP8266WebServer server(80); //80是端口号 启动服务器 1server.begin(); 服务器访问配置 12345// 访问根节点时，调用处理函数 handleRootserver.on(&quot;/&quot;, handleRoot);//访问不到，即404时，调用处理函数 handleNotFoundserver.onNotFound(handleNotFound); 访问处理函数 123void handleRoot()&#123; server.send(200, &quot;text/plain&quot;, &quot;Hello from ESP8266&quot;);&#125; 123void handleNotFound()&#123; server.send(404, &quot;text/plain&quot;, &quot;404: Not found&quot;);&#125; 循环监听端口 123void loop()&#123; server.handleClient(); //循环监听客户端访问情况&#125; 完整code： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;ESP8266WiFi.h&gt;#include &lt;ESP8266WiFiMulti.h&gt;#include &lt;ESP8266WebServer.h&gt;ESP8266WiFiMulti wifiMulti;ESP8266WebServer server(80); //80是端口号void setup()&#123; Serial.begin(9600); server.begin(); server.on(&quot;/&quot;, handleRoot); server.onNotFound(handleNotFound); wifiMulti.addAP(&quot;RBook&quot;, &quot;17191719&quot;); wifiMulti.addAP(&quot;bbb&quot;, &quot;12345678&quot;); wifiMulti.addAP(&quot;ccc&quot;, &quot;12345678&quot;); int i = 0; while (wifiMulti.run() != WL_CONNECTED)&#123; delay(600); Serial.print(++i); Serial.print(&quot; &quot;); &#125; Serial.println(&quot;&quot;); Serial.print(&quot;IP Address: &quot;); Serial.println(WiFi.localIP()); &#125;//监听客户端void loop()&#123; server.handleClient();&#125;//访问处理函数void handleRoot()&#123; server.send(200, &quot;text/plain&quot;, &quot;Hello esp8266&quot;);&#125;void handleNotFound()&#123; server.send(404, &quot;text/plain&quot;, &quot;404 not found&quot;);&#125; 2、通过网络服务器实现开发板控制 通过网页控制nodeMCU开发板小灯亮灭 步骤1、2、3、6不变，只是第3、4步的服务器访问配置和访问处理函数有些许改动 服务器访问配置 123456server.on(&quot;/&quot;, HTTP_GET, handleRoot);/*添加这个控制LED的网页, 使用post方式发送http请求*/server.on(&quot;/LED&quot;, HTTP_POST, handleLED); server.onNotFound(handleNotFound); 访问处理函数 1234void handleRoot()&#123; server.send(200, &quot;text/html&quot;, &quot;&lt;form action=\\&quot;/LED\\&quot; method=\\&quot;POST\\&quot;&gt;&lt;input type=\\&quot;submit\\&quot; value=\\&quot;Toggle LED\\&quot;&gt;&lt;/form&gt;&quot;);&#125; 注意这句html代码： 123&lt;form action=&quot;/LED&quot; method=&quot;POST&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;Toggle LED&quot;&gt;&lt;/form&gt; 这会生成一个按钮，点击这个按钮会把数据发到&quot;/LED&quot;页面 下面是“/LED”页面的处理函数： 1234567void handleLED()&#123; static bool LEDState = LOW;//记录LED此时亮灭状态 LEDState = !LEDState; digitalWrite(LED_BUILTIN, LEDState); server.sendHeader(&quot;Location&quot;, &quot;/&quot;); server.send(303); //303表示将网页重定向&#125; 完整code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;ESP8266WiFi.h&gt;#include &lt;ESP8266WiFiMulti.h&gt;#include &lt;ESP8266WebServer.h&gt;ESP8266WiFiMulti wifiMulti;ESP8266WebServer server(80); //80是端口号void setup()&#123; Serial.begin(9600); pinMode(LED_BUILTIN, OUTPUT); //设置内置LED引脚为输出模式 /*服务器配置*/ server.begin(); server.on(&quot;/&quot;, HTTP_GET, handleRoot); server.on(&quot;/LED&quot;, HTTP_POST, handleLED); server.onNotFound(handleNotFound); /*Wifi配置*/ wifiMulti.addAP(&quot;RBook&quot;, &quot;17191719&quot;); wifiMulti.addAP(&quot;bbb&quot;, &quot;12345678&quot;); wifiMulti.addAP(&quot;ccc&quot;, &quot;12345678&quot;); int i = 0; while (wifiMulti.run() != WL_CONNECTED)&#123; delay(600); Serial.print(++i); Serial.print(&quot; &quot;); &#125; Serial.println(&quot;&quot;); Serial.print(&quot;IP Address: &quot;); Serial.println(WiFi.localIP());&#125;void loop()&#123; server.handleClient();&#125;void handleRoot()&#123; server.send(200, &quot;text/html&quot;, &quot;&lt;form action=\\&quot;/LED\\&quot; method=\\&quot;POST\\&quot;&gt;&lt;input type=\\&quot;submit\\&quot; value=\\&quot;Toggle LED\\&quot;&gt;&lt;/form&gt;&quot;);&#125;void handleNotFound()&#123; server.send(404, &quot;text/plain&quot;, &quot;404 not found&quot;);&#125;void handleLED()&#123; static bool LEDState = LOW; //记录LED此时亮灭状态 LEDState = !LEDState; digitalWrite(LED_BUILTIN, LEDState); server.sendHeader(&quot;Location&quot;, &quot;/&quot;); server.send(303); //303表示将网页重定向&#125; 3、将开发板引脚状态发送到终端网页 将引脚D3（已经与flash按键相连，按键按下为低电平）的电平状态显示到网页中 首先在开始时将D3引脚设置为上拉输入模式 1pinMode(D3, INPUT_PULLUP); 循环读取引脚状态 digitalRead() 12345bool pinState;void loop()&#123; pinState = digitalRead(D3); // 获取引脚状态 //......&#125; 要在根节点下显示引脚状态，所以其访问处理函数为： 123456789101112void handleRoot() &#123; String displayPinState; // 存储按键状态的字符串变量 if(pinState == HIGH)&#123; // 当按键引脚D3为高电平 displayPinState = &quot;Button State: HIGH&quot;; // 字符串赋值高电平信息 &#125; else &#123; // 当按键引脚D3为低电平 displayPinState = &quot;Button State: LOW&quot;; // 字符串赋值低电平信息 &#125; esp8266_server.send(200, &quot;text/plain&quot;, displayPinState); // 向浏览器发送按键状态信息 &#125; 完整code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;ESP8266WiFi.h&gt;#include &lt;ESP8266WiFiMulti.h&gt;#include &lt;ESP8266WebServer.h&gt;ESP8266WiFiMulti wifiMulti;ESP8266WebServer server(80); //80是端口号bool pinState;void setup()&#123; Serial.begin(9600); pinMode(D3, INPUT_PULLUP); //上拉输入模式 /*服务器配置*/ server.begin(); server.on(&quot;/&quot;, HTTP_GET, handleRoot); server.onNotFound(handleNotFound); /*Wifi配置*/ wifiMulti.addAP(&quot;RBook&quot;, &quot;17191719&quot;); wifiMulti.addAP(&quot;bbb&quot;, &quot;12345678&quot;); wifiMulti.addAP(&quot;ccc&quot;, &quot;12345678&quot;); int i = 0; while (wifiMulti.run() != WL_CONNECTED)&#123; delay(800); Serial.print(++i); Serial.print(&quot; &quot;); &#125; Serial.println(&quot;&quot;); Serial.print(&quot;IP Address: &quot;); Serial.println(WiFi.localIP());&#125;void loop()&#123; server.handleClient(); pinState = digitalRead(D3);&#125;void handleRoot()&#123; String displayPinState; if(pinState == HIGH)&#123; // 当按键引脚D3为高电平 displayPinState = &quot;Button State: HIGH&quot;; // 字符串赋值高电平信息 &#125; else &#123; // 当按键引脚D3为低电平 displayPinState = &quot;Button State: LOW&quot;; // 字符串赋值低电平信息 &#125; server.send(200, &quot;text/plain&quot;, displayPinState);&#125;void handleNotFound()&#123; server.send(404, &quot;text/plain&quot;, &quot;404 not found&quot;);&#125; 注意：引脚状态改变后需要手动刷新网页，网页显示才会改变"},{"title":"","date":"2024-03-31T14:49:40.671Z","updated":"2024-03-31T14:49:40.671Z","comments":true,"path":"notes/esp8266/esp8266_3/index.html","permalink":"https://blog.ajream.top/notes/esp8266/esp8266_3/","excerpt":"","text":"1、文件基本操作 ESP8266配有一个闪存，这就像是一个小硬盘，上传的文件就可以存放在这个闪存里，这个闪存简称为 SPIFFS 代码中需要用到头文件&lt;FS.h&gt; 包含的类SPIFFS 下面教你如何打开一个文件并向里面写如信息 格式化SPIFFS 1SPIFFS.format(); 启动SPIFFS 1SPIFFS.begin(); //该函数会返回一个bool型结果，启动成功返回true，否则为false 用open函数打开一个文件，如果不存在就会创建文件（打开文件-&gt;写入数据-&gt;关闭文件） 12345//以写入的方式打开一个文件，filename为文件路径String file_name = &quot;/folder/notes.txt&quot;File dataFile = SPIFFS.open(file_name, &quot;w&quot;); dataFile.println(&quot;Hello World&quot;); // 向dataFile写入字符串信息dataFile.close(); // 关闭文件 完整code： 1234567891011121314151617181920#include &lt;FS.h&gt;void setup()&#123; Serial.begin(9600); String filename = &quot;/folder/notes.txt&quot;; SPIFFS.format(); if(SPIFFS.begin()) Serial.println(&quot;SPIFFS Started...&quot;); else Serial.println(&quot;SPIFFS Failed to Start...&quot;); File f = SPIFFS.open(filename, &quot;w&quot;); f.println(&quot;Hello esp8266 world&quot;); f.close(); Serial.println(&quot;Finish writing the file...&quot;); &#125;void loop()&#123; &#125; SPIFFS基于文件的基本操作 1234void SPIFFS.format(); //格式化闪存文件系统 【注意：格式化文件系统需要耗费一定时间】bool SPIFFS.exists(String s); //是否存在文件名为s的文件（准确说s是文件的路径）bool SPIFFS.remove(String s); //删除文件s，返回是否删除成功 123456File f = SPIFFS.open(file_name, &quot;r&quot;); //以读的方式打开一个文件//打印文件中所有内容for(int i=0; i&lt;f.size(); i++)&#123; Serial.print((char)f.read()); &#125; 1234//以添加信息方式打开一个文件File f = SPIFFS.open(file_name, &quot;a&quot;);f.println(&quot;This is Appended Info.&quot;); // 添加字符串信息f.close(); //关闭文件 注意：不论以何种方式打开文件，最后都要记得关闭文件 基于目录的操作 获取一个目录对象 openDir()： 1234567String folder_name = &quot;/folder&quot;; //被读取的文件夹Dir dir = SPIFFS.openDir(folder_name); // 建立“目录”对象// dir.next()可以看作一个指针，每循环一次就会指向下一个元素while (dir.next()) &#123; Serial.println(dir.fileName()); // 输出文件名&#125; 闪存文件系统的基本信息 12345678910111213141516171819FSInfo fs_info; // 创建一个基本信息的对象// 写入闪存文件系统信息到fs_infoSPIFFS.info(fs_info);Serial.print(fs_info.totalBytes); // 可用空间总和（Bytes）Serial.print(fs_info.usedBytes); // 已经用掉的空间（Bytes）// 最大文件名字符限制（含路径和&#x27;\\0&#x27;）Serial.println(fs_info.maxPathLength);// 最多允许打开文件数量Serial.println(fs_info.maxOpenFiles);// 存储块大小Serial.println(fs_info.blockSize);// 存储页大小Serial.println(fs_info.pageSize); 2、通过Arduino IDE向闪存文件系统上传文件 看太极创客这篇文章 【注意】 上传文件前，把【串口监视器】关闭 之前上传的代码中没有使用格式化，否则刚上传的文件就被格式化删除了 3、使用闪存系统配置功能更丰富的网络服务器 太极创客文章"},{"title":"","date":"2024-03-31T14:49:40.671Z","updated":"2024-03-31T14:49:40.671Z","comments":true,"path":"notes/esp8266/esp8266_4/index.html","permalink":"https://blog.ajream.top/notes/esp8266/esp8266_4/","excerpt":"","text":"ESP8266-Arduino库中有两个库用于控制ESP8266与网络服务器进行通讯。他们是WiFiClient库和ESP8266HTTPClient库。 【注意】 WiFiClient 被声明在 &lt;ESP8266WiFi.h&gt; 中（这种方式实现Client更复杂，但灵活） 而ESP8266HTTPClient被单独声明在 &lt;ESP8266HTTPClient.h&gt;（这种方式实现Client更简单，但很多功能不能根据自己意愿来定制实现） 1、ESP8266HTTPClient 实现 连接WiFi，具体实现看第一篇文章 连接WiFi后，写一个函数来访问服务器 函数设计，五个步骤： 创建客户端对象 配置访问地址url 发送get（post）请求 请求成功：处理返回信息 请求失败：（任意） 结束请求 123456789101112131415161718192021222324// 发送HTTP请求并且将服务器响应通过串口输出void httpClientRequest()&#123; //1 创建 HTTPClient 对象 HTTPClient httpClient; //2 通过begin函数配置请求地址 httpClient.begin(URL); //3 通过GET函数启动连接并发送HTTP请求 int httpCode = httpClient.GET(); //4 处理服务器返回信息 if (httpCode == HTTP_CODE_OK) &#123; // 使用getString函数获取服务器响应体内容 String responsePayload = httpClient.getString(); //... &#125; else &#123; //... &#125; //5 关闭ESP8266与服务器连接 httpClient.end();&#125; 完整code： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;ESP8266WiFi.h&gt;#include &lt;ESP8266HTTPClient.h&gt;void setup() &#123; String url = &quot;http://www.example.com&quot;; Serial.begin(115200); WiFi.mode(WIFI_STA); WiFi.begin(&quot;RBook&quot;, &quot;17191719&quot;); for(int i=0; WiFi.status() != WL_CONNECTED; i++)&#123; delay(1000); Serial.printf(&quot;%d &quot;, i); &#125; Serial.print(&quot;\\r\\nwifi is connected\\r\\n&quot;); getResponse(url); &#125;void loop() &#123; // put your main code here, to run repeatedly:&#125;//五个步骤进行发送请求并获取数据void getResponse(String url)&#123; HTTPClient httpClient; // 1 httpClient.begin(url); // 2 int httpCode = httpClient.GET(); // 3 // 4 if(httpCode == HTTP_CODE_OK)&#123; Serial.printf(&quot;httpCode: %d Success......\\n&quot;, httpCode); String res = httpClient.getString(); Serial.println(&quot;======================&quot;); Serial.println(res); Serial.println(&quot;======================&quot;); &#125; else &#123; Serial.printf(&quot;httpCode: %d Failed......\\n&quot;, httpCode); &#125; // 5 httpClient.end(); &#125; 【注意】 转义字符 \\r 表示将光标移动到本行开头（继续输出会覆盖本行内容） \\r\\n 表示将光标移到开头再换行（不会覆盖本行内容），一般与 \\n 效果相同 2、WiFiClient 实现 创建对象 连接服务器 连接成功：（1）发送请求（2）获取并处理服务器响应的数据（3）断开与服务器的连接 连接失败：断开连接 12345678910111213141516171819202122232425262728void wifiClientRequest(String url)&#123; // 建立WiFi客户端对象 WiFiClient client; // 建立字符串，用于HTTP请求 String httpRequest = String(&quot;GET /&quot;) + &quot; HTTP/1.1\\r\\n&quot; + &quot;url: &quot; + url + &quot;\\r\\n&quot; + &quot;Connection: close\\r\\n&quot; + &quot;\\r\\n&quot;; // 连接网络服务器 if (client.connect(url, httpPort))&#123; //连接成功connect会返回true client.print(httpRequest); // 向服务器发送HTTP请求 // 通过串口输出网络服务器响应信息 while (client.connected() || client.available())&#123; if (client.available())&#123; String line = client.readStringUntil(&#x27;\\n&#x27;); //一行一行读取 Serial.println(line); &#125; &#125; client.stop(); // 断开与服务器的连接 &#125; else&#123; client.stop(); // 如果连接不成功则断开连接 &#125;"},{"title":"","date":"2024-03-31T14:49:40.671Z","updated":"2024-03-31T14:49:40.671Z","comments":true,"path":"notes/esp8266/esp8266_5/index.html","permalink":"https://blog.ajream.top/notes/esp8266/esp8266_5/","excerpt":"","text":"Stream数据流 1、串口收发数据 123456789101112void setup() &#123; // 启动串口通讯 Serial.begin(9600); Serial.println();&#125; void loop() &#123; if (Serial.available())&#123; // 当串口接收到信息后 String serialData = Serial.readString(); // 将接收到的信息存储于serialData变量 Serial.print(serialData); &#125;&#125; 使用Serial.available来判断ESP8266开发板是否接收到串口数据 实际上，ESP8266开发板通过串口收发的数据通过Stream进行的 下面的程序将演示： 当ESP8266找到了find函数所指定的参数“ok”后，随即在后续接收到的数据中查找数字信息。一旦找到数字，则通过串口监视器输出。接下来串口监视器还将输出找到数字后剩余的串口输入信息是什么。 123456789101112131415161718192021void setup() &#123; Serial.begin(9600); Serial.println(&quot;&quot;); Serial.println(&quot;Please enter input...&quot;);&#125; void loop() &#123; while(Serial.available())&#123; if(Serial.find(&quot;ok&quot;))&#123; Serial.println(&quot;Found ok in user input.&quot;); int serialParseInt = Serial.parseInt(); Serial.print(&quot;serialParseInt = &quot;); Serial.println(serialParseInt); String serialInput = Serial.readString(); Serial.print(&quot;serialInput = &quot;); Serial.println(serialInput); &#125; &#125;&#125; 2、使用Stream方式来读取服务器响应的信息 （具体看第4篇文章第2点的代码） 123456while (client.connected() || client.available())&#123; if (client.available())&#123; String line = client.readStringUntil(&#x27;\\n&#x27;); //读取返回的数据 Serial.println(line); &#125;&#125; 3、使用Stream方式来读取文件内容 12File f = SPIFFS.open(file_name, &quot;r&quot;); // 以“r”模式再次打开闪存文件Serial.println(f.readString()); // 读取文件内容"},{"title":"","date":"2024-03-31T14:49:40.671Z","updated":"2024-03-31T14:49:40.671Z","comments":true,"path":"notes/esp8266/esp8266_6/index.html","permalink":"https://blog.ajream.top/notes/esp8266/esp8266_6/","excerpt":"","text":"之前nodeMCU一直都要用代码进行连接WiFi的操作，但这样很不方便，如何使用电脑或手机等设备来实时扫描周围WiFi进行配网？ 这里主要用到 WiFiManager库，可以去太极创客下载并加载到ArduinoIDE中。 1、清除WiFi信息 使用前要先清除掉此前连接过的WiFi信息，不然一上电nodeMCU就直接连接上之前的WiFi了 只需2个步骤： 创建WiFiManager对象 清除WiFi信息 12WiFiManager wifiManager; //创建对象wifiManager.resetSettings(); //清除WiFi信息 完整code 12345678910111213141516#include &lt;ESP8266WiFi.h&gt; #include &lt;DNSServer.h&gt;#include &lt;ESP8266WebServer.h&gt;#include &lt;WiFiManager.h&gt; void setup() &#123; Serial.begin(9600); // 建立WiFiManager对象 WiFiManager wifiManager; // 清除ESP8266所存储的WiFi连接信息以便测试WiFiManager工作效果 wifiManager.resetSettings(); Serial.println(&quot;ESP8266 WiFi Settings Cleared&quot;);&#125; void loop() &#123;&#125; 2、WiFi配网 创建WiFiManager对象 开启接入点模式（就是在开发板上开个热点，让周围设备连接） 1wifiManager.autoConnect(&quot;热点名称&quot;[, &quot;密码&quot;]); 接下来就可以用手机、电脑配网 （1）用手机（或电脑）连接开发板的热点 （2）连接后会自动跳转到一个网页（网页地址就是开发板ip），然后手动选择让开发板连接周围WiFi （3）开发板连接上周围的WiFi后会自动关闭热点，连接不上就会再开启热点，重新配网 （4）【注意1】：连接后不能主动更换为其他WiFi，除非该WiFi断开了，开发板才会再次打开热点，否则如要更换WiFi需要擦除已连接的WiFi信息 （5）【注意2】：如果连接了校园网WiFi，但需要登录才能用，此时也不能主动断开WiFi去选择其他能用的WiFi，也需要擦除已连接的WiFi信息。 判断是否配网成功 可以在串口监视屏打印连接上的WiFi名称 完整code： 1234567891011121314151617181920212223242526#include &lt;ESP8266WiFi.h&gt; #include &lt;DNSServer.h&gt;#include &lt;ESP8266WebServer.h&gt;#include &lt;WiFiManager.h&gt; void setup() &#123; Serial.begin(9600); // 建立WiFiManager对象 WiFiManager wifiManager; // 自动连接WiFi。以下语句的参数是连接ESP8266时的WiFi名称 wifiManager.autoConnect(&quot;ESP8266-wifi&quot;); // 如果您希望该WiFi添加密码，可以使用以下语句： // wifiManager.autoConnect(&quot;ESP8266-wifi&quot;, &quot;12345678&quot;); // WiFi连接成功后将通过串口监视器输出连接成功信息 Serial.println(&quot;&quot;); Serial.print(&quot;ESP8266 Connected to &quot;); Serial.println(WiFi.SSID()); // 连接上的WiFi名称 Serial.print(&quot;IP address:\\t&quot;); Serial.println(WiFi.localIP()); // IP&#125; void loop() &#123;&#125;"},{"title":"","date":"2024-03-31T14:49:40.671Z","updated":"2024-03-31T14:49:40.671Z","comments":true,"path":"notes/esp8266/esp8266_7/index.html","permalink":"https://blog.ajream.top/notes/esp8266/esp8266_7/","excerpt":"","text":"通过Ticker库可以让esp8266同时执行多个任务 1、如何实现 示例：在实现一个呼吸灯的同时，在串口监视器打印一些字符信息 创建 Ticker对象 1Ticker ticker; 定时执行某个函数 12ticker.attach(time, func); //time单位为s，func为函数名ticker.attach_ms(time, func); //time单位为ms，func为函数名 12345678910111213141516171819202122232425262728293031323334#include &lt;Ticker.h&gt;Ticker ticker;// 建立Ticker用于实现定时功能int count; // 计数用变量void setup() &#123; Serial.begin(9600); pinMode(LED_BUILTIN, OUTPUT); // attach函数的第一个参数是控制定时间隔的变量。该参数的单位为秒。第二个参数是 // 定时执行的函数名称。 ticker.attach(1, sayHi);&#125;void loop() &#123; // 用LED呼吸灯效果来演示在Tinker对象控制下，ESP8266可以定时执行其它任务 for (int fadeValue = 0 ; fadeValue &lt;= 1023; fadeValue += 5) &#123; analogWrite(LED_BUILTIN, fadeValue); delay(10); &#125; for (int fadeValue = 1023 ; fadeValue &gt;= 0; fadeValue -= 5) &#123; analogWrite(LED_BUILTIN, fadeValue); delay(10); &#125; delay(3000);&#125;// 在Tinker对象控制下，此函数将会定时执行。void sayHi()&#123; count++; Serial.print(&quot;Hi &quot;); Serial.println(count);&#125; 2、其他操作 停止执行定时任务：ticker.detach() 向定时调用函数传递参数：ticker.attach(1, sayHi, 8) 【注意】： attach函数所能传递的参数最多只有一个 该参数仅能是以下类型中的一种：char, short, int, float, void*, char* 利用多个Ticker对象可以让ESP8266处理多任务"},{"title":"","date":"2024-03-31T14:49:40.671Z","updated":"2024-03-31T14:49:40.671Z","comments":true,"path":"notes/esp8266/esp8266_8/index.html","permalink":"https://blog.ajream.top/notes/esp8266/esp8266_8/","excerpt":"","text":"所谓OTA，就是Over-The-Air的缩写，通过OTA我们无需将ESP8266与电脑连接，而仅仅通过WiFi就可以用Arduino IDE向ESP8266上传程序。 在这一节课程里，我们将分步骤向您介绍如何实现ESP8266的OTA操作。 1、通过数据线上传初始示例程序 首先，请将以下示例程序通过Arduino IDE上传到ESP8266。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;ESP8266WiFi.h&gt;#include &lt;ArduinoOTA.h&gt;#include &lt;Ticker.h&gt; // 闪烁时间间隔(秒)const int blinkInterval = 2; // 设置wifi接入信息(请根据您的WiFi信息进行修改)const char* ssid = &quot;taichimaker&quot;;const char* password = &quot;12345678&quot;; Ticker ticker; void setup() &#123; Serial.begin(9600); Serial.println(&quot;&quot;); pinMode(LED_BUILTIN, OUTPUT); ticker.attach(blinkInterval, tickerCount); // 设置Ticker对象 connectWifi(); // OTA设置并启动 ArduinoOTA.setHostname(&quot;ESP8266&quot;); ArduinoOTA.setPassword(&quot;12345678&quot;); ArduinoOTA.begin(); Serial.println(&quot;OTA ready&quot;);&#125;void loop() &#123; ArduinoOTA.handle();&#125; // 在Tinker对象控制下，此函数将会定时执行。void tickerCount()&#123; digitalWrite(LED_BUILTIN, !digitalRead(LED_BUILTIN));&#125; void connectWifi()&#123; //开始连接wifi WiFi.begin(ssid, password); //等待WiFi连接,连接成功打印IP while (WiFi.status() != WL_CONNECTED) &#123; delay(1000); Serial.print(&quot;.&quot;); &#125; Serial.println(&quot;&quot;); Serial.println(&quot;WiFi Connected!&quot;); Serial.print(&quot;IP address:\\t&quot;); Serial.println(WiFi.localIP()); &#125; 2、通过Arduino IDE正确选择OTA端口 程序上传后，请重新启动Arduino IDE。并且通过Arduino IDE正确选择ESP8266的OTA端口。 如下图所示： 3、认证并上传程序 点击Arduino IDE的”上传”按钮后， IDE将会弹出对话框让用户输入OTA上传密码。请根据示例程序中的setPassword函数所设置的信息来输入密码。完成密码输入后，点击确定。如果密码无误，您将看到程序开始上传。 程序上传结束后，ESP8266将会自动重启开发板，新的程序也将在重启后开始运行。 4、OTA的局限性 1. 程序占用空间变大 在OTA上传新程序过程中， ESP8266开发板将会保持旧程序的运行。这将导致ESP8266开发板的程序占用空间翻倍。假如您的程序非常复杂，占用空间很大，那么使用OTA上传就不太适合了。 2. Arduino IDE无法通过OTA端口与开发板进行串口通讯 当Arduino IDE的上传端口选为“网络端口”，Arduino IDE将无法获取ESP8266的串口通讯数据。不过ESP8266的串口通讯并不会因为OTA功能而受到影响。换句话说，您可以使用其它电脑串口通讯软件，如Putty等，来实现ESP8266与电脑之间的串口通讯。 3.使用OTA上传程序的电脑与ESP8266必须连接同一WiFi 若要使用OTA上传功能，那么电脑和ESP8266必须要在同一WiFi中，否则是无法实现OTA上传的。"},{"title":"","date":"2024-03-31T14:49:40.671Z","updated":"2024-03-31T14:49:40.671Z","comments":true,"path":"notes/esp8266/esp8266_9/index.html","permalink":"https://blog.ajream.top/notes/esp8266/esp8266_9/","excerpt":"","text":"什么是MQTT MQTT是一个客户端服务端架构的发布/订阅模式的消息传输协议。 优点： 轻巧、开放、简单、规范，易于实现。 这些特点使得它对很多场景来说都是很好的选择，特别是对于受限的环境如机器与机器的通信（M2M）以及物联网环境（IoT）。 基本原理 在MQTT协议通讯中，有两个最为重要的角色。它们分别是服务端和客户端。 服务端： 是消息传输的枢纽 客户端： 客户端有多个，它们之间不能直接相互通信，中间使用服务端来处理消息分配。 客户端要获取某个主题信息，要向服务端进行主题 “订阅”，订阅后可以向服务端发送与主题相关的信息，其他客户端再从服务端获取信息。 客户端连接服务端 分2个步骤 客户端向服务端发送请求数据包“CONNECT”（也叫报文），其中包含了连接请求的信息 服务端收到请求后，发送数据包“CONNACK”进行确认 CONNECT报文 这是该报文的信息： clientID clientId是MQTT客户端的唯一标识，MQTT服务端以此来识别客户端 cleanSession – 清除会话 表示如果客户端未能正确接收到数据时，服务端是否要对数据进行保存； 取值true表示保存，false表示不保存 注意：如果数据很重要，客户端没有正确接收到会造成严重后果，建议取值true，让服务端先把会话保留，待客户端能正常接收再发送。 反之如果数据不会重要，可以取值为false keepAlive —— 间隔时间 用于服务端每隔多久就了解一下客户端是否与其保持连接的情况 CONNACK – 确认连接请求 sessionPresent CONNACK报文的sessionPresent与CONNECT报文的cleanSession相互配合。 cleanSession=true时，sessionPresent应该配置为false，即不需要保存信息；反之sessionPresent应该配置为true，即需要保存会话信息。 总之，sessionPresent作用是客户端发送连接请求时，服务端告知客户端有没有保存报文信息。这个被服务端保存的报文信息是来自于上一次客户端连接时，服务端曾经发送此报文给客户端，但是发送后没有收到客户端接收确认。 returnCode —— 返回码 当服务端收到了客户端的连接请求后，会向客户端发送returnCode(返回码)，用以说明连接情况 返回码 返回码描述 0 成功连接 1 连接被服务端拒绝，原因是不支持客户端的MQTT协议版本 2 连接被服务端拒绝，原因是不支持客户端标识符的编码。 可能造成此原因的是客户端标识符编码是UTF-8，但是服务端不允许使用此编码。 3 连接被服务端拒绝，原因是服务端不可用。 即，网络连接已经建立，但MQTT服务不可用。 4 连接被服务端拒绝，原因是用户名或密码无效。 5 连接被服务端拒绝，原因是客户端未被授权连接到此服务端。 ESP8266连接MQTT服务端 http://test.ranye-iot.net 是国内一个MQTT服务器平台地址，TCP端口为1883 接下来使用PubSubClient库（去GitHub下载zip包后通过ArduinoIDE添加即可）来实现MQTT物联网应用。 配置WiFi 创建mqtt客户端对象（间接创建） 12WiFiClient wifiClient;PubSubClient mqttClient(wifiClient); 配置客户端要连接哪个服务端（绑定服务端） 123String mqttServer = &quot;test.ranye-iot.net&quot;;const int port = 1883;mqttClient.setServer(mqttServer, port); //连接服务端 连接服务端 1234//用设备的mac地址来生成唯一标识该设备的clientIDString clientID = &quot;esp8266-&quot; + WiFi.macAddress(); mqttClient.connect(clientId.c_str()) //连接成功返回true 连接成功后保持 “心跳”，否则…（可以尝试继续连接） 1234567void loop() &#123; if (mqttClient.connected()) &#123; // 如果开发板成功连接服务器 mqttClient.loop(); // 保持客户端心跳 &#125; else &#123; // 如果开发板未能成功连接服务器 connectMQTTServer(); // 则尝试连接服务器 &#125;&#125; 完整code： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;ESP8266WiFi.h&gt;#include &lt;PubSubClient.h&gt; // 设置wifi接入信息(请根据您的WiFi信息进行修改)const char* ssid = &quot;rbook&quot;;const char* password = &quot;12345678&quot;;const char* mqttServer = &quot;test.ranye-iot.net&quot;; // 如以上MQTT服务器无法正常连接，请前往以下页面寻找解决方案// http://www.taichi-maker.com/public-mqtt-broker/ WiFiClient wifiClient;PubSubClient mqttClient(wifiClient); void setup() &#123; Serial.begin(9600); //设置ESP8266工作模式为无线终端模式 WiFi.mode(WIFI_STA); // 连接WiFi connectWifi(); // 设置MQTT服务器和端口号 mqttClient.setServer(mqttServer, 1883); // 连接MQTT服务器 connectMQTTServer();&#125; void loop() &#123; if (mqttClient.connected()) &#123; // 如果开发板成功连接服务器 mqttClient.loop(); // 保持客户端心跳 &#125; else &#123; // 如果开发板未能成功连接服务器 connectMQTTServer(); // 则尝试连接服务器 &#125;&#125; void connectMQTTServer()&#123; // 根据ESP8266的MAC地址生成客户端ID（避免与其它ESP8266的客户端ID重名） String clientId = &quot;esp8266-&quot; + WiFi.macAddress(); // 连接MQTT服务器 if (mqttClient.connect(clientId.c_str())) &#123; Serial.println(&quot;MQTT Server Connected.&quot;); Serial.println(&quot;Server Address: &quot;); Serial.println(mqttServer); Serial.println(&quot;ClientId:&quot;); Serial.println(clientId); &#125; else &#123; Serial.print(&quot;MQTT Server Connect Failed. Client State:&quot;); Serial.println(mqttClient.state()); delay(3000); &#125; &#125;// ESP8266连接wifivoid connectWifi()&#123; WiFi.begin(ssid, password); //等待WiFi连接,成功连接后输出成功信息 while (WiFi.status() != WL_CONNECTED) &#123; delay(1000); Serial.print(&quot;.&quot;); &#125; Serial.println(&quot;&quot;); Serial.println(&quot;WiFi Connected!&quot;); Serial.println(&quot;&quot;); &#125;"},{"title":"","date":"2024-03-31T14:49:40.671Z","updated":"2024-03-31T14:49:40.671Z","comments":true,"path":"notes/javase/awt/index.html","permalink":"https://blog.ajream.top/notes/javase/awt/","excerpt":"","text":"Frame 创建第一个Frame 123456789101112131415161718192021package com.ajream.lesson1;import java.awt.*;public class TestFrame &#123; public static void main(String[] args) &#123; /*窗口标题*/ Frame frame = new Frame(&quot;Title&quot;); frame.setSize(400, 400); frame.setVisible(true); frame.setBackground(new Color(114, 72, 173)); frame.setLocation(200,200); frame.setResizable(false); /*使大小固定*/ &#125;&#125; 将Frame的创建打包成类使用 12345678910111213141516171819202122232425262728package com.ajream.lesson1;import java.awt.*;public class TestFrame2 &#123; public static void main(String[] args) &#123; MyFrame frame1 = new MyFrame(100, 100, 200, 200, Color.BLUE); MyFrame frame2 = new MyFrame(300, 100, 200, 200, Color.GREEN); MyFrame frame3 = new MyFrame(100, 300, 200, 200, Color.YELLOW); MyFrame frame4 = new MyFrame(300, 300, 200, 200, Color.PINK); &#125;&#125;//封装成类class MyFrame extends Frame&#123; static int id = 0; public MyFrame(int x, int y, int w, int h, Color color)&#123; super(&quot;Myframe&quot; + (++id)); setBackground(color); setSize(w, h); setLocation(x, y); setVisible(true); &#125;&#125; 面板 panel panel需要放在Frame上 123Frame frame = new Frame();Panel panel = new Panel();frame.add(panel); 监听事件 123456789frame.addWindowListener(new WindowAdapter() &#123; @Override public void windowClosing(WindowEvent e) &#123; //super.windowClosing(e); System.exit(0); &#125;&#125;); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.ajream.lesson1;import java.awt.*;import java.awt.event.WindowAdapter;import java.awt.event.WindowEvent;import java.awt.event.WindowListener;public class TestPanel &#123; public static void main(String[] args) &#123; Frame frame = new Frame();// 布局的概念 Panel panel = new Panel();// 设置布局 frame.setLayout(null);// frame坐标 frame.setBounds(400, 500, 400, 400); frame.setBackground(Color.BLUE);// 设置panel坐标，相对于frame panel.setBounds(50, 50, 300, 300); panel.setBackground(Color.GREEN); frame.add(panel); frame.setVisible(true);// 监听事件 frame.addWindowListener(new WindowAdapter() &#123; @Override public void windowClosing(WindowEvent e) &#123;// super.windowClosing(e); System.exit(0); &#125; &#125;); &#125;&#125; 布局管理器 流式布局(默认使用)-FlowLayout 使用布局(自动按照规则排列，如果是 FlowLayout.LEFT 则从左向右排) 12//new FlowLayout() 参数有 FlowLayout.LEFT。 FlowLayout.CENTER, RIGHT...frame.setLayout(new FlowLayout(FlowLayout.LEFT)); 例子 1234567891011121314151617181920212223242526package com.ajream.lesson1;import java.awt.*;public class TestFlowLayout &#123; public static void main(String[] args) &#123; Frame frame = new Frame(); frame.setBounds(400, 500, 500, 500); frame.setVisible(true); frame.setBackground(Color.magenta);// 流式布局// new FlowLayout() 参数有 FlowLayout.LEFT。 FlowLayout.CENTER, RIGHT... frame.setLayout(new FlowLayout(FlowLayout.LEFT)); Button btn1 = new Button(&quot;btn1&quot;); Button btn2 = new Button(&quot;btn2&quot;); Button btn3 = new Button(&quot;btn3&quot;); frame.add(btn1); frame.add(btn2); frame.add(btn3); &#125;&#125; 东西南北中-BorderLayout 布局使用 12345678910111213frame.setLayout(new BorderLayout());Button btn1 = new Button(&quot;东&quot;);Button btn2 = new Button(&quot;西&quot;);Button btn3 = new Button(&quot;南&quot;);Button btn4 = new Button(&quot;北&quot;);Button btn5 = new Button(&quot;中&quot;);frame.add(btn1, BorderLayout.EAST);frame.add(btn2, BorderLayout.WEST);frame.add(btn3, BorderLayout.SOUTH);frame.add(btn4, BorderLayout.NORTH);frame.add(btn5, BorderLayout.CENTER); 例子 1234567891011121314151617181920212223242526272829package com.ajream.lesson1;import java.awt.*;public class TestBoderLayout &#123; public static void main(String[] args) &#123; Frame frame = new Frame(); frame.setBounds(400, 500, 500, 500); frame.setVisible(true); frame.setBackground(Color.magenta);// 东西南北中布局(贴着边界摆放组件) frame.setLayout(new BorderLayout()); Button btn1 = new Button(&quot;东&quot;); Button btn2 = new Button(&quot;西&quot;); Button btn3 = new Button(&quot;南&quot;); Button btn4 = new Button(&quot;北&quot;); Button btn5 = new Button(&quot;中&quot;); frame.add(btn1, BorderLayout.EAST); frame.add(btn2, BorderLayout.WEST); frame.add(btn3, BorderLayout.SOUTH); frame.add(btn4, BorderLayout.NORTH); frame.add(btn5, BorderLayout.CENTER); &#125;&#125; 表格布局-GridLayout 布局使用 12345678910111213141516//表格布局（2行3列）frame.setLayout(new GridLayout(2,3));Button btn1 = new Button(&quot;btn1&quot;);Button btn2 = new Button(&quot;btn2&quot;);Button btn3 = new Button(&quot;btn3&quot;);Button btn4 = new Button(&quot;btn4&quot;);Button btn5 = new Button(&quot;btn5&quot;);Button btn6 = new Button(&quot;btn6&quot;);frame.add(btn1);frame.add(btn2);frame.add(btn3);frame.add(btn4);frame.add(btn5);frame.add(btn6); 例子 12345678910111213141516171819202122232425262728293031package com.ajream.lesson1;import java.awt.*;public class TestGridLayout &#123; public static void main(String[] args) &#123; Frame frame = new Frame(); frame.setBounds(400, 500, 500, 500); frame.setVisible(true); frame.setBackground(Color.magenta);// 表格布局（2行3列） frame.setLayout(new GridLayout(2,3)); Button btn1 = new Button(&quot;btn1&quot;); Button btn2 = new Button(&quot;btn2&quot;); Button btn3 = new Button(&quot;btn3&quot;); Button btn4 = new Button(&quot;btn4&quot;); Button btn5 = new Button(&quot;btn5&quot;); Button btn6 = new Button(&quot;btn6&quot;); frame.add(btn1); frame.add(btn2); frame.add(btn3); frame.add(btn4); frame.add(btn5); frame.add(btn6); &#125;&#125; 练习 做一个类似下面的界面 构思：在Frame上添加4个panel 代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.ajream.lesson1;import java.awt.*;import java.awt.event.WindowAdapter;import java.awt.event.WindowEvent;public class ExerciseLayout &#123; public static void main(String[] args) &#123; Frame frame = new Frame(); frame.setBackground(Color.BLUE); frame.setVisible(true); frame.setBounds(300, 300, 500, 500); frame.setLayout(new GridLayout(2,1)); Panel p1 = new Panel(); Panel p2 = new Panel(); Panel p3 = new Panel(); Panel p4 = new Panel(); p3.setLayout(new GridLayout(2,1)); p3.add(new Button(&quot;p3_btn1&quot;)); p3.add(new Button(&quot;p3_btn2&quot;)); p1.setLayout(new BorderLayout()); p1.add(new Button(&quot;p1_btn1&quot;), BorderLayout.WEST); p1.add(new Button(&quot;p1_btn2&quot;), BorderLayout.EAST); p1.add(p3, BorderLayout.CENTER); p4.setLayout(new GridLayout(2,2)); for (int i = 0; i &lt; 4; i++) &#123; p4.add(new Button(&quot;p4_btn&quot;+(i+1))); &#125; p2.setLayout(new BorderLayout()); p2.add(new Button(&quot;p2_btn1&quot;),BorderLayout.WEST); p2.add(new Button(&quot;p2_btn2&quot;),BorderLayout.EAST); p2.add(p4,BorderLayout.CENTER);// 把p1, p2添加到frame frame.add(p1); frame.add(p2); frame.addWindowListener(new WindowAdapter() &#123; @Override public void windowClosing(WindowEvent e) &#123; System.exit(0); &#125; &#125;); &#125;&#125; 事件监听 事件：实现了 ActionListener接口的类 ActionListener只有一个方法：void actionPerformed 123456class MyEvent implements ActionListener &#123; @Override public void actionPerformed(ActionEvent e) &#123; System.out.println(&quot;点击了btn&quot;); &#125;&#125; 参数e表示某个组件触发的事件 123456class MyEvent implements ActionListener &#123; @Override public void actionPerformed(ActionEvent e) &#123; System.out.println(&quot;msg =&gt; &quot; + e.getActionCommand()); &#125;&#125; 监听事件 1button.addActionListener(new MyEvent()); 例子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.ajream.lesson2;import java.awt.*;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.awt.event.WindowAdapter;import java.awt.event.WindowEvent;public class TestActionEvent &#123; public static void main(String[] args) &#123; Frame frame = new Frame(); frame.setBounds(200, 300, 300, 300); frame.addWindowListener(new WindowAdapter() &#123; @Override public void windowClosing(WindowEvent e) &#123; System.exit(0); &#125; &#125;); Button button1 = new Button(&quot;btn1&quot;); Button button2 = new Button(&quot;btn2&quot;); button1.setActionCommand(&quot;点击了btn1&quot;); button2.setActionCommand(&quot;点击了btn2&quot;); MyEvent myEvent = new MyEvent(); button1.addActionListener(myEvent); button2.addActionListener(myEvent); frame.add(button1, BorderLayout.NORTH); frame.add(button2, BorderLayout.SOUTH); frame.pack(); frame.setVisible(true); &#125;&#125;class MyEvent implements ActionListener &#123; @Override public void actionPerformed(ActionEvent e) &#123; System.out.println(&quot;msg ==&gt; &quot; + e.getActionCommand()); &#125;&#125;"},{"title":"","date":"2024-03-31T14:49:40.671Z","updated":"2024-03-31T14:49:40.671Z","comments":true,"path":"notes/javase/http/index.html","permalink":"https://blog.ajream.top/notes/javase/http/","excerpt":"","text":"介绍 超文本传输协议（Hyper Text Transfer Protocol，HTTP）是一个简单的请求-响应协议，它通常运行在TCP之上，如图 文本：html， 字符串… 超文本：图片、音乐…… http端口：80 https端口：443 Http请求与响应 HTTP协议永远都是客户端发起请求，服务器回送响应。见下图： 这样就限制了使用HTTP协议，无法实现在客户端没有发起请求的时候，服务器将消息推送给客户端 请求报文：请求行 － 通用信息头 － 请求头 － 实体头 － 报文主体 响应（应答）报文：状态行 － 通用信息头 － 响应头 － 实体头 － 报文主体 HTTP请求方式 GET：最常用的请求方式，使用GET方法应该只用在获取数据 POST：向指定资源提交数据，请求服务器进行处理（例如提交表单或者上传文件）。数据被包含在请求本文中。这个请求可能会创建新的资源或修改现有资源，或二者皆有 除此以外还有HEAD/PUT/DELETE/TRACE/OPTIONS/CONNECT 这8种不常用的请求方式 URL URL被称为：统一资源定位符 其中通常包含信息： 传送协议 层级URL标记符号（为[//],固定不变） 访问资源需要的凭证信息（可省略） 服务器地址（通常为域名，有时为IP地址） 端口号（可省略，默认使用http协议，端口为80） 资源路径（以“/”字符区别路径中的每一个目录名称） 查询（可省略，GET模式的窗体参数，以“?”字符为起点，每个参数以“&amp;”隔开，再以“=”分开参数名称与数据，通常以UTF8的URL编码，避开字符冲突的问题） 片段。以“#”字符为起点（可省略） 例如： 1http://www.luffycity.com:80/news/index.html?id=250&amp;page=1 HTTP状态码 状态码元由3位数字组成，表示请求是否被理解或被满足。 1XX: 信息——请求已被服务器接收，继续处理 2XX: 连接成功 200：请求成功（其后是对GET和POST请求的应答文档） 3XX: 重定向 300：多重选择。链接列表。用户可以选择某链接到达目的地。最多允许五个地址 301：所请求的页面已经转移至新的url 302：所请求的页面已经临时转移至新的url 303：所请求的页面可在别的url下被找到 4XX: 请求错误 400：服务器不理解请求 401：被请求的页面需要用户名和密码 403：对被请求页面的访问被禁止 404：服务器无法找到被请求的页面 5XX: 服务器错误 500：请求未完成，服务器遇到不可预知的情况。 501：请求未完成。服务器不支持所请求的功能。 503：请求未完成。服务器临时过载或宕机。 504：网关超时 HTTP请求报文 例如： HTTP响应报文 例如： Http工作原理 HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。 HTTP协议采用了请求/响应模型: 客户端向服务器发送一个【请求报文】，请求报文包含请求的方法(get/post/…)、URL、协议版本、请求头部和请求数据。 服务器以一个【状态行】作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。 典型的HTTP事务处理有如下的过程： （1）客户与服务器建立连接： 一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接 （2）客户向服务器提出请求： 通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。 （3）服务器接受请求，并根据请求返回相应的文件作为应答： Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。 （4）客户与服务器关闭连接： 若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接; 若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求; （5）客户端浏览器解析HTML内容： 客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。 然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。 客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。"},{"title":"","date":"2024-03-31T14:49:40.671Z","updated":"2024-03-31T14:49:40.671Z","comments":true,"path":"notes/javase/javase_1/index.html","permalink":"https://blog.ajream.top/notes/javase/javase_1/","excerpt":"","text":"类与对象 类可以看成是具有很多相似性质、功能的事物的集合，如鸟可以看作一个类，鸟都具有各自的名称，各色的羽毛、飞等相似特点； 用代码创建一个鸟类： 1234567public class Bird&#123; String name; String feathers_color; public void fly()&#123; System.out.println(name + &quot;可以飞&quot;) &#125;&#125; 对象可以看作是类的一个具体事例，如上面所说的鸟类，鸽子是鸟类的一种，老鹰也是鸟类一种，因此鸽子、老鹰都可以分别看作是鸟类的一个对象； 用代码来创建对象： 12Bird bird1 = new Bird();Bird bird2 = new Bird(); 引用与指向 在下面创建的这一对象中 1Bird bird1 = new Bird(); bird1存储的是对象的地址，因此bird1是对象的引用；这一地址指向了对象本身； 多个引用指向同一对象 123Bird b1 = new Bird();Bird b2 = b1;Bird b3 = b1; 多个引用指向多个（不同）对象 123Bird b1 = new Bird();Bird b2 = new Bird();Bird b3 = new Bird(); 继承 可以创建两个类，其中一个类可以继承另一个类的属性和方法，继承语法： 123public class ClassName2 extends ClassName1&#123;&#125; 例如： 首先创建父类Item 1234public class Item &#123; String name; int price;&#125; 创建子类Weapon继承Item 12345678910111213public class Weapon extends Item&#123; int damage; //攻击力 public static void main(String[] args) &#123; Weapon infinityEdge = new Weapon(); infinityEdge.damage = 65; //damage属性在类Weapon中新设计的 infinityEdge.name = &quot;无尽之刃&quot;;//name属性，是从Item中继承来的，就不需要重复设计了 infinityEdge.price = 3600; &#125; &#125; 方法重载 方法的重载指的是方法名一样，但是参数类型或数量不一样 123456789101112131415161718192021222324252627282930public class ADHero extends Hero &#123; //无参数 public void attack() &#123; System.out.println(name + &quot; 进行了一次攻击 ，但是不确定打中谁了&quot;); &#125; //1个参数 public void attack(Hero h1) &#123; System.out.println(name + &quot;对&quot; + h1.name + &quot;进行了一次攻击 &quot;); &#125; //2个参数 public void attack(Hero h1, Hero h2) &#123; System.out.println(name + &quot;同时对&quot; + h1.name + &quot;和&quot; + h2.name + &quot;进行了攻击 &quot;); &#125; public static void main(String[] args) &#123; ADHero bh = new ADHero(); bh.name = &quot;赏金猎人&quot;; Hero h1 = new Hero(); h1.name = &quot;盖伦&quot;; Hero h2 = new Hero(); h2.name = &quot;提莫&quot;; bh.attack(h1); bh.attack(h1, h2); &#125; &#125; 可变数量的参数 采用可变数量的参数 只需要设计一个方法： public void attack(Hero... heros) 即可代表上述所有的方法了，此时 heros被当作一个数组，在方法里，使用操作数组的方式处理参数heros即可 1234567891011121314151617181920212223242526272829public class ADHero extends Hero &#123; public void attack() &#123; System.out.println(name + &quot; 进行了一次攻击 ，但是不确定打中谁了&quot;); &#125; // 可变数量的参数 public void attack(Hero... heros) &#123; for (int i = 0; i &lt; heros.length; i++) &#123; System.out.println(name + &quot; 攻击了 &quot; + heros[i].name); &#125; &#125; public static void main(String[] args) &#123; ADHero bh = new ADHero(); bh.name = &quot;赏金猎人&quot;; Hero h1 = new Hero(); h1.name = &quot;盖伦&quot;; Hero h2 = new Hero(); h2.name = &quot;提莫&quot;; bh.attack(h1); bh.attack(h1, h2); &#125; &#125; 构造方法 构造方法是一个特殊的方法，其方法名与类名一样，没有返回类型，在实例化一个对象时，必然调用构造方法 123456789101112131415161718192021222324public class Hero &#123; String name; float hp; float armor; int moveSpeed; // 方法名和类名一样（包括大小写） // 没有返回类型 public Hero() &#123; System.out.println(&quot;实例化一个对象的时候，必然调用构造方法&quot;); &#125; public static void main(String[] args) &#123; //实例化一个对象的时候，必然调用构造方法 Hero h = new Hero(); &#125; &#125;//输出：实例化一个对象的时候，必然调用构造方法 构造方法也可以重载，即可以有几个构造方法，但它们的参数数量或类型不同 this this 代表当前对象，因此把this看成一个对象就行，对象的属性、方法、构造方法它都有 1234567891011121314151617181920212223242526272829303132333435363738public class Hero &#123; String name; //姓名 float hp; //血量 float armor; //护甲 int moveSpeed; //移动速度 //打印内存中的虚拟地址 public void showAddressInMemory()&#123; System.out.println(&quot;打印this看到的虚拟地址：&quot;+this); &#125; public static void main(String[] args) &#123; //--------------------------------------------- Hero garen = new Hero(); garen.name = &quot;aaa&quot;; System.out.println(&quot;打印对象看到的虚拟地址：&quot;+garen); garen.showAddressInMemory(); //------------------------------------------- Hero teemo = new Hero(); teemo.name = &quot;bbb&quot;; System.out.println(&quot;打印对象看到的虚拟地址：&quot;+teemo); teemo.showAddressInMemory(); &#125; &#125;//输出：/*打印对象看到的虚拟地址：Hero@2a139a55打印this看到的虚拟地址：Hero@2a139a55打印对象看到的虚拟地址：Hero@15db9742打印this看到的虚拟地址：Hero@15db9742*/ 通过this 可以访问对象的属性、方法 通过this()可以调用其他的构造方法 1234567891011121314151617181920212223242526272829303132333435363738public class Hero &#123; String name; // 姓名 float hp; // 血量 float armor; // 护甲 int moveSpeed; // 移动速度 // 带一个参数的构造方法 public Hero(String name) &#123; System.out.println(&quot;一个参数的构造方法&quot;); this.name = name; &#125; // 带两个参数的构造方法 public Hero(String name, float hp) &#123; this(name); System.out.println(&quot;两个参数的构造方法&quot;); this.hp = hp; &#125; public static void main(String[] args) &#123; Hero teemo = new Hero(&quot;aaaa&quot;, 383); //两个参数 System.out.println(teemo.name); &#125;&#125;/*输出：一个参数的构造方法两个参数的构造方法aaaa*/ 传参 基本类型传参与引用类型传参 基本类型传参，不多说 引用类型传参，即传入参数为引用类型 =的含义 如果变量是基本类型，则 =表示赋值 如果变量是引用类型，= 表示指向的意思，比如 1Hero h = new Hero(); //引用h，指向一个Hero对象 引用类型传参 形参与实参都指向同一对象 1234567891011121314151617181920212223242526272829public class Hero &#123; String name; float hp; public Hero(String name, float hp) &#123; this.name = name; this.hp = hp; &#125; public void attack(Hero hero) &#123; System.out.println(&quot;hero:&quot;+hero); &#125; public static void main(String[] args) &#123; Hero teemo = new Hero(&quot;teemo&quot;, 383); Hero garen = new Hero(&quot;garen&quot;, 616); garen.attack(teemo); System.out.println(&quot;teemo:&quot;+teemo); &#125;&#125;/**输出：hero:Hero@2a139a55teemo:Hero@2a139a55*/ 用图表示如下 但如果形参在内部指向了新的对象，实参是不会跟着改变的 123456789101112131415161718192021222324252627282930public class Hero &#123; String name; // 姓名 float hp; // 血量 public Hero(String name, float hp) &#123; this.name = name; this.hp = hp; &#125; public void attack(Hero hero) &#123; hero = new Hero(&quot;hero&quot;, 100); //形参指向了新的对象 System.out.println(&quot;hero:&quot;+hero); &#125; public static void main(String[] args) &#123; Hero teemo = new Hero(&quot;teemo&quot;, 383); Hero garen = new Hero(&quot;garen&quot;, 616); garen.attack(teemo); System.out.println(&quot;teemo:&quot;+teemo); &#125;&#125;/**输出：hero:Hero@2a139a55teemo:Hero@15db9742*/ 用图表示如下 类属性(又叫静态属性) 当一个属性被static修饰的时候，就叫做类属性，又叫做静态属性 当一个属性被声明成类属性，那么所有的对象，都共享一个值 对象属性： 又叫实例属性，非静态属性 与对象属性对比： 不同对象的 对象属性 的值都可能不一样。 访问类属性： 1类.类属性 12//访问对象属性：对象.对象属性 类属性与对象属性的选择 如果一个属性，每个英雄都不一样，比如name，这样的属性就应该设计为对象属性，因为它是跟着对象走的，每个对象的name都是不同的 如果一个属性，所有的英雄都共享，都是一样的，那么就应该设计为类属性。比如血量上限，所有的英雄的血量上限都是 9999，不会因为英雄不同，而取不同的值。 这样的属性，就适合设计为类属性 类方法(静态方法) 类方法： 又叫做静态方法，即被static修饰的方法 对象方法： 又叫实例方法，非静态方法 区别： 调用一个对象方法，必须建立在有一个对象的前提的基础上 调用类方法，不需要对象的存在，直接就访问 调用类方法 1类.类方法 12//访问对象方法对象.对象方法 什么时候用类方法 如果一个方法，没有调用任何对象属性，那么就可以考虑设计为类方法，比如： 123public static void printGameDuration()&#123; System.out.println(&quot;已经玩了50秒&quot;); &#125; 反之，如果方法里访问了对象属性，那么这个方法，就必须设计为对象方法； 注意：类方法中不能直接调用对象方法"},{"title":"","date":"2024-03-31T14:49:40.671Z","updated":"2024-03-31T14:49:40.671Z","comments":true,"path":"notes/javase/javase_10/index.html","permalink":"https://blog.ajream.top/notes/javase/javase_10/","excerpt":"","text":"循环语句 while与 do while 语句 含义 while 条件为true时 重复执行 do while 条件为true时 重复执行，至少会执行一次 用法： 123456789//while:while()&#123; &#125;-------------------------//do whiledo&#123; &#125;while(); for语句与增强型for语句 for语句 用法(类似c/c++语言)： 123for(语句1;语句2;语句3)&#123; 语句4;&#125; 增强型for语句 Java5引入了一种主要用于数组的增强型for循环，用法如下： 12345678for(局部变量:表达式)&#123;&#125;/* 局部变量：该变量的类型必须和数组元素的类型匹配。 * 其作用域限定在循环语句块，其值与此时数组元素的值相等。*/// 表达式：表达式是要访问的数组名，或者是返回值为数组的方法。 声明语句：声明新的局部变量，该变量的类型必须和数组元素的类型匹配。其作用域限定在循环语句块，其值与此时数组元素的值相等。 表达式：表达式是要访问的数组名，或者是返回值为数组的方法。 contiue语句 满足条件时跳过本次循环，进入下一次循环 break语句 满足条件时终止距离最近的一层循环； 使用标签结束外部循环 注意标签放的位置：需要终止的循环外部 1234567891011121314151617public class HelloWorld &#123; public static void main(String[] args) &#123; //打印单数 outloop: //outloop这个标签可以自定义，比如a,b,c,outloop1...,放在需要终止的循环外部 for (int i = 0; i &lt; 10; i++) &#123; for (int j = 0; j &lt; 10; j++) &#123; System.out.println(i+&quot;:&quot;+j); if(0==j%2) break outloop; //如果是双数，结束外部循环 &#125; &#125; &#125;&#125;"},{"title":"","date":"2024-03-31T14:49:40.671Z","updated":"2024-03-31T14:49:40.671Z","comments":true,"path":"notes/javase/javase_11/index.html","permalink":"https://blog.ajream.top/notes/javase/javase_11/","excerpt":"","text":"包package 通常会把比较接近的类，规划在同一个包下； 在最开始的地方声明该类所处于的包名； 12345678package charactor; //在最开始的地方声明该类所处于的包名public class Hero &#123; String name; //姓名 float hp; //血量 int moveSpeed; //移动速度 &#125; 使用同一个包下的其他类，直接使用即可 使用其他包下的类，必须import 123456789package charactor; //Weapon类在其他包里，使用必须进行importimport property.Weapon; public class Hero &#123; &#125;"},{"title":"","date":"2024-03-31T14:49:40.671Z","updated":"2024-03-31T14:49:40.671Z","comments":true,"path":"notes/javase/javase_12/index.html","permalink":"https://blog.ajream.top/notes/javase/javase_12/","excerpt":"","text":"10 装箱与拆箱 10.1封装类 所有的基本类型，都有对应的类类型 比如int对应的类是Integer 这种类就叫做封装类 1234567int i = 5; //把一个基本类型的变量,转换为Integer对象Integer it = new Integer(i);//把一个Integer对象，转换为一个基本类型的intint i2 = it.intValue(); 10.2 Number类 数字封装类有 Byte Short Integer Long Float Double 这些类都是抽象类Number的子类 10.3 基本类型⇿封装类型 基本类型转换成封装类型 1234int i = 5; Integer it = new Integer(i); //i转换成封装类型it 封装类型转换成基本类型 12345int i = 5;Integer it = new Integer(i); //i转换成封装类型itint i2 = it.intValue(); //封装类型转it换成基本类型i2，i2与i是一样的 10.4 自动装箱与拆箱 自动装箱：通过=符号自动把 基本类型 —&gt; 类类型 12int i = 5;Integer it = i; //自动装箱 自动拆箱：与自动装箱相反，通过=符号自动把 类类型 —&gt; 基本类型 1234int i = 5;Integer it = i; //自动装箱int i1 = it; //自动拆箱 10.5 int的最大值/最小值 int的最大值可以通过其对应的封装类Integer.MAX_VALUE获取； 同理，最小值通过 Integer.MIN_VALUE 获取；"},{"title":"","date":"2024-03-31T14:49:40.671Z","updated":"2024-03-31T14:49:40.671Z","comments":true,"path":"notes/javase/javase_13/index.html","permalink":"https://blog.ajream.top/notes/javase/javase_13/","excerpt":"","text":"11 数字⇿字符串 11.1 数字转字符串（2种方法） 使用String类的静态方法valueOf 先把基本类型装箱为对象，然后调用对象的toString 12345678int i = 5; //方法1String str = String.valueOf(i); //方法2Integer it = i;String str2 = it.toString(); 11.2 字符串转数字 调用Integer的静态方法parseInt 123String str = &quot;999&quot;; int i= Integer.parseInt(str);"},{"title":"","date":"2024-03-31T14:49:40.671Z","updated":"2024-03-31T14:49:40.671Z","comments":true,"path":"notes/javase/javase_14/index.html","permalink":"https://blog.ajream.top/notes/javase/javase_14/","excerpt":"","text":"12 java字符串 Java用String 和 StringBuffer类来处理字符串，在Java中，每个字符串都是一个对象。 String：主要用于内容不可改变的字符串对象，即字符串一旦创建就不能再改变了（只读） StringBuffer：用于串内容可以改变的字符串对象（可读、可写） 12.1字符串初始化 以下用3种方法创建并初始化字符串对象 1234567String s1 = new String( &quot;hello&quot;);String s2 = &quot;hello&quot;;char[] ch = &#123;&#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;&#125;;String s3 = new String(ch); 12.2 字符串连接 字符串连接用 + 号 1234String str1 = &quot;abc&quot;;String str2 = &quot;123&quot;;String str3 = str1 + str2; //字符串连接 12.3 字符串比较 ==只检查两个串引用是否相同，不比较串值； 注意： 一般说来，编译器每碰到一个字符串的字面值，就会创建一个新的对象 所以在如下代码中： 第6行会创建了一个新的字符串&quot;the light&quot;， 但是在第7行，编译器发现已经存在现成的&quot;the light&quot;，那么就直接拿来使用，而没有进行重复创建 1234567891011package character; public class TestString &#123; public static void main(String[] args) &#123; String str1 = &quot;the light&quot;; String str3 = &quot;the light&quot;; System.out.println( str1 == str3); //true &#125; &#125; equals()或equalsIgnoreCase()方法：比较串值是否相同 equalsIgnoreCase()表示忽略大小写的影响 compareTo()方法：串大小比较(字典序) 1234567string str1 = &quot;abc&quot;; string str2 = &quot;a&quot;;str2 += &quot;bc&quot;; if(str1 == str2)&#123; &#125;; //falseif(str1.equals(str2))&#123; &#125;; //true 12.4 字符串拆分 split(regex)方法根据匹配确定的分隔符 regex 将串分解成子串，所有子串存储在字符串数组（每个成员是一个子串）中； 1234567891011121314151617181920212223public class HelloWorld &#123; public static void main(String[] args)&#123; String s = &quot;The-cat-sat-on-the-mat.&quot;; String[] words = s.split(&quot;-&quot;); //从-处开始分割 for(int i=0; i&lt;words.length; i++) &#123; System.out.println(words[i]); &#125; &#125;&#125;/*输出：Thecatsatonthemat.*/ 1234567891011121314151617public class HelloWorld &#123; public static void main(String[] args)&#123; String s = &quot;12+34+567&quot;; String[] ss = s.split(&quot;[+]&quot;); //注意中括号[]不能省略 int sum = 0; for(int i=0;i&lt;ss.length;i++) &#123; sum += Integer.parseInt(ss[i]); &#125; System.out.println(sum); &#125;&#125;//输出：613 12.5操作字符串常用函数 12345678910111213141516171819202122232425int length(); //返回字符串长度char charAt(int index); //返回指定下标的字符boolean equals(String s); //判断当前字符串和s串相等int indexOf(String str); //返回str在串中首次出现位置String concat(String str); //把str连接在当前串之后。String substring(int begin ,int end); //截取子串[begin,end-1]String toLowerCase(); //将串转换成小写并返回String toUpperCase(); //将串转换成大写并返回String trim(); //将串开始和结尾的空串去掉。char[] toCharArray(); //返回对应的字符数组String replace(char old, char new); //新字符替代旧字符String replaceAll(String old, String new) // 用 `new`串替代字符串中【所有的】 `old`串String replaceFirst(String old, String new) //只替代【第一个】出现的 12.6 StringBuffer类 StringBuffer类创建的串其内容是可以修改的，其占用的空间能自动增长： 1String s = &quot;a&quot; + 4 + &quot;b123&quot; + false; //低效率 为提高效率被编译成下列等价代码： 12StringBuffer s = new StringBuffer(); s.append(&quot;a&quot;).append(4).append(&quot;b123&quot;).append(false).toString();"},{"title":"","date":"2024-03-31T14:49:40.671Z","updated":"2024-03-31T14:49:40.671Z","comments":true,"path":"notes/javase/javase_15/index.html","permalink":"https://blog.ajream.top/notes/javase/javase_15/","excerpt":"","text":"13 日期 在Java中使用日期，需导入 java.util.Date 类 1import java.util.Date; 13.1 创建一个日期对象 Date date = new Date(); 1234Date now = new Date(); //不加参数表示当前时间//加了参数n表示从1970-01-01 8:00:00开始经历了n毫秒 日期对象转字符串对象： 1String s = now.toString() 13.2 getTime()方法 getTime()是Date()对象的一个方法，返回类型 long，用于获取从1970-01-01 8:00:00开始到现在经历的毫秒数 另外，Date().getTime() 和 System.currentTimeMillis() 是一样的 1234567891011121314151617181920212223242526package date; //import java.util.Date; public class TestDate &#123; public static void main(String[] args) &#123; Date now= new Date(); //当前日期的毫秒数 System.out.println(&quot;Date.getTime() \\t\\t\\t返回值: &quot;+now.getTime()); //通过System.currentTimeMillis()获取当前日期的毫秒数 System.out.println(&quot;System.currentTimeMillis() \\t返回值: &quot;+System.currentTimeMillis()); &#125;&#125;/*输出：Date.getTime() 返回值: 1611591854927System.currentTimeMillis() 返回值: 1611591854927*/ 13.3 格式化日期并转为字符串 格式化日期： 需要用到 SimpleDateFormat 类 1import java.text.SimpleDateFormat; 指定格式 1234567891011121314SimpleDateFormat sdf =new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss SSS&quot; ); //y 代表年 //M 代表月 //d 代表日 //H 代表24进制的小时 //h 代表12进制的小时 //m 代表分钟 //s 代表秒 //S 代表毫秒// 以上7种可以只选其中一种或多种，根据自己需要来，如：SimpleDateFormat sdf1 = new SimpleDateFormat(&quot;yyyy-MM-dd&quot; );SimpleDateFormat sdf2 = new SimpleDateFormat(&quot;MM/dd&quot; ); 利用sdf对象的 format方法对日期 Date()进行格式化，并返回格式化后的字符串 12Date d = new Date();String str = sdf.format(d); //这样日期就按格式转为了字符串 13.4 字符串转日期 三个步骤 ： 指定字符串格式： 123SimpleDateFormat sdf =new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot; );//SimpleDateFormat sdf1 =new SimpleDateFormat(&quot;yyyy/MM/dd&quot; ); 创建字符串，注意格式要与 sdf 一致 123String str = &quot;2019-1-15 16:02:27&quot;;//String str1 = &quot;2019-1-15&quot;; 创建日期对象，用 sdf的 parse(str)方法来把字符串转为日期对象 1Date d = sdf.parse(str); 13.5 日历 Calendar 使用前需要导入： 1import java.util.Calendar; 获取日历对象 Calendar.getInstance(); 1Calendar cl = Calendar.getInstance(); 通过日历对象得到日期对象： getTime() 1Date d = cl.getTime(); 日期设置：把 cl 这个日历，调成日期（时间原点） —— 1970.1.1 08:00:00，用 setTime() 12Date d2 = new Date(0);cl.setTime(d2); 13.6 翻日历 add方法，在原日期上增加(add) 年/月/日 set方法，直接设置(set) 年/月/日 创建日历对象 1Calendar c = Calendar.getInstance(); 获取当前日期 1Date now = c.getTime(); 把日历改成下个月的今天 1234c.setTime(now); //表示把日历改为当前时间c.add(Calendar.MONTH, 1); //在当前时间now的基础上修改日历，这里修改了月份，下个月 = 本月 + 1 把日历改成去年的今天 12c.setTime(now);c.add(Calendar.YEAR, -1); //负数表示以前的，去年 = 今年 - 1 把日历直接设置成上个月的第三天 123456c.setTime(now);c.add(Calendar.MONTH, -1); //先改月份c.set(Calendar.DATE, 3); //再改日数，注意用set//如果是今天后的第三天，则用://c.add(Calendar.DATE, 3)"},{"title":"","date":"2024-03-31T14:49:40.671Z","updated":"2024-03-31T14:49:40.671Z","comments":true,"path":"notes/javase/javase_16/index.html","permalink":"https://blog.ajream.top/notes/javase/javase_16/","excerpt":"","text":"14.接口与继承 14.1 接口 14.1.1 接口 接口的创建：(与创建类相似) 1234567//创建一个播放器接口public interface Player&#123; public void play(); public void pause(); public void stop(); public void tune(); //接口只有方法声明，没有主体&#125; Java接口是一系列方法的声明(没有主体)，是一些方法特征的集合; 一个接口只有方法的特征没有方法的实现（不能使用 new来创建实例），因此这些方法可以在不同的地方被不同的类实现（继承），进而在不同的类中实现不同的功能。 接口就是一组抽象方法和常量值的集合。可以把接口看成是一种特殊的抽象类。 (1)其所有的方法都必须是抽象的(abstract)。 (2)其属性成员（若有）只能是final static的常量。 14.1.2 实现接口 实现一个接口与类的继承相似，用 implements 来实现 123456789101112131415161718// 创建一个MP3类，实现播放器功能public MP3 implements Player&#123; public void play()&#123; System.out.println(&quot;播放&quot;); &#125; public void pause()&#123; System.out.println(&quot;暂停&quot;); &#125; public void stop()&#123; System.out.println(&quot;停止&quot;); &#125; public void tune()&#123; System.out.println(&quot;调节音量&quot;); &#125;&#125; 14.2 对象转型 14.2.1 明确引用类型与对象类型的概念 引用和对象都是有类型的 1Hero h = new Hero(); 在这个例子，引用是 h，对象是 new Hero()，它们的类型均为 Hero 通常情况引用类型与对象类型是一样的，但也有不一样的时候 14.2.2 子类转父类（向上转型） 所谓的转型，是指当引用类型和对象类型不一致的时候，才需要进行类型转换； 类型转换有时候会成功，有时候会失败 假如 ADHero 是 Hero 的子类 123Hero h = new Hero();ADHero ad = new ADHero(); 用图来表示其关系如下： 1h = ad; //向上转型 转型后的图： 可以看到 h 经过 ad 最终指向的还是 Hero 因此，把 h 指向 ADHero 一定可以，因为 ADHero 继承了 Hero，Hero能实现的功能 ADHero 也可以 14.2.3 父类转子类(向下转型) 父类转子类，有的时候行，有的时候不行，所以必须进行强制转换。 强制转换的意思就是：转换有风险，风险自担。 假如 ADHero 和 Support 是 Hero 的两个不同子类： 123Hero h =new Hero();ADHero ad = new ADHero();Support s = new Support(); 1h = s; // 向上转型，一定可以 向上转型一定可以，因为 h通过 s 最终还是指向 Hero 1ad = (ADHero)h; //向下转型，不一定可以，需要强制转换 虽然 ad 指向的 ADHero 是 Hero 的子类，眨眼看来 ad 最终也是指向 Hero 的，但实际上指向的是 ADHero，ADHero与Hero还是有区别的，ADHero有的方法Hero不一定有 而ad通过h最终指向的是 Hero，而不是 ADHero，因此会有风险（指向ADHero才不会有风险），只能强制转换。 因为子类拥有的方法父类不一定有，因此 h 向下转型后，ad可能就没有了一些子类的方法 14.2.4 没有继承关系的两个类 没有继承关系的两个类，互相转换，一定会失败 14.2.5实现类转换成接口(向上转型) 假如 AD 是一个接口，ADHero 类继承了它 1234567public class Test &#123; public static void main(String[] args) &#123; ADHero ad = new ADHero(); AD adi = ad; //向上转型 &#125; &#125; 14.2.6 转型练习 如下转换能否成功？如果不能，是哪一行会出错？为什么会出错？ 1234567891011public class Hero &#123; public String name; protected float hp; public static void main(String[] args) &#123; ADHero ad = new ADHero(); Hero h = ad; AD adi = (AD) h; APHero ap = (APHero) adi; &#125;&#125; 分析 第7行向上转型没问题 第8行，可以将h强制转换为AD，因为 AD 与 Hero 之间通过子类关联在了一起；因此 h 指向了AD，而通过 h -&gt; ad -&gt; ADHero -&gt; AD，最终也是指向AD，虽有风险，但不会报错； 第9行，不能将 adi 强制转换为 APHero，因为 AD 与 APHero之间没有关联，因此ap本应该指向 APHero，但通过转换 ap -&gt; adi -&gt; AD,即最终指向了AD，因此不能进行转换，会报错 14.2.7 instanceof 语句 instanceof Hero 判断一个引用所指向的对象，是否是以下两种，返回 true 或 false Hero类型 Hero的子类 1234567891011121314151617181920212223package charactor; public class Hero &#123; public String name; protected float hp; public static void main(String[] args) &#123; ADHero ad = new ADHero(); APHero ap = new APHero(); Hero h1= ad; Hero h2= ap; //判断引用h1指向的对象，是否是ADHero类型 System.out.println(h1 instanceof ADHero); //true //判断引用h2指向的对象，是否是APHero类型 System.out.println(h2 instanceof APHero); //true //判断引用h1指向的对象，是否是Hero的子类型 System.out.println(h1 instanceof Hero); //true &#125;&#125; 14.3 重写 子类可以继承父类的对象方法 在继承后，重复提供该方法，就叫做方法的重写 又叫覆盖 override 父类Item有一个方法，叫做effect 1234567891011121314package property; public class Item &#123; String name; int price; public void buy()&#123; System.out.println(&quot;购买&quot;); &#125; public void effect() &#123; System.out.println(&quot;物品使用后，可以有效果&quot;); &#125; &#125; 子类LifePotion继承Item,同时也提供了方法effect 123456789package property; public class LifePotion extends Item&#123; public void effect()&#123; //重写effect()方法 System.out.println(&quot;血瓶使用后，可以回血&quot;); &#125;&#125; 调用重写的方法 调用就会执行重写的方法，而不是从父类的方法 重写的优点： 如果没有重写这样的机制，也就是说LifePotion这个类，一旦继承了Item，所有方法都不能修改了。 但是LifePotion又希望提供一点不同的功能，为了达到这个目的，只能放弃继承Item,重新编写所有的属性和方法，然后在编写effect的时候，做一点小改动. 这样就增加了开发时间和维护成本 14.4 多态 14.4.1操作符的多态 同一个操作符在不同情境下，具备不同的作用： 如果+号两侧都是整型，那么+代表 数字相加 如果+号两侧，任意一个是字符串，那么+代表字符串连接 14.4.2 类的多态 多态: 都是同一个类型，调用同一个方法，却能呈现不同的状态（实际是子类重写了父类的方法，导致子类的方法与父类的方法不同，子类之间的方法也不同） 类的多态即父类引用指向不同的子类对象，调用同一个方法时出现不同的效果 假设 Hero是 ADHero 与 APHero 的父类 12Hero h1 = new ADHero();Hero h2 = new APHero(); 类的多态的条件： 父类（接口）引用指向子类对象 调用的方法有[重写](#14.3 重写) 14.4.3 使用类多态的好处 如果不使用多态，例如： 假设英雄要使用血瓶和魔瓶，就需要为Hero设计两个方法 useLifePotion、useMagicPotion； 除了血瓶和魔瓶还有很多种物品，那么就需要设计很多很多个方法，比如 usePurityPotion、useGuard、useInvisiblePotion等等等等 123456789101112131415161718192021222324252627282930package charactor; import property.LifePotion;import property.MagicPotion; public class Hero &#123; public String name; protected float hp; public void useLifePotion(LifePotion lp)&#123; lp.effect(); &#125; public void useMagicPotion(MagicPotion mp)&#123; mp.effect(); &#125; public static void main(String[] args) &#123; Hero garen = new Hero(); garen.name = &quot;盖伦&quot;; LifePotion lp =new LifePotion(); MagicPotion mp =new MagicPotion(); garen.useLifePotion(lp); garen.useMagicPotion(mp); &#125; &#125; 这个时候采用多态来解决这个问题： 设计一个方法叫做useItem，其参数类型是Item 如果是使用血瓶，调用该方法 如果是使用魔瓶，还是调用该方法 无论英雄要使用什么样的物品，只需要一个方法 即可 12345678910111213141516171819202122232425262728package charactor; import property.Item;import property.LifePotion;import property.MagicPotion; public class Hero &#123; public String name; protected float hp; public void useItem(Item i)&#123; //设计一个方法叫做useItem，其参数类型是Item i.effect(); &#125; public static void main(String[] args) &#123; Hero garen = new Hero(); garen.name = &quot;盖伦&quot;; LifePotion lp =new LifePotion(); MagicPotion mp =new MagicPotion(); garen.useItem(lp); //使用血瓶lp garen.useItem(mp); //使用魔瓶mp &#125; &#125; 14.5 隐藏 与重写类似： 重写，是子类覆盖父类的对象方法； 隐藏，就是子类覆盖父类的类方法 如何隐藏呢： 父类有一个类方法 ：battleWin 1234567891011package charactor;public class Hero &#123; public String name; protected float hp; public static void battleWin()&#123; //类方法，静态方法 System.out.println(&quot;hero battle win&quot;); &#125; &#125; 创建一个子类，隐藏父类方法 battleWin() 123456789101112131415package charactor; public class ADHero extends Hero implements AD&#123; //隐藏父类的battleWin方法 public static void battleWin()&#123; System.out.println(&quot;ad hero battle win&quot;); &#125; public static void main(String[] args) &#123; Hero.battleWin(); // 调用父类的方法 ADHero.battleWin();//调用子类的方法 &#125; &#125; 问：对于Hero h =new ADHero(); h是父类类型的引用，但是指向一个子类对象h.battleWin(); 会调用父类的方法？还是子类的方法？ 答：当父类的引用指向一个子类对象时，执行的： 对象方法是子类的对象方法（因为重写） 类方法是父类的类方法（类方法不能被重写） 14.6 super关键字 super()用于子类的构造函数内部； 特点： 实例化一个父类的时候，父类的构造方法会被自动调用（根据实例化方式来选择调用有参或无参的构造方法）； 实例化一个子类的时候，若没有写 super()语句，会默认调用父类无参构造方法。 并且，父类和子类的构造方法都会被调用，且父类的构造方法先被调用 1234567package superKeyWord;//父类：public class Hero&#123; public Hero()&#123; System.out.println(&quot;调用父类的构造方法&quot;); &#125;&#125; 12345678910111213141516171819202122package superKeyWord;//子类public class SuperTest extends Hero &#123; public SuperTest()&#123; System.out.println(&quot;调用子类构造方法&quot;); &#125; public static void main(String[] args)&#123; new Hero(); //创建父类对象 System.out.println(&quot;---------------&quot;); new SuperTest(); //创建子类对象 &#125; &#125;/*输出：调用父类的构造方法---------------调用父类的构造方法调用子类构造方法*/ 14.6.1 super调用父类带参构造方法 super() 相当于一个父类的对象，在子类中使用就类似于创建了一个父类的对象，会调用父类带参的构造方法 super 与 this 类似，this是当前类的对象，super是父类的对象，两者都只能在方法内部使用 12345678910package superKeyWord;//父类：public class Hero&#123; public Hero(String name)&#123; //带参的构造方法 System.out.println(&quot;调用父类的构造方法&quot;+name); &#125;&#125; 123456789101112131415161718192021222324252627package superKeyWord;public class SuperTest extends Hero &#123; // super(&quot;h2&quot;); //super只能在方法内部使用 public SuperTest()&#123; super(&quot;h2&quot;); //正确，super在方法内使用 System.out.println(&quot;调用子类构造方法&quot;); &#125; public static void main(String[] args)&#123; new Hero(&quot;h1&quot;); System.out.println(&quot;---------------&quot;); new SuperTest(); &#125; &#125;/*输出：调用父类的构造方法h1---------------调用父类的构造方法h2调用子类构造方法*/ 14.6.2 super调用父类属性 12345678//父类package superKeyWord;public class Hero&#123; int moveSpeed = 100; &#125; 123456789101112131415161718192021222324//子类package superKeyWord;public class SuperTest extends Hero &#123; int moveSpeed = 200; public void getMoveSpeed1()&#123; System.out.println(super.moveSpeed); //打印父类moveSpeed &#125; public void getMoveSpeed2() &#123; System.out.println(this.moveSpeed); //打印子类moveSpeed &#125; public static void main(String[] args)&#123; SuperTest h = new SuperTest(); h.getMoveSpeed1(); //输出：100 h.getMoveSpeed2(); //输出：200 &#125; &#125; 14.6.3 super调用父类方法 当子类重写了父类的方法后，super调用的依然是父类原本的方法 14.7 Object类 Object类是所有类的父类，即声明一个类的时候，默认就继承了Object 14.7.1 Object提供的一些方法 toString()： 返回当前对象的字符串表达 通过 System.out.println()打印对象就是打印该对象的toString()返回值 123456Hero h = new Hero();//下面两行等效System.out.println(h);System.out.println(h.toString()); finalize(): 当一个对象没有任何引用指向的时候，它就满足垃圾回收的条件 当它被垃圾回收的时候，它的finalize() 方法就会被调用。 finalize() 不是开发人员主动调用的方法，而是由虚拟机JVM调用 1234Hero h;h = new Hero();h = new Hero(); 执行第四行的时候，第三行的 Hero() 对象没了引用指向，就满足垃圾回收条件 equals(): equals() 用于判断两个对象的内容是否相同，假设，当两个英雄的hp相同的时候，我们就认为这两个英雄相同 1234567891011121314151617181920212223242526package charactor; public class Hero &#123; public String name; protected float hp; public boolean equals(Object o)&#123; if(o instanceof Hero)&#123; Hero h = (Hero) o; return this.hp == h.hp; &#125; return false; &#125; public static void main(String[] args) &#123; Hero h1= new Hero(); h1.hp = 300; Hero h2= new Hero(); h2.hp = 400; Hero h3= new Hero(); h3.hp = 300; System.out.println(h1.equals(h2)); System.out.println(h1.equals(h3)); &#125;&#125; == 这不是Object的方法，但是用于判断两个对象是否相同， 更准确的讲，用于判断两个引用，是否指向了同一个对象 hashCode(): 返回对象的哈希值 线程同步方法 123wait()notify()notifyAll() getClass: 会返回一个对象的类对象 14.8 final修饰 final修饰类，方法，基本类型变量，引用的时候分别有不同的意思。 修饰类：表示该类不能被继承 123public final class Hero&#123; //该类不能被继承 &#125; 修饰方法：表示该方法不能被重写 123public final void useItem()&#123; &#125; 修饰基本变量：表示该变量只能被赋值一次 123final int a;a = 1;a = 2; //报错 修饰引用：表示该引用只有一次指向对象的机会 123final Hero h;h = new Hero();h = new Hero(); //报错 可以用 final 修饰变量使其作为常量使用 常量指的是可以公开，直接访问，不会变化的值 14.9 抽象类 抽象类 在类中声明一个方法，这个方法没有实现体，是一个“空”方法 这样的方法就叫抽象方法，使用修饰符abstract 注意： 当一个类有抽象方法的时候，该类必须被声明为抽象类 子类继承抽象类后，必须重写抽象方法（如果有的话），赋予其具体功能 抽象类可以没有抽象方法，可以有实体方法，但是有抽象方法时必须声明为抽象类 抽象类不能直接进行实例化，即不能创建抽象类的对象 123456789101112package charactor; public abstract class Hero &#123; //抽象类 String name; float hp; float armor; int moveSpeed; public abstract void attack();// 抽象方法attack &#125; 抽象类与接口区别 接口的方法默认是 public，所有方法在接口中不能有实现(Java 8 开始接口方法可以有默认实现），而抽象类可以有非抽象的方法。 接口中除了 static、final 变量，不能有其他变量，而抽象类中则不一定。 一个类可以实现多个接口，但只能实现一个抽象类。接口自己本身可以通过 extends 关键字扩展多个接口。 接口方法默认修饰符是 public，抽象方法可以有 public、protected 和 default 这些修饰符（抽象方法就是为了被重写所以不能使用 private 关键字修饰！）。 从设计层面来说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。 抽象类 接口 抽象类也是类，子类只能继承一个类 子类可以实现多个接口 可以是public,protected,package,private 只能是public 静态、非静态 静态 final或非final的属性 final的 另外，抽象类和接口都可以有实体方法。 接口中的实体方法，叫做[默认方法](#14.11 默认方法) 14.10 内部类 内部类分为四种： 非静态内部类 非静态内部类，只有一个外部类对象存在的时候，才有意义。也就是说，要调用非静态内部类的属性和方法，必须要先创建一个外部类 12345678910public class Hero&#123; String name; class BattleScore&#123; //内部类 int score; public void kill()&#123; &#125; &#125;&#125; 调用内部类的途径： 12Hero h = new Hero(); //先创建外部类BattleScore bs = h.new BattleScore(); 静态内部类 在一个类里面声明一个静态内部类，静态内部类的实例化不需要一个外部类的实例为基础，可以直接实例化。 另外，静态内部类不能直接访问外部类的对象属性 语法： 1new 外部类.静态内部类(); 例： 123456789101112public class Hero&#123; String name; static class BattleScore&#123; //静态内部类 int score; public void kill()&#123; //静态内部类不能直接访问外部类的对象属性 System.out.println(name + &quot;kille a Hero&quot;);//报错 &#125; &#125;&#125; 实例化： 1Hero.BattleScore bs = new Hero.BattleScore(); 匿名类 匿名类指的是在创建某个类的对象的同时实例化它，使代码更加简洁精练 通常情况下，要使用一个接口或者抽象类，都必须创建一个子类，为了快速使用，直接实例化一个抽象类，并“当场”实现其抽象方法。 既然实现了抽象方法，那么就是一个新的类，只是这个类，没有命名。这样的类，叫做匿名类 12345678910111213141516171819202122232425package charactor; public abstract class Hero &#123; String name; float hp; float armor; int moveSpeed; public abstract void attack(); //抽象方法 public static void main(String[] args) &#123; Hero h = new Hero()&#123; //当场实现attack方法 public void attack() &#123; System.out.println(&quot;新的进攻手段&quot;); &#125; &#125;; h.attack(); //通过打印h，可以看到h这个对象属于Hero$1这么一个系统自动分配的类名 System.out.println(h); &#125; &#125; 注意：在匿名类中使用外部的局部变量，外部的局部变量必须修饰为final，但在jdk8中，已经不需要强制修饰成final了，因为编译器偷偷的帮你加上了看不见的final 本地类 本地类可以理解为有名字的匿名类 内部类与匿名类不一样的是，内部类必须声明在成员的位置，即与属性和方法平等的位置。 本地类和匿名类一样，直接声明在代码块里面，可以是主方法，for循环里等等地方 1234567891011121314151617181920212223242526package charactor; public abstract class Hero &#123; String name; float hp; float armor; int moveSpeed; public abstract void attack(); public static void main(String[] args) &#123; //在主方法里声明本地类 //与匿名类的区别在于，本地类有了自定义的类名 class SomeHero extends Hero&#123; public void attack() &#123; System.out.println( name+ &quot; 新的进攻手段&quot;); &#125; &#125; SomeHero h =new SomeHero(); h.name =&quot;地卜师&quot;; h.attack(); &#125; &#125; 14.11 默认方法 默认方法是JDK8新特性，指的是接口也可以提供具体方法了，而不像以前，只能提供抽象方法 例如： 12345678public interface Mortal &#123; public void die(); //抽象方法 default public void revive() &#123; //具体方法 System.out.println(&quot;本英雄复活了&quot;); &#125;&#125; 为什么会有默认方法？ 假设没有默认方法这种机制，那么如果要为Mortal增加一个新的方法revive，那么所有实现了Mortal接口的子类，都需要做改动（都要在子类中考虑重写revive的具体方法）。 但是引入了默认方法后，原来的类，不需要做任何改动，并且还能得到这个默认方法 通过这种手段，就能够很好的扩展新的类，并且做到不影响原来的类"},{"title":"","date":"2024-03-31T14:49:40.671Z","updated":"2024-03-31T14:49:40.671Z","comments":true,"path":"notes/javase/javase_17/index.html","permalink":"https://blog.ajream.top/notes/javase/javase_17/","excerpt":"","text":"15 异常处理 异常定义 导致程序的正常流程被中断的事件，叫做异常 异常处理常见手段：try catch finally throws 例如：文件不存在异常 123456789101112131415161718192021package ExceptionProcess;import java.io.File;import java.io.FileInputStream;public class Test &#123; public static void main(String[] args)&#123; File f = new File(&quot;D:/LOL.exe&quot;); new FileInputStream(f); &#125; &#125;/*输出：Exception in thread &quot;main&quot; java.lang.Error: Unresolved compilation problem: Unhandled exception type FileNotFoundException at ExceptionProcess.Test.main(Test.java:10)*/ 异常处理 异常处理常见手段： try catch finally throws try catch 将可能抛出FileNotFoundException 文件不存在异常的代码放在try里 如果文件存在，就会顺序往下执行，并且不执行catch块中的代码 如果文件不存在，try 里的代码会立即终止，程序流程会运行到对应的catch块中 e.printStackTrace(); 会打印出方法的调用痕迹，如此例，会打印出异常开始于TestException的第16行，这样就便于定位和分析到底哪里出了异常 123456789101112131415161718192021222324package exception; import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException; public class TestException &#123; public static void main(String[] args) &#123; File f = new File(&quot;d:/LOL.exe&quot;); try&#123; System.out.println(&quot;试图打开 d:/LOL.exe&quot;); new FileInputStream(f); System.out.println(&quot;成功打开&quot;); &#125; catch(FileNotFoundException e)&#123; System.out.println(&quot;d:/LOL.exe不存在&quot;); e.printStackTrace(); &#125; &#125;&#125; 使用异常的父类进行catch FileNotFoundException是Exception的子类，使用Exception也可以catch住 FileNotFoundException 123456789101112File f= new File(&quot;d:/LOL.exe&quot;);try&#123; System.out.println(&quot;试图打开 d:/LOL.exe&quot;); new FileInputStream(f); System.out.println(&quot;成功打开&quot;);&#125;catch(Exception e)&#123; System.out.println(&quot;d:/LOL.exe不存在&quot;); e.printStackTrace();&#125; 多异常捕捉办法一 有的时候一段代码会抛出多种异常，比如 12new FileInputStream(f);Date d = sdf.parse(&quot;2016-06-03&quot;); 这段代码，会抛出 文件不存在异常 FileNotFoundException 和解析异常ParseException 解决办法之一是分别进行catch 12345678catch (FileNotFoundException e) &#123; System.out.println(&quot;d:/LOL.exe不存在&quot;); e.printStackTrace(); &#125; catch (ParseException e) &#123; System.out.println(&quot;日期格式解析错误&quot;); e.printStackTrace();&#125; 多异常捕捉办法2 另一个种办法是把多个异常，放在一个catch里统一捕捉 123catch (FileNotFoundException | ParseException e) &#123; &#125; 这种方式从 JDK7开始支持，好处是捕捉的代码更紧凑，不足之处是，一旦发生异常，不能确定到底是哪种异常，需要通过instanceof 进行判断具体的异常类型 1234if (e instanceof FileNotFoundException) System.out.println(&quot;d:/LOL.exe不存在&quot;);if (e instanceof ParseException) System.out.println(&quot;日期格式解析错误&quot;); 例如： 123456789101112131415161718192021222324252627282930313233package exception; import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date; public class TestException &#123; public static void main(String[] args) &#123; File f = new File(&quot;d:/LOL.exe&quot;); try &#123; System.out.println(&quot;试图打开 d:/LOL.exe&quot;); new FileInputStream(f); System.out.println(&quot;成功打开&quot;); SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); Date d = sdf.parse(&quot;2016-06-03&quot;); &#125; catch (FileNotFoundException | ParseException e) &#123; if (e instanceof FileNotFoundException) System.out.println(&quot;d:/LOL.exe不存在&quot;); if (e instanceof ParseException) System.out.println(&quot;日期格式解析错误&quot;); e.printStackTrace(); &#125; &#125;&#125; finally 无论是否出现异常，finally中的代码都会被执行 1234567891011121314151617181920212223242526package exception; import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException; public class TestException &#123; public static void main(String[] args) &#123; File f= new File(&quot;d:/LOL.exe&quot;); try&#123; System.out.println(&quot;试图打开 d:/LOL.exe&quot;); new FileInputStream(f); System.out.println(&quot;成功打开&quot;); &#125; catch(FileNotFoundException e)&#123; System.out.println(&quot;d:/LOL.exe不存在&quot;); e.printStackTrace(); &#125; finally&#123; System.out.println(&quot;无论文件是否存在， 都会执行的代码&quot;); &#125; &#125;&#125; throws 考虑如下情况： 主方法调用method1 method1调用method2 method2中打开文件 method2中需要进行异常处理 但是method2不打算处理，而是把这个异常通过throws抛出去 那么method1就会接到该异常。 处理办法也是两种，要么是try catch处理掉，要么也是抛出去。 method1选择本地try catch住 一旦try catch住了，就相当于把这个异常消化掉了，主方法在调用method1的时候，就不需要进行异常处理了 123456789101112131415161718192021222324252627282930313233package exception; import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException; public class TestException &#123; public static void main(String[] args) &#123; method1(); &#125; private static void method1() &#123; try &#123; method2(); &#125; catch (FileNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; private static void method2() throws FileNotFoundException &#123; File f = new File(&quot;d:/LOL.exe&quot;); System.out.println(&quot;试图打开 d:/LOL.exe&quot;); new FileInputStream(f); System.out.println(&quot;成功打开&quot;); &#125;&#125; throws与throw区别 throws与throw这两个关键字接近，不过意义不一样，有如下区别： throws 出现在方法声明上，而throw通常都出现在方法体内。 throws 表示出现异常的一种可能性，并不一定会发生这些异常； throw则是抛出了异常，执行throw则一定抛出了某个异常对象 异常分类 可查异常(CheckedException) 非可查异常 运行时异常(RunTimeException) 错误(Error) 可查异常 可查异常即必须进行处理的异常，要么try catch住,要么往外抛，谁调用，谁处理，比如 FileNotFoundException 如果不处理，编译器，就不让你通过 运行时异常 运行时异常RuntimeException指： 不是必须进行try catch的异常 常见运行时异常: 除数不能为0异常:ArithmeticException 下标越界异常:ArrayIndexOutOfBoundsException 空指针异常:NullPointerException 在编写代码的时候，依然可以使用try catch throws进行处理，与可查异常不同之处在于，即便不进行try catch，也不会有编译错误。 Java之所以会设计运行时异常的原因之一，是因为下标越界，空指针这些运行时异常太过于普遍，如果都需要进行捕捉，代码的可读性就会变得很糟糕。 123456789101112131415161718package exception; public class TestException &#123; public static void main(String[] args) &#123; //任何除数不能为0:ArithmeticException int k = 5/0; //下标越界异常：ArrayIndexOutOfBoundsException int j[] = new int[5]; j[10] = 10; //空指针异常：NullPointerException String str = null; str.length(); &#125;&#125; 错误Error 指的是系统级别的异常，通常是内存用光了 在默认设置下，一般java程序启动的时候，最大可以使用16m的内存 如例不停的给StringBuffer追加字符，很快就把内存使用光了。抛出OutOfMemoryError，与运行时异常一样，错误也是不要求强制捕捉的 123456789101112131415package exception; public class TestException &#123; public static void main(String[] args) &#123; StringBuffer sb =new StringBuffer(); for (int i = 0; i &lt; Integer.MAX_VALUE; i++) &#123; sb.append(&#x27;a&#x27;); &#125; &#125; &#125; Throwable Throwable Throwable是类，Exception和Error都继承了该类 所以在捕捉的时候，也可以使用Throwable进行捕捉 如图： 异常分Error和Exception Exception里又分运行时异常和可查异常 123456789101112131415161718192021package exception; import java.io.File;import java.io.FileInputStream; public class TestException &#123; public static void main(String[] args) &#123; File f = new File(&quot;d:/LOL.exe&quot;); try &#123; new FileInputStream(f); //使用Throwable进行异常捕捉 &#125; catch (Throwable t) &#123; // TODO Auto-generated catch block t.printStackTrace(); &#125; &#125;&#125; 自定义异常 创建自定义异常 一个英雄攻击另一个英雄的时候，如果发现另一个英雄已经挂了，就会抛出EnemyHeroIsDeadException 创建一个类EnemyHeroIsDeadException，并继承Exception 提供两个构造方法 无参的构造方法 带参的构造方法，并调用父类的对应的构造方法 123456789class EnemyHeroIsDeadException extends Exception&#123; public EnemyHeroIsDeadException()&#123; &#125; public EnemyHeroIsDeadException(String msg)&#123; super(msg); &#125;&#125; 抛出自定义异常 在Hero的attack方法中，当发现敌方英雄的血量为0的时候，抛出该异常 创建一个EnemyHeroIsDeadException实例 通过throw 抛出该异常 当前方法通过 throws 抛出该异常 在外部调用attack方法的时候，就需要进行捕捉，并且捕捉的时候，可以通过e.getMessage() 获取当时出错的具体原因 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package charactor; public class Hero &#123; public String name; protected float hp; public void attackHero(Hero h) throws EnemyHeroIsDeadException&#123; if(h.hp == 0)&#123; throw new EnemyHeroIsDeadException(h.name + &quot; 已经挂了,不需要施放技能&quot; ); &#125; &#125; public String toString()&#123; return name; &#125; class EnemyHeroIsDeadException extends Exception&#123; public EnemyHeroIsDeadException()&#123; &#125; public EnemyHeroIsDeadException(String msg)&#123; super(msg); &#125; &#125; public static void main(String[] args) &#123; Hero garen = new Hero(); garen.name = &quot;盖伦&quot;; garen.hp = 616; Hero teemo = new Hero(); teemo.name = &quot;提莫&quot;; teemo.hp = 0; try &#123; garen.attackHero(teemo); &#125; catch (EnemyHeroIsDeadException e) &#123; // TODO Auto-generated catch block System.out.println(&quot;异常的具体原因:&quot;+e.getMessage()); e.printStackTrace(); &#125; &#125;&#125; 输出："},{"title":"","date":"2024-03-31T14:49:40.671Z","updated":"2024-03-31T14:49:40.671Z","comments":true,"path":"notes/javase/javase_18/index.html","permalink":"https://blog.ajream.top/notes/javase/javase_18/","excerpt":"","text":"文件IO系列 文件和文件夹都是用File代表 文件对象 创建一个文件对象 注意：不是创建文件 首先导入 File类 1import java.io.File; 使用绝对路径或者相对路径创建File对象 12345// 绝对路径File f1 = new File(&quot;d:/LOLFolder&quot;); //这是一个文件夹// 相对路径, 相对于工作目录（项目目录）File f2 = new File(&quot;LOL.exe&quot;); //这是一个文件 12// 把f1作为父目录创建文件对象File f3 = new File(f1, &quot;LOL.exe&quot;); 文件常用方法 1File f = new File(&quot;d:/LOLFolder/skin/garen.ski&quot;); 获取文件相关信息： 1234567891011121314f.exists(); //判断文件是否存在f.isDirectory(); //判断是否是文件夹f.isFile(); //判断是否是文件f.length(); //文件长度（单位字节bytes）long time = f.lastModified(); //返回从1970-1-1 08：00：00 开始的秒数Date d = new Date(time);f.setLastModified(0); //设置文件修改时间为1970.1.1 08:00:00 文件、文件夹操作 1234567891011121314151617181920212223242526272829303132f.list();// 以【字符串数组】的形式，返回当前文件夹下的所有文件（不包含子文件及子文件夹）File[]fs = f.listFiles();// 以【文件（后缀为Files）数组】的形式，返回当前文件夹下的所有文件（不包含子文件及子文件夹）f.getParent();// 以【字符串】形式返回文件所在文件夹f.getParentFile();// 以【文件】形式返回获取所在文件夹f.mkdir();// 创建文件夹，如果父文件夹skin不存在，创建就无效f.mkdirs();// 创建文件夹，如果父文件夹skin不存在，就会创建父文件夹f.createNewFile();// 创建一个空文件,如果父文件夹skin不存在，就会抛出异常f.getParentFile().mkdirs();// 所以创建一个空文件之前，通常都会创建父目录f.listRoots();// 列出所有的盘符c: d: e: 等等f.delete();// 刪除文件f.deleteOnExit();// JVM结束的时候，刪除文件，常用于临时文件的删除 什么是流 流（Stream）就是一系列的数据 当不同的介质之间有数据交互的时候，JAVA就使用流来实现。 数据源可以是文件，数据库，网络，甚至是其他的程序。 比如读取文件的数据到程序中，站在程序的角度来看，就叫做输入流 （输入输出是针对Java虚拟机JVM而言的，流入JVM叫输入，反之叫输出） 输入流：InputStream 输出流：OutputStream 文件输入流 java中通过 FileInputStream() 实现文件输入流。 如下代码，就建立了一个文件输入流，这个流可以用来把数据从硬盘的文件，读取到JVM(内存)。 目前代码只是建立了流，还没有开始读取，真正的读取在下个章节讲解。 1234567891011121314151617181920212223package stream; import java.io.File;import java.io.FileInputStream;import java.io.IOException; public class TestStream &#123; public static void main(String[] args) &#123; try &#123; File f = new File(&quot;d:/lol.txt&quot;);//创建文件对象 // 创建基于文件的输入流，即将文件对象放入流中 FileInputStream fis = new FileInputStream(f); // 通过这个输入流，就可以把数据从硬盘，读取到Java的虚拟机中来，也就是读取到内存中 &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; 文件输出流 FileOutputStream ：通过这个输出流，就可以吧数据从java的虚拟机中写入硬盘 1234567891011121314151617package stream; import java.io.File;import java.io.FileNotFoundException;import java.io.FileOutputStream; public class TestStream &#123; public static void main(String[] args) &#123; File f =new File(&quot;d:/lol.txt&quot;); try &#123; FileOutputStream fos = new FileOutputStream(f); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 字节流 字节流即：用于以字节的形式读取和写入数据 InputStream：字节输入流 OutputStream：字节输出流 ASCII码概念 所有的数据存放在计算机中都是以数字的形式存放的。 所以字母就需要转换为数字才能够存放。 比如A就对应的数字65，a对应的数字97. 不同的字母和符号对应不同的数字，就是一张码表。 ASCII是这样的一种码表。 只包含简单的英文字母、符号、数字等。 不包含中文，德文，俄语等复杂的。 以字节流形式读取文件内容 InputStream是字节输入流，同时也是抽象类，只提供方法声明，不提供方法的具体实现。 FileInputStream 是InputStream 子类，以 FileInputStream 为例进行文件读取 1234567891011121314151617181920212223242526272829303132333435package IOlearning.stream;import java.io.File;import java.io.FileInputStream;import java.io.IOException;public class StreamTest &#123; public static void main(String[] args) &#123; try &#123; File f = new File(&quot;d:/javaTest.txt&quot;); //文件javaTest.txt内容是abc...xyz // 创建基于文件的输入流 FileInputStream fis = new FileInputStream(f); // 创建字节数组，其长度就是文件的长度 byte[] all = new byte[(int) f.length()]; fis.read(all); // 以字节流的形式读取文件所有内容到 all for (byte b : all) &#123; System.out.print(b + &quot; &quot;);// 打印出来是97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 &#125; // 每次使用完流，都应该进行关闭 fis.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 以字节流的形式向文件写入数据 OutputStream 是字节输出流，同时也是抽象类，只提供方法声明，不提供方法的具体实现。 FileOutputStream 是OutputStream子类，以FileOutputStream 为例向文件写出数据 注: 若文件d:/lol2.txt不存在，写出操作会自动创建该文件。 但是如果是文件 d:/xyz/lol2.txt，而目录xyz又不存在，会抛出异常 123456789101112131415161718192021222324252627282930package stream; import java.io.File;import java.io.FileOutputStream;import java.io.IOException; public class TestStream &#123; public static void main(String[] args) &#123; try &#123; // 准备文件javaTest2.txt, 其中的内容是空的 File f = new File(&quot;d:/javaTest2.txt&quot;); // 准备长度是2的字节数组，用88,89初始化，其对应的字符分别是X,Y byte data[] = &#123; 88, 89 &#125;; // 创建基于文件的输出流 FileOutputStream fos = new FileOutputStream(f); fos.write(data);// 把数据写入到输出流，注意data是个数组 // 关闭输出流 fos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 总结(利用流读取文件步骤) 4个操作步骤： 创建文件对象 将文件放入对应的流（输入、输出流） 操作流（读取、写入） 关闭流（close） 关闭流的方式 在try里关闭 12345678910111213try &#123; File f = new File(&quot;d:/javaTest.txt&quot;); FileInputStream fis = new FileInputStream(f); byte[] all = new byte[(int) f.length()]; fis.read(all); //使用完流，进行关闭 fis.close();&#125; catch (IOException e) &#123; e.printStackTrace();&#125; 在try的作用域里关闭文件输入流，在前面的示例中都是使用这种方式，这样做有一个弊端： 如果文件不存在，或者读取的时候出现问题而抛出异常，那么就不会执行这一行关闭流的代码，存在巨大的资源占用隐患。 不推荐使用 在finally里关闭 这是标准的关闭流的方式 首先把流的引用声明在try的外面，如果声明在try里面，其作用域无法抵达finally. 在finally关闭之前，要先判断该引用是否为空 关闭的时候，需要再一次进行try catch处理 这是标准的严谨的关闭流的方式，但是看上去很繁琐，所以写不重要的或者测试代码的时候，都会采用上面的有隐患的方式，因为不麻烦🤣 下面是标准方式： 12345678910111213141516171819202122232425262728293031323334353637package stream; import java.io.File;import java.io.FileInputStream;import java.io.IOException; public class TestStream &#123; public static void main(String[] args) &#123; File f = new File(&quot;d:/lol.txt&quot;); FileInputStream fis = null; //在try外部声明 try &#123; fis = new FileInputStream(f); byte[] all = new byte[(int) f.length()]; fis.read(all); for (byte b : all) &#123; System.out.println(b); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; // 在finally 里关闭流 if (null != fis) try &#123; fis.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125;&#125; 使用try()的方式 把流定义在try()里,当try、catch或者finally结束的时候，会自动关闭。注意区别在try里关闭 这种编写代码的方式叫做 try-with-resources， 这是从JDK7开始支持的技术。 所有的流，都实现了一个接口叫做 AutoCloseable，任何类实现了这个接口，都可以在try()中进行实例化。 并且在try, catch, finally结束的时候自动关闭，回收相关资源。 12345678910111213141516171819202122232425package stream; import java.io.File;import java.io.FileInputStream;import java.io.IOException; public class TestStream &#123; public static void main(String[] args) &#123; File f = new File(&quot;d:/lol.txt&quot;); //把流定义在try()里,try,catch或者finally结束的时候，会自动关闭 try (FileInputStream fis = new FileInputStream(f)) &#123; byte[] all = new byte[(int) f.length()]; fis.read(all); for (byte b : all) &#123; System.out.println(b); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 字符流 上面所讲的 InputStream 与 OutputStream 是字节流； 这里还有字符流，即专门用于以字符的形式读写数据： Reader Writer 用字符流读取文件 FileReader 是 Reader子类，以FileReader 为例进行文件读取 1234567891011121314151617181920212223242526272829303132package stream; import java.io.File;import java.io.FileReader;import java.io.IOException; public class TestStream &#123; public static void main(String[] args) &#123; // 准备文件lol.txt其中的内容是AB File f = new File(&quot;d:/lol.txt&quot;); // 创建基于文件的Reader try (FileReader fr = new FileReader(f)) &#123; // 创建字符数组，其长度就是文件的长度 char[] all = new char[(int) f.length()]; // 以字符流的形式读取文件所有内容 fr.read(all); for (char b : all) &#123; // 打印出来是A B System.out.println(b); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 用字符流把字符串写入文件 FileWriter 是Writer的子类，以FileWriter 为例把字符串写入到文件 1234567891011121314151617181920212223242526package stream; import java.io.File;import java.io.FileWriter;import java.io.IOException; public class TestStream &#123; public static void main(String[] args) &#123; // 准备文件lol2.txt File f = new File(&quot;d:/lol2.txt&quot;); // 创建基于文件的Writer try (FileWriter fr = new FileWriter(f)) &#123; // 以字符流的形式把数据写入到文件中 String data=&quot;abcdefg1234567890&quot;; char[] cs = data.toCharArray(); fr.write(cs); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; 中文问题 编码概念 ASCII 字符集只有256个字符，用 0-255 之间的数字来表示。包括大小写字母、数字以及少数特殊字符：如标点符号、货币符号等。 对于大多数拉丁语言来说，这些字符已经够用。 但是，许多亚洲和东方语言所用的字符远远不止256个字符。有些超过千个。 因此，为了突破 ASCII 码字符数的限制，试图用新的编码方法来针对超过256个字符的语言编写计算机程序 常见编码 工作后经常接触的编码方式有如下几种： ISO-8859-1/ASCII: 数字和西欧字母 GBK/GB2312/BIG5: 中文 UNICODE: 统一码，万国码 其中 ISO-8859-1 包含 ASCII GB2312 是简体中文，BIG5是繁体中文，GBK同时包含简体和繁体以及日文。 UNICODE 包括了所有的文字，无论中文，英文，藏文，法文，世界所有的文字都包含其中 UNICODE和UTF 虽然UNICODE可以存储所有字符，但如果完全按照UNICODE的方式来存储数据，就会有很大的浪费。因为1个Unicode字符就占用4 bytes 倘若一篇文章大部分都是英文字母，那么按照UNICODE的方式进行数据保存就会消耗很多空间 在这种情况下，就出现了UNICODE的各种减肥子编码, 比如UTF-8对数字和字母就使用一个字节，而对汉字就使用3个字节，从而达到了减肥还能保证健康的效果 UTF-8，UTF-16和UTF-32 针对不同类型的数据有不同的减肥效果，一般说来UTF-8是比较常用的方式 UTF-8，UTF-16和UTF-32 彼此的区别在此不作赘述，有兴趣的可以参考 unicode-百度百科 UTF-8编码方式：数字和字母用一个字节， 汉字用3个字节。 Java采用的是Unicode 写在.java源代码中的汉字，在执行之后，都会变成JVM中的字符。 而这些中文字符采用的编码方式，都是使用UNICODE. 例如： &quot;中&quot;字对应的UNICODE是4E2D,所以在内存中，实际保存的数据就是十六进制的0x4E2D, 也就是十进制的20013。 一个汉字使用不同编码方式的表现 以字符 中 为例，查看其在不同编码方式下的值是多少 1234567891011121314151617181920212223242526272829303132333435package stream; import java.io.UnsupportedEncodingException; public class TestStream &#123; public static void main(String[] args) &#123; String str = &quot;中&quot;; showCode(str); &#125; private static void showCode(String str) &#123; String[] encodes = &#123; &quot;BIG5&quot;, &quot;GBK&quot;, &quot;GB2312&quot;, &quot;UTF-8&quot;, &quot;UTF-16&quot;, &quot;UTF-32&quot; &#125;; for (String encode : encodes) &#123; showCode(str, encode); &#125; &#125; private static void showCode(String str, String encode) &#123; try &#123; System.out.printf(&quot;字符: \\&quot;%s\\&quot; 的在编码方式%s下的十六进制值是%n&quot;, str, encode); byte[] bs = str.getBytes(encode); for (byte b : bs) &#123; int i = b&amp;0xff; System.out.print(Integer.toHexString(i) + &quot;\\t&quot;); &#125; System.out.println(); System.out.println(); &#125; catch (UnsupportedEncodingException e) &#123; System.out.printf(&quot;UnsupportedEncodingException: %s编码方式无法解析字符%s\\n&quot;, encode, str); &#125; &#125;&#125; 用FileInputStream 字节流正确读取中文 为了能够正确的读取中文内容 必须了解文本是以哪种编码方式保存字符的 使用字节流读取文本 使用对应的编码方式去识别这些数字，得到正确的字符。 如本例，一个文件中的内容是字符&quot;中&quot;，编码方式是GBK，那么读出来的数据一定是D6D0。 再使用GBK编码方式识别D6D0，就能正确的得到字符中 注： 在GBK的棋盘上找到的中字后，JVM会自动找到中在UNICODE这个棋盘上对应的数字，并且以UNICODE上的数字保存在内存中。 12345678910111213141516171819202122232425package stream; import java.io.File;import java.io.FileInputStream;import java.io.IOException; public class TestStream &#123; public static void main(String[] args) &#123; File f = new File(&quot;d:\\\\project\\\\j2se\\\\src\\\\test.txt&quot;); //该文件保存时的编码方式为GBK try (FileInputStream fis = new FileInputStream(f);) &#123; byte[] all = new byte[(int) f.length()]; fis.read(all); //使用字节流读取文本 String str = new String(all,&quot;GBK&quot;); //解码，解码方式为GBK System.out.println(str); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 用FileReader 字符流正确读取中文 FileReader得到的是字符，所以一定是已经把字节根据某种编码识别成为字符了 而FileReader使用的编码方式是Charset.defaultCharset()的返回值，如果是中文的操作系统，就是GBK FileReader是不能手动设置编码方式的，为了使用其他的编码方式，只能使用InputStreamReader来代替，像这样： 1new InputStreamReader(new FileInputStream(f), Charset.forName(&quot;UTF-8&quot;)); 缓存流 以介质是硬盘为例，字节流和字符流的弊端： 在每一次读写的时候，都会访问硬盘。 如果读写的频率比较高的时候，其性能表现不佳。 为了解决以上弊端，采用缓存流。 缓存流在读取的时候，会一次性读较多的数据到缓存中，以后每一次的读取，都是在缓存中访问，直到缓存中的数据读取完毕，再到硬盘中读取。 就好比吃饭，不用缓存就是每吃一口都到锅里去铲。用缓存就是先把饭盛到碗里，碗里的吃完了，再到锅里去铲。 缓存流在写入数据的时候，会先把数据写入到缓存区，直到缓存区达到一定的量，才把这些数据，一起写入到硬盘中去。按照这种操作模式，就不会像字节流，字符流那样每写一个字节都访问硬盘，从而减少了IO操作，提高速度。 使用缓存流读取数据 缓存字符输入流 BufferedReader 可以一次读取一行数据，但要注意，缓存流必须建立在一个存在的流的基础上 先准备好文件 d:/lol.txt,文件内容如下： garen kill teemo teemo revive after 1 minutes teemo try to garen, but killed again 12345678910111213141516171819202122232425262728293031package stream; import java.io.BufferedReader;import java.io.File;import java.io.FileReader;import java.io.IOException; public class TestStream &#123; public static void main(String[] args) &#123; File f = new File(&quot;d:/lol.txt&quot;); try ( FileReader fr = new FileReader(f); // 创建文件字符流 BufferedReader br = new BufferedReader(fr); // 缓存流必须建立在一个存在的流的基础上 ) &#123; while (true) &#123; String line = br.readLine();// 一次读一行 if (line == null) break; System.out.println(line); &#125; &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; 使用缓存流写入数据 之前的 FileOutputStream 与 FileWriter要写入一串数据时，必须将数据转换为数组，一次只能写入一个字符。 而PrintWriter 缓存字符输出流， 可以一次写入一行数据； 12345678910111213141516171819202122232425262728package stream; import java.io.File;import java.io.FileWriter;import java.io.IOException;import java.io.PrintWriter; public class TestStream &#123; public static void main(String[] args) &#123; // 向文件lol2.txt中写入三行语句 File f = new File(&quot;d:/lol2.txt&quot;); try ( FileWriter fw = new FileWriter(f); // 创建文件字符流 PrintWriter pw = new PrintWriter(fw); // 缓存流必须建立在一个存在的流的基础上 ) &#123; pw.println(&quot;garen kill teemo&quot;); //写入一行数据 pw.println(&quot;teemo revive after 1 minutes&quot;); pw.println(&quot;teemo try to garen, but killed again&quot;); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; flush方法 有的时候，需要立即把数据写入到硬盘，而不是等缓存满了才写出去。 这时候就需要用到flush()方法 123456789101112131415161718192021222324252627package stream; import java.io.File;import java.io.FileWriter;import java.io.IOException;import java.io.PrintWriter;public class TestStream &#123; public static void main(String[] args) &#123; //向文件lol2.txt中写入三行语句 File f =new File(&quot;d:/lol2.txt&quot;); try( FileWriter fr = new FileWriter(f); //创建文件字符流 PrintWriter pw = new PrintWriter(fr); //缓存流必须建立在一个存在的流的基础上 ) &#123; pw.println(&quot;garen kill teemo&quot;); pw.flush(); //强制把缓存中的数据写入硬盘，无论缓存是否已满 pw.println(&quot;teemo revive after 1 minutes&quot;); pw.flush(); pw.println(&quot;teemo try to garen, but killed again&quot;); pw.flush(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; 数据流 DataInputStream 数据输入流 DataOutputStream 数据输出流 直接读写字符串 使用数据流的writeUTF()和readUTF() 可以进行数据的格式化顺序读写； 如本例，通过DataOutputStream 向文件顺序写出【布尔值，整数和字符串】。 然后再通过DataInputStream 顺序读入这些数据。 注： 要用DataInputStream 读取一个文件，这个文件必须是由DataOutputStream 写出的，否则会出现EOFException 因为DataOutputStream 在写出的时候会做一些特殊标记，只有DataInputStream 才能成功的读取。 读取步骤： 创建输入流 FileInputStream() 创建数据输入流 DataInputStream() 读取布尔值：boolean b= dis.readBoolean(); 读取整数：int i = dis.readInt(); 读取字符串：String str = dis.readUTF(); 12345678910111213141516File f =new File(&quot;d:/lol.txt&quot;);try ( FileInputStream fis = new FileInputStream(f); DataInputStream dis =new DataInputStream(fis);)&#123; boolean b= dis.readBoolean(); int i = dis.readInt(); String str = dis.readUTF(); System.out.println(&quot;读取到布尔值:&quot;+b); System.out.println(&quot;读取到整数:&quot;+i); System.out.println(&quot;读取到字符串:&quot;+str);&#125; catch (IOException e) &#123; e.printStackTrace();&#125; 写入步骤： 创建输出流：FileOutputStream() 创建数据输出流：DataOutputStream() 写入布尔值true：dos.writeBoolean(true) 写入整数：dos.writeInt(123) 写入字符串：dos.writeUTF(&quot;This is my string&quot;) 1234567891011File f =new File(&quot;d:/lol.txt&quot;);try ( FileOutputStream fos = new FileOutputStream(f); DataOutputStream dos =new DataOutputStream(fos);)&#123; dos.writeBoolean(true); dos.writeInt(300); dos.writeUTF(&quot;123 this is gareen&quot;);&#125; catch (IOException e) &#123; e.printStackTrace();&#125; 对象流 序列化一个对象 需要用到： 对象输入流：ObjectInputStream 对象输出流：ObjectOutputStream 把一个对象序列化有一个前提是：这个对象的类，必须实现了Serializable接口 1234567891011package charactor; import java.io.Serializable; public class Hero implements Serializable &#123; //表示这个类当前的版本，如果有了变化，比如新设计了属性，就应该修改这个版本号 private static final long serialVersionUID = 1L; public String name; public float hp; &#125; 步骤： 创建一个Hero对象h，设置其名称为garen。 123Hero h = new Hero();h.name = &quot;garen&quot;;h.hp = 616; 把该对象序列化(即写入)到一个文件garen.lol。 1234567891011121314File f =new File(&quot;d:/garen.lol&quot;);try(//创建对象输出流FileOutputStream fos = new FileOutputStream(f);ObjectOutputStream oos =new ObjectOutputStream(fos);) &#123;oos.writeObject(h);&#125; catch (IOException e) &#123;// TODO Auto-generated catch blocke.printStackTrace();&#125; 然后再通过序列化把该文件转换为一个Hero对象 1234567891011121314File f =new File(&quot;d:/garen.lol&quot;);try(//创建对象输入流FileInputStream fis = new FileInputStream(f);ObjectInputStream ois =new ObjectInputStream(fis);)&#123; Hero h2 = (Hero) ois.readObject(); System.out.println(h2.name); System.out.println(h2.hp);&#125;catch (ClassNotFoundException e) &#123;// TODO Auto-generated catch blocke.printStackTrace();&#125; System.in System.out 是常用的在控制台输出数据的 System.in 可以从控制台输入数据 12345678910111213try (InputStream is = System.in;) &#123; while (true) &#123; // 敲入a,然后敲回车可以看到 // 97 13 10 // 97是a的ASCII码 // 13 10分别对应回车换行 int i = is.read(); System.out.println(i); &#125;&#125; catch (IOException e) &#123; e.printStackTrace();&#125; Scanner读取字符串 使用System.in.read虽然可以读取数据，但是很不方便； 使用Scanner就可以逐行读取了 1import java.util.Scanner; //使用前需要导入 123456Scanner s = new Scanner(System.in);while(true)&#123; String line = s.nextLine(); System.out.println(line);&#125; Scanner从控制台读取整数 12345Scanner s = new Scanner(System.in);int a = s.nextInt();System.out.println(&quot;第一个整数：&quot; + a);int b = s.nextInt();System.out.println(&quot;第二个整数：&quot; + b);"},{"title":"","date":"2024-03-31T14:49:40.671Z","updated":"2024-03-31T14:49:40.671Z","comments":true,"path":"notes/javase/javase_19/index.html","permalink":"https://blog.ajream.top/notes/javase/javase_19/","excerpt":"","text":"集合框架 ArrayList类 容器概念 我们已经知道，如果要存放多个对象，可以使用数组，但是数组有局限性，比如： 声明长度是10的数组，不用的数组就浪费了，超过10的个数，又放不下 为了解决数组的局限性，引入容器类的概念。 最常见的容器类就是ArrayList，容器的容量&quot;capacity&quot;会随着对象的增加，自动增长，只需要不断往容器里增加英雄即可，不用担心会出现数组的边界问题。 使用ArrayList前需导入： 1import java.util.ArrayList; 12345678//容器类ArrayList，用于存放对象ArrayList heros = new ArrayList();heros.add( new Hero(&quot;盖伦&quot;));System.out.println(heros.size());//容器的容量&quot;capacity&quot;会随着对象的增加，自动增长//只需要不断往容器里增加英雄即可，不用担心会出现数组的边界问题。heros.add( new Hero(&quot;提莫&quot;)); ArrayList常用方法 关键字 简介 示例代码 add 增加 示例代码 contains 判断是否存在 示例代码 get 获取指定位置的对象 示例代码 indexOf 获取对象所处的位置 示例代码 remove 删除 示例代码 set 替换 示例代码 size 获取大小 示例代码 toArray 转换为数组 示例代码 addAll 把另一个容器所有对象都加进来 示例代码 clear 清空 示例代码 add 12345for (int i = 0; i &lt; 5; i++) &#123; heros.add(new Hero(&quot;hero &quot; + i));&#125;Hero specialHero = new Hero(&quot;special hero&quot;);heros.add(specialHero); contains 1234// 初始化5个对象System.out.println(heros); //打印herosSystem.out.println(heros.contains(new Hero(&quot;hero 1&quot;))); //falseSystem.out.println(heros.contains(specialHero)); //true get 通过get获取指定位置的对象，如果输入的下标越界，一样会报错 123System.out.println(heros.get(5)); //获取指定位置的对象System.out.println(heros.get(6)); //如果超出了范围，依然会报错 indexOf 123System.out.println(&quot;specialHero所处的位置:&quot;+heros.indexOf(specialHero));System.out.println(&quot;新英雄，但是名字是\\&quot;hero 1\\&quot;所处的位置:&quot;+heros.indexOf(new Hero(&quot;hero 1&quot;))); remove remove可以根据下标删除ArrayList的元素 1heros.remove(2); 也可以根据对象删除 1heros.remove(specialHero); set set用于替换指定位置的元素 1heros.set(5, new Hero(&quot;hero 5&quot;)); size size 用于获取ArrayList的大小 1System.out.println(heros.size()); toArray toArray可以把一个ArrayList对象转换为数组。 需要注意的是，如果要转换为一个Hero数组，那么需要传递一个Hero数组类型的对象给toArray()，这样toArray方法才知道，你希望转换为哪种类型的数组，否则只能转换为Object数组 12Hero hs[] = (Hero[])heros.toArray(new Hero[]&#123;&#125;);//传递一个Hero数组类型的对象new Hero[]&#123;&#125;给toArray() addAll addAll 把另一个容器所有对象都加进来 12345ArrayList anotherHeros = new ArrayList();anotherHeros.add(new Hero(&quot;hero a&quot;));anotherHeros.add(new Hero(&quot;hero b&quot;));heros.addAll(anotherHeros); clear clear 清空一个ArrayList 12heros.clear();System.out.println(&quot;ArrayList heros:\\t&quot; + heros); List接口 ArrayList与List ArrayList实现了接口List，常见的写法会把引用声明为接口List类型 注意：是java.util.List,而不是java.awt.List 1234567891011121314151617181920212223package collection; import java.util.ArrayList;import java.util.List; import charactor.Hero; public class TestCollection &#123; public static void main(String[] args) &#123; //ArrayList实现了接口List //常见的写法会把引用声明为接口List类型 //注意：是java.util.List,而不是java.awt.List //接口引用指向子类对象（多态） List heros = new ArrayList(); heros.add( new Hero(&quot;盖伦&quot;)); System.out.println(heros.size()); &#125; &#125; List的接口与方法 因为ArrayList实现了List接口，所以List接口的方法ArrayList都实现了。 在【ArrayList常用方法】有详细的讲解，在此不作赘述 泛型 不指定泛型的容器，可以存放任何类型的元素 指定了泛型的容器，只能存放指定类型的元素以及其子类 语法： 1234List&lt;Hero&gt; genericheros = new ArrayList&lt;Hero&gt;(); //只能存放Hero类型//简写List&lt;Hero&gt; genericheros = new ArrayList&lt;&gt;(); 遍历 关键字 简介 示例代码 for 用for循环遍历 示例代码 iterator 迭代器遍历 示例代码 增强型for 用增强型for循环 示例代码 for 1234for (int i = 0; i &lt; heros.size(); i++) &#123; Hero h = heros.get(i); System.out.println(h);&#125; iterator Iterator 类位于 java.util 包中，使用前需要引入它，语法格式如下： 1import java.util.Iterator; // 引入 Iterator 类 迭代器的两个基本操作是 next 、hasNext 和 remove。 调用 it.next() 会返回迭代器的下一个元素，并且更新迭代器的状态。 调用 it.hasNext() 用于检测集合中是否还有元素。 调用 it.remove() 将迭代器返回的元素删除。 首先将集合转为迭代器 1Iterator&lt;Hero&gt; it= heros.iterator(); 用while遍历 123456//从最开始的位置判断&quot;下一个&quot;位置是否有数据while(it.hasNext())&#123; //判断是否为null Hero h = it.next(); //通过next取出来，并且把指针向下移动 System.out.println(h);&#125; 用for遍历 1234for (Iterator&lt;Hero&gt; iterator = heros.iterator(); iterator.hasNext();) &#123; Hero hero = (Hero) iterator.next(); System.out.println(hero);&#125; 增强型for 123for (Hero h : heros) &#123; System.out.println(h);&#125; 其他集合 链表-LinkList 以下情况使用 ArrayList : 频繁访问列表中的某一个元素。 只需要在列表末尾进行添加和删除元素操作。 以下情况使用 LinkedList : 你需要通过循环迭代来访问列表中的某些元素。 需要频繁的在列表开头、中间、末尾等位置进行添加和删除元素操作。 123456//创建链表import java.util.LinkList;LinkedList&lt;E&gt; list = new LinkedList&lt;E&gt;(); // 普通创建方法//或者LinkedList&lt;E&gt; list = new LinkedList(Collection&lt;? extends E&gt; c); // 使用集合创建链表 常用方法: 插入： addLast() addFirst() 查看： getFirst() getLast() 删除： removeFirst() removeLast() 队列-Queue Queue是先进先出队列 FIFO，常用方法： offer(e) 在最后添加元素e poll() 取出第一个元素 peek() 查看第一个元素 二叉树 二叉树由各种节点组成 二叉树特点： 每个节点都可以有左子节点，右子节点 每一个节点都有一个值 123456789package collection; public class Node &#123; public Node leftNode; // 左子节点 public Node rightNode; // 右子节点 public Object value; // 值&#125; HashMap HashMap 是一个散列表，它存储的内容是键值对key-value映射； HashMap 实现了 Map 接口，根据键的 HashCode 值存储数据，具有很快的访问速度，最多允许一条记录的键为 null，不支持线程同步； HashMap 是无序的，即不会记录插入的顺序； HashMap中的key不能重复，value可以重复； HashMap 继承于AbstractMap，实现了 Map、Cloneable、java.io.Serializable 接口。 创建一个 HashMap 对象 Sites，其中： key为整型 value为字符串（String）类型 123import java.util.HashMap; // 引入 HashMap 类HashMap&lt;Integer, String&gt; Sites = new HashMap&lt;Integer, String&gt;(); 添加元素 put(key, value) 1234567891011121314import java.util.HashMap;public class HashMapTest &#123; public static void main(String[] args) &#123; // 创建 HashMap 对象 Sites HashMap&lt;Integer, String&gt; Sites = new HashMap&lt;Integer, String&gt;(); // 添加键值对 Sites.put(1, &quot;Google&quot;); Sites.put(2, &quot;Runoob&quot;); Sites.put(3, &quot;Taobao&quot;); Sites.put(4, &quot;Zhihu&quot;); System.out.println(Sites); &#125;&#125; 访问元素的value值：get(key) 1System.out.println(Sites.get(3)); 删除元素（键值对）：remove(key) 1Sites.remove(4); 清空所有键值对：clear() 1Sites.clear(); 返回元素(键值对)数量：size() 1Sites.size(); 返回所有key：keySet() 1Sites.keySet() 返回所有values：values() 1Sites.values() HashSet HashSet 基于 HashMap 来实现的，是一个不允许有重复元素的集合。 HashSet 允许有 null 值。 HashSet 是无序的，即不会记录插入的顺序。 由于Set是无序的，所以Set不可以获取指定位置的元素。 HashSet 实现了 Set 接口。 创建一个Set： 1HashSet&lt;String&gt; sites = new HashSet&lt;String&gt;(); 添加元素：sites.add(e) 判断元素e是否存在：sites.contains(e) 删除元素：sites.remove(e) 清空元素：sites.clear() 计算大小：sites.size() Collection Collection是 Set、List、Queue、Deque的接口（Deque 继承 Queue,间接的继承了 Collection） Queue: 先进先出队列 Deque: 双向链表 注：Collection 和 Map 之间没有关系，Collection是放一个一个对象的，Map 是放键值对的 Collections Collections是一个类，容器的工具类，就如同Arrays是数组的工具类 Collections具有以下方法： 关键字 简介 reverse 反转 shuffle 混淆 sort 排序 swap 交换两个数据的位置 rotate 滚动 synchronizedList 线程安全化 创建一个集合numbers 123import java.util.ArrayList;import java.util.Collections;import java.util.List; 12345List&lt;Integer&gt; numbers = new ArrayList&lt;&gt;();for (int i = 0; i &lt; 10; i++) &#123; numbers.add(i);&#125; reverse： 1Collections.reverse(numbers); shuffle： 1Collections.shuffle(numbers); sort： 1Collections.sort(numbers); swap： 1Collections.swap(numbers,0, 5); //交换第0个和第5个元素 rotate：把List中的数据，向右滚动指定单位的长度 1Collections.rotate(numbers,2); synchronizedList：把非线程安全的List转换为线程安全的List 123//把非线程安全的List转换为线程安全的ListList&lt;Integer&gt; synchronizedNumbers = (List&lt;Integer&gt;) Collections.synchronizedList(numbers); 关系与区别 其他"},{"title":"","date":"2024-03-31T14:49:40.671Z","updated":"2024-03-31T14:49:40.671Z","comments":true,"path":"notes/javase/javase_2/index.html","permalink":"https://blog.ajream.top/notes/javase/javase_2/","excerpt":"","text":"属性初始化 对象属性初始化 声明的同时初始化 块初始化（声明后初始化） 通过构造方法初始化 1234567891011121314151617package charactor; public class Hero &#123; public String name = &quot;some hero&quot;; //声明该属性的时候初始化 protected float hp; float maxHP; &#123; maxHP = 200; //块初始化 &#125; public Hero()&#123; hp = 100; //构造方法中初始化 &#125; &#125; 注意：最后进行的是通过构造方法进行的初始化，需要在创建对象的时候才开始初始化 123456789101112131415161718package ChuShiHua;public class Hero &#123; public String name = &quot;some hero&quot;; &#123; System.out.println(&quot;声明时初始化：&quot;+name); &#125; public Hero() &#123; name = &quot;one hero&quot;; System.out.println(&quot;构造方法中初始化：&quot; + name); &#125; &#123; name = &quot;the hero&quot;; System.out.println(&quot;块初始化：&quot; + name); &#125;&#125; 创建对象，查看输出： 1234567891011121314package ChuShiHua;public class Test &#123; public static void main(String[] args)&#123; Hero hero = new Hero(); &#125; &#125;/**输出：声明时初始化：some hero块初始化：the hero构造方法中初始化：one hero*/ 因此初始化顺序为：声明时初始化-&gt;块初始化-&gt;构造方法中初始化 类属性初始化 声明的同时初始化 静态块初始化 12345678910111213141516171819package charactor; public class Hero &#123; public static int itemCapacity=8; //声明的时候 初始化 static&#123; //静态初始化块 itemCapacity = 6; &#125; public Hero()&#123; &#125; public static void main(String[] args) &#123; System.out.println(Hero.itemCapacity); &#125; &#125;"},{"title":"","date":"2024-03-31T14:49:40.671Z","updated":"2024-03-31T14:49:40.671Z","comments":true,"path":"notes/javase/javase_20/index.html","permalink":"https://blog.ajream.top/notes/javase/javase_20/","excerpt":"","text":"容 器 Collectiion接口 Collection接口声明了以下方法： 1234567891011121314151617boolean add(Object element);boolean remove(Object element);boolean contains(Object element);int size(); //容器中元素数量 boolean isEmpty();void clear();Iterator iterator();boolean containsAll(Collection c);boolean addAll(Collection c);boolean removeAll(Collection c);boolean retainAll(Collection c); //移除非交集元素,保留交集元素Object[] toArray(); //转换成Object数组 注：List和Set是Collection的子接口 List接口 List特点：有序、元素可重复 有序：每个元素都有索引标记 List通常允许满足 e1.equals(e2) 的元素重复加入容器 相比Collection接口，List中多了一些与索引有关的方法 12345678void add(int index, Object element);Object set(int index, Object element);Object get(int index);Object remove(int index);int indexOf(Object o); //返回第一个匹配元素的索引，若没有返回-1int lastIndexOf(Object o); //返回最后一个匹配的元素的索引，若没有返回-1 ArrayList类 ArrayList底层是用【数组】实现的存储。特点：查询效率高，增删效率低，线程不安全。 我们知道，数组长度是有限的，而ArrayList是可以存放任意数量的对象，长度不受限制，那么它是怎么实现的呢? 本质上就是通过定义新的更大的数组，将旧数组中的内容拷贝到新数组，来实现扩容。 ArrayList的Object数组【初始化长度为10】，如果我们存储满了这个数组，需要存储第11个对象，就会定义新的长度更大的数组，并将原数组内容和新的元素一起加入到新数组中 LinkList类 LinkList底层用【双向链表】实现 特点：查询效率低、增删效率高，线程不安全 双向链表也叫双链表，是链表的一种，它的每个数据节点中都有两个指针，分别指向前一个节点和后一个节点。 所以，从双向链表中的任意一个节点开始，都可以很方便地找到所有节点。 Vector类 Vector底层是用数组实现的List，相关的方法都加了同步检查，因此“线程安全,效率低”。 比如，indexOf方法就增加了synchronized同步标记。 如何选用ArrayList、LinkedList、Vector 需要线程安全时，用Vector。 不存在线程安全问题时，并且查找较多用ArrayList(一般使用它)。 不存在线程安全问题时，增加或删除元素较多用LinkedList。 Map接口 Map就是用来存储“键(key)-值(value) 对”的。 Map类中存储的“键值对”通过键来标识，所以“键”不能重复。 Map接口常用方法： 123456789101112Object put(Object key, Object value);Object get(Object key);Object remove(Object key);boolean containsKey(Object Key);boolean containsValue(Object value);int size();boolean isEmpty();void putAll(Map t);void clear(); Map 接口的实现类有HashMap、TreeMap、HashTable、Properties等。 HashMap类 HashMap采用哈希算法实现，是Map接口最常用的实现类。 由于底层采用了哈希表存储数据，我们要求键不能重复，如果发生重复，新的键值对会替换旧的键值对 HashMap在查找、删除、修改方面都有非常高的效率 HashTable类和HashMap用法几乎一样，底层实现几乎一样，只不过HashTable的方法添加了synchronized关键字确保线程同步检查，效率较低。 HashMap与HashTable的区别 HashMap: 线程不安全，效率高。允许key或value为null HashTable: 线程安全，效率低。不允许key或value为null Set接口与HashSet类 Set接口继承自Collection，Set接口中没有新增方法，方法和Collection保持完全一致。 Set容器特点：无序、不可重复 新元素如果和Set中某个元素通过equals()方法对比为true，则不能加入; 甚至，Set中也只能放入一个null元素，不能多个。 Set常用的实现类有：HashSet、TreeSet等，我们一般使用HashSet HashSet基本用法 1234567891011121314public class Test &#123; public static void main(String[] args) &#123; Set&lt;String&gt; s = new HashSet&lt;String&gt;(); s.add(&quot;hello&quot;); s.add(&quot;world&quot;); System.out.println(s); s.add(&quot;hello&quot;); //相同的元素不会被加入 System.out.println(s); s.add(null); System.out.println(s); s.add(null); System.out.println(s); &#125;&#125; 迭代器 将容器转为迭代器： 1Iterator&lt;E&gt; iter = aList.iterator() 使用Iterator迭代器遍历容器元素(List/Set/Map) 迭代器遍历ArrayList 12345678910111213List&lt;String&gt; aList = new ArrayList&lt;String&gt;();for (int i = 0; i &lt; 5; i++) &#123; aList.add(&quot;a&quot; + i);&#125;for (Iterator&lt;String&gt; iter = aList.iterator(); iter.hasNext();)&#123; String temp = iter.next(); System.out.print(temp + &quot;\\t&quot;); if (temp.endsWith(&quot;3&quot;)) &#123;// 删除3结尾的字符串 iter.remove(); &#125;&#125; 迭代器遍历Map 【1】 123456789101112public class Test&#123; public static void main(String[] args)&#123; Map&lt;String, String&gt; map = new HashMap&lt;String String&gt;(); map.put(&quot;A&quot;, &quot;GaoQi&quot;); map.put(&quot;B&quot;, &quot;LiuBa&quot;); Set&lt;Entry&lt;String, String&gt;&gt; ss = map.entrySet(); for(Iterator&lt;Entry&lt;String, String&gt;&gt; iterator = ss.iterator(); iterator.hasNext();)&#123; Entry&lt;String, String&gt; e = iterator.next(); System.out.println(e.getKey() + &quot;--&quot; + e.getValue()); &#125; &#125;&#125; 迭代器遍历Map 【2】 123456789101112public class Test &#123; public static void main(String[] args) &#123; Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); map.put(&quot;A&quot;, &quot;GaoQi&quot;); map.put(&quot;B&quot;, &quot;LiuBa&quot;); Set&lt;String&gt; ss = map.keySet(); for (Iterator&lt;String&gt; iterator = ss.iterator(); iterator.hasNext();) &#123; String key = iterator.next(); System.out.println(key + &quot;--&quot; + map.get(key)); &#125; &#125;&#125; Collections工具类 类 java.util.Collections 提供了对Set、List、Map进行排序、填充、查找元素的辅助方法。 void sort(List) //对List容器内的元素排序，排序的规则是按照升序进行排序。 void shuffle(List) //对List容器内的元素进行随机排列。 void reverse(List) //对List容器内的元素进行逆续排列 。 void fill(List, Object) //用一个特定的对象重写整个List容器。 int binarySearch(List, Object) //对于顺序的List容器，采用折半查找的方法查找特定对象。"},{"title":"","date":"2024-03-31T14:49:40.671Z","updated":"2024-03-31T14:49:40.671Z","comments":true,"path":"notes/javase/javase_21/index.html","permalink":"https://blog.ajream.top/notes/javase/javase_21/","excerpt":"","text":"泛型 泛型用法 泛型的用法是在容器后面添加&lt;Type&gt; 1234ArrayList&lt;APHero&gt; heros = new ArrayList&lt;APHero&gt;();//简写：ArrayList&lt;Hero&gt; heros2 = new ArrayList&lt;&gt;(); Type可以是类，抽象类，接口； 泛型表示这种容器，只能存放APHero，ADHero就放不进去了。 创建支持泛型的类 设计一个支持泛型的栈 MyStack 设计这个类的时候，在类的声明上，加上一个，表示该类支持泛型。 T是type的缩写，也可以使用任何其他的合法的变量，比如A,B,X都可以，但是一般约定成俗使用T，代表类型。 1234567891011121314151617181920212223242526272829303132333435363738package generic; import java.util.HashMap;import java.util.LinkedList; import charactor.Hero;import property.Item; public class MyStack&lt;T&gt; &#123; LinkedList&lt;T&gt; values = new LinkedList&lt;T&gt;(); public void push(T t) &#123; values.addLast(t); &#125; public T pull() &#123; return values.removeLast(); &#125; public T peek() &#123; return values.getLast(); &#125; public static void main(String[] args) &#123; //在声明这个Stack的时候，使用泛型&lt;Hero&gt;就表示该Stack只能放Hero MyStack&lt;Hero&gt; heroStack = new MyStack&lt;&gt;(); heroStack.push(new Hero()); //不能放Item heroStack.push(new Item()); //在声明这个Stack的时候，使用泛型&lt;Item&gt;就表示该Stack只能放Item MyStack&lt;Item&gt; itemStack = new MyStack&lt;&gt;(); itemStack.push(new Item()); //不能放Hero itemStack.push(new Hero()); &#125; &#125; 通配符 ? extends ArrayList heroList&lt;? extends Hero&gt; 表示这是一个Hero泛型或者其子类泛型（可以理解为这个heroList的元素类型是：Hero或其子类类型）： heroList 的泛型可能是Hero heroList 的泛型可能是APHero heroList 的泛型可能是ADHero 所以 可以确定的是，从heroList取出来的对象，一定是可以转型成Hero的 1234567ArrayList&lt;APHero&gt; apHeroList = new ArrayList&lt;APHero&gt;();apHeroList.add(new APHero());ArrayList&lt;? extends Hero&gt; heroList = apHeroList;//可以确凿的是，从heroList取出来的对象，一定是可以转型成Hero的Hero h = heroList.get(0); 注：不能往里面放东西，因为： 放APHero就不满足&lt;ADHero&gt; 放ADHero又不满足&lt;APHero&gt; 1heroList.add(new ADHero()); //编译错误，因为heroList的泛型有可能是APHero ? super ArrayList heroList&lt;? super Hero&gt; 表示这是一个Hero或者其父类泛型: heroList的泛型可能是Hero heroList的泛型可能是Object 可以往里面插入Hero以及Hero的子类： 放Hero没问题 放APHero、ADHero也没问题 但是取出来有风险，因为不确定取出来是Hero还是Object 12ArrayList&lt;? super Hero&gt; heroList = new ArrayList&lt;Object&gt;();//? super Hero 表示 heroList的泛型是Hero或者其父类泛型Object 123456//所以就可以插入HeroheroList.add(new Hero());//也可以插入Hero的子类heroList.add(new APHero());heroList.add(new ADHero()); 12//但是，不能从里面取数据出来,因为其泛型可能是Object,而Object是强转Hero会失败Hero h= heroList.get(0); 泛型通配符【?】 泛型通配符?代表任意泛型 既然?代表任意泛型，那么换句话说，这个容器什么泛型都有可能； 取：只能以Object的形式取出来 放：不能往里面放对象，因为不知道到底是一个什么泛型的容器 1234567891011121314ArrayList&lt;APHero&gt; apHeroList = new ArrayList&lt;APHero&gt;();//?泛型通配符，表示任意泛型ArrayList&lt;?&gt; generalList = apHeroList;//?的缺陷1： 既然?代表任意泛型，那么换句话说，你就不知道这个容器里面是什么类型//所以只能以Object的形式取出来Object o = generalList.get(0);//?的缺陷2： 既然?代表任意泛型，那么既有可能是Hero,也有可能是Item//所以，放哪种对象进去，都有风险，结果就什么什么类型的对象，都不能放进去generalList.add(new Item()); //编译错误 因为?代表任意泛型，很有可能不是ItemgeneralList.add(new Hero()); //编译错误 因为?代表任意泛型，很有可能不是HerogeneralList.add(new APHero()); //编译错误 因为?代表任意泛型，很有可能不是APHero 总结 如果希望只取出，不插入，就使用? extends Hero 如果希望只插入，不取出，就使用? super Hero 如果希望，又能插入，又能取出，就不要用通配符？ 泛型转型 对象转型 根据面向对象学习的知识，子类转父类 是一定可以成功的 子类泛型转父类泛型 既然子类对象转父类对象是可以成功的，那么子类泛型转父类泛型能成功吗？（不能） 例如： hs的泛型是父类Hero adhs 的泛型是子类ADHero 那么 把adhs转换为hs能成功吗？（不能） 父类转子类也不能"},{"title":"","date":"2024-03-31T14:49:40.671Z","updated":"2024-03-31T14:49:40.671Z","comments":true,"path":"notes/javase/javase_22/index.html","permalink":"https://blog.ajream.top/notes/javase/javase_22/","excerpt":"","text":"多线程系列 线程状态 一个线程对象在它的生命周期内，需要经历5个状态。 新生状态(New) 用new关键字建立一个线程对象后，该线程对象就处于新生状态。 处于新生状态的线程有自己的内存空间，通过调用start方法进入就绪状态。 就绪状态(Runnable) 处于就绪状态的线程已经具备了运行条件，但是还没有被分配到CPU，处于“线程就绪队列”，等待系统为其分配CPU。 就绪状态并不是执行状态，当系统选定一个等待执行的Thread对象后，它就会进入执行状态。一旦获得CPU，线程就进入运行状态并自动调用自己的run方法。有4中原因会导致线程进入就绪状态： 新建线程：调用start()方法，进入就绪状态; 阻塞线程：阻塞解除，进入就绪状态; 运行线程：调用yield()方法，直接进入就绪状态; 运行线程：JVM将CPU资源从本线程切换到其他线程。 运行状态(Running) 在运行状态的线程执行自己run方法中的代码，直到调用其他方法而终止或等待某资源而阻塞或完成任务而死亡。 如果在给定的时间片内没有执行结束，就会被系统给换下来回到就绪状态。也可能由于某些“导致阻塞的事件”而进入阻塞状态。 阻塞状态(Blocked) 阻塞指的是暂停一个线程的执行以等待某个条件发生(如某资源就绪)。 有4种原因会导致阻塞： 执行sleep(int millsecond)方法，使当前线程休眠，进入阻塞状态。当指定的时间到了后，线程进入就绪状态。 执行wait()方法，使当前线程进入阻塞状态。当使用nofity()方法唤醒这个线程后，它进入就绪状态。 线程运行时，某个操作进入阻塞状态，比如执行IO流操作(read()/write()方法本身就是阻塞的方法)。只有当引起该操作阻塞的原因消失后，线程进入就绪状态。 join()线程联合: 当某个线程等待另一个线程执行结束后，才能继续执行时，使用join()方法 死亡状态(Terminated) 死亡状态是线程生命周期中的最后一个阶段。线程死亡的原因有两个: 正常运行的线程完成了它run()方法内的全部工作 线程被强制终止，如通过执行stop()或destroy()方法来终止一个线程 (注：stop()/destroy()方法已经被JDK废弃，不推荐使用)。 当一个线程进入死亡状态以后，就不能再回到其它状态了。 终止线程 终止线程一般不使用JDK提供的stop()/destroy()方法(它们本身也被JDK废弃了)。 通常的做法是提供一个boolean型的终止变量，当这个变量置为false，则终止线程。 12345678910111213141516171819202122232425262728293031323334package com.myThread;public class TestThread implements Runnable&#123; String name; boolean live = true;// 标记变量，表示线程是否可中止； public TestThread(String name) &#123; super(); this.name = name; &#125; public void run() &#123; int i = 0; //当live的值是true时，继续线程体；false则结束循环，继而终止线程体； while (live) &#123; System.out.println(name + (i++)); &#125; &#125; public void terminate() &#123; live = false; &#125; public static void main(String[] args) &#123; TestThread ttc = new TestThread(&quot;线程A:&quot;); Thread t1 = new Thread(ttc);// 新生状态 t1.start();// 就绪状态 for (int i = 0; i &lt; 10; i++) &#123; System.out.println(&quot;主线程&quot; + i); &#125; ttc.terminate(); System.out.println(&quot;ttc stop!&quot;); &#125;&#125; 该程序中通过主线程控制live的值，当主线程把live置为 false时，run()方法停止执行，子线程终止运行 暂停线程 暂停线程执行常用的方法有sleep()和yield()方法 这两个方法的区别是： sleep()方法：可以让正在运行的线程进入阻塞状态，直到休眠时间满了，进入就绪状态。 注意：是休眠期到了后才会进入就绪状态，参与竞争获取CPU使用权 yield()方法：可以让正在运行的线程直接进入就绪状态，让出CPU的使用权。 注意：由于没有标出让出的时间，所以下一刻就会立即进入竞争获取CPU的就绪状态 join()方法 b.join()可以将一个线程b插入到当前线程a中，这时a线程需要等待b执行完才会继续 线程基本信息获取 12345678isAlive();getPriority(); //获取线程优先级，默认为5setPriority(); //设置线程优先级数值（int）setName();getName();currentThread(); //获得当前线程 注意：优先级低只是意味着获得调度的概率低。并不是绝对先调用优先级高的线程后调用优先级低的线程。 线程同步 线程同步其实就是一种等待机制，多个需要同时访问此对象的线程进入这个对象的等待池形成队列，等待前面的线程使用完毕后，下一个线程再使用。 由于同一进程的多个线程共享同一块存储空间，在带来方便的同时，也带来了访问冲突的问题。Java语言提供了专门机制以解决这种冲突，有效避免了同一个数据对象被多个线程同时访问造成的这种问题。 由于我们可以通过 private 关键字来保证数据对象只能被方法访问，所以我们只需针对方法提出一套机制，这套机制就是synchronized关键字，它包括两种用法： synchronized 方法 synchronized 块 synchronized 方法 1public synchronized void func(int a); synchronized 方法控制对“对象的类成员变量”的访问：每个对象对应一把锁，每个 synchronized 方法都必须获得调用该方法的对象的锁方能执行，否则所属线程阻塞，方法一旦执行，就独占该锁，直到从该方法返回时才将锁释放，此后被阻塞的线程方能获得该锁，重新进入可执行状态。 synchronized块 synchronized 方法的缺陷：若将一个大的方法声明为synchronized 将会大大影响效率。 Java 为我们提供了更好的解决办法，那就是 synchronized 块。 块可以让我们精确地控制到具体的“成员变量”，缩小同步的范围，提高效率。 synchronized 块：通过 synchronized关键字来声明synchronized 块，语法如下： 123synchronized(syncObject)&#123; //允许访问控制的代码 &#125; 表示在操控 syncObject时，每次只能控制一次，如果多个线程同时执行到这一条语句，则同一时间只能有一个线程操控syncObject 死锁问题 死锁： 多个线程各自占有一些共享资源，并且互相等待其他线程占有的资源才能进行，而导致两个或者多个线程都在等待对方释放资源，都停止执行的情形。"},{"title":"","date":"2024-03-31T14:49:40.671Z","updated":"2024-03-31T14:49:40.671Z","comments":true,"path":"notes/javase/javase_23/index.html","permalink":"https://blog.ajream.top/notes/javase/javase_23/","excerpt":"","text":"Java反射机制 获取类对象 类对象 类对象，用于描述这种类，都有什么属性，什么方法的 获取类对象 Class.forName(); Hero.class （注：Hero是自定义类的类名） new Hero().getClass() 在一个JVM中，一种类，只会有一个类对象存在。所以以上三种方式取出来的类对象，都是一样的。 12345678String className = &quot;charactor.Hero&quot;;Class pClass1 = Class.forName(className);Class pClass2 = Hero.class;Class pClass3 = new Hero().getClass();System.out.println(pClass1 == pClass2);//trueSystem.out.println(pClass1 == pClass3);//true 获取类对象，会导致类属性的初始化 无论什么途径获取类对象，都会导致静态属性被初始化，而且只会执行一次。 （除了直接使用 Class c = Hero.class 这种方式，这种方式不会导致静态属性被初始化） 创建类对象 使用反射机制创建类对象，3个步骤 获取类对象 获取构造器 通过构造器实例化 12345678910//使用反射的方式创建对象String className = &quot;charactor.Hero&quot;;//类对象Class pClass = Class.forName(className);//构造器Constructor c = pClass.getConstructor();//通过构造器实例化Hero h2 = (Hero) c.newInstance(); 属性访问 用法 使用反射机制获取并修改类对象属性（也叫字段Field），4个步骤 导包 获取类对象 获取属性（字段）—— getDeclaredField 修改指定对象的属性值—— set 123456789import java.lang.reflect.Field;Hero h = new Hero();Class c = h.getClass();Field f = c.getDeclaredField(&quot;name&quot;);f1.set(h, &quot;teemo&quot;);//修改这个字段的值 区分 getField 与 getDeclaredField 这两个方法都是用于获取字段 getField 只能获取public的，包括从父类继承来的字段。 getDeclaredField 可以获取本类所有的字段，包括private的，但是不能获取继承来的字段。 注： 这里只能获取到private的字段，但并不能访问该private字段的值,除非加上setAccessible(true) 方法获取 导包 获取类对象 获取到方法—— getMethod 调用指定对象的方法—— invoke 123456789import java.lang.reflect.Method;Hero h = new Hero(); // 获取这个名字叫做setName，参数类型是String的方法Method m = h.getClass().getMethod(&quot;setName&quot;, String.class);// 对h对象，调用这个方法m.invoke(h, &quot;garent&quot;);"},{"title":"","date":"2024-03-31T14:49:40.671Z","updated":"2024-03-31T14:49:40.671Z","comments":true,"path":"notes/javase/javase_24/index.html","permalink":"https://blog.ajream.top/notes/javase/javase_24/","excerpt":"","text":"Java注解Anotation 1. 什么是注解 注解是jdk5.0开始引进的新技术 1.1作用是什么 注解的作用类似注释，但注释是给人（程序员）看的，而注解是给编译器看的。 注解通过标记包、类、字段、方法、局部变量、方法参数等元素据，告诉jvm这些元素据的信息 1.2 格式 以 @注解名 的格式存在，如： 123@override@suppressWarnings(value=&quot;unchecked&quot;) 2. 元注解 元注解即用来定义注解的注解，也就是在你创建注解的时候会用到，Java有4个类型的元注解： 1234@Target@Retention@Documented @Inherited @Target 表示该注解用于什么地方，可以是包、类、方法…，在枚举类 ElemenetType中 有说明: 123456789101112131415161718192021222324252627282930313233343536373839public enum ElementType &#123; /** Class, interface (including annotation type), or enum declaration */ TYPE, /** Field declaration (includes enum constants) */ FIELD, /** Method declaration */ METHOD, /** Formal parameter declaration */ PARAMETER, /** Constructor declaration */ CONSTRUCTOR, /** Local variable declaration */ LOCAL_VARIABLE, /** Annotation type declaration */ ANNOTATION_TYPE, /** Package declaration */ PACKAGE, /** * Type parameter declaration * * @since 1.8 */ TYPE_PARAMETER, /** * Use of a type * * @since 1.8 */ TYPE_USE&#125; 例如创建一个test1注解： 1234@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;) //可以用在方法、class中@interface Test1&#123; String value() default &quot;&quot;; //参数，默认为空 &#125; @Retention 表示在什么级别保存该注解信息。可选的参数值在枚举类型 RetentionPolicy 中，包括： 123RetentionPolicy.SOURCE //注解将被编译器丢弃 RetentionPolicy.CLASS //注解在class文件中可用，但会被VM丢弃 RetentionPolicy.RUNTIME //JVM将在运行期也保留注释，因此可以通过反射机制读取注解的信息。通常自定义注解都用这个 @Documented 将此注解包含在 javadoc 中 ，它代表着此注解会被javadoc工具提取成文档。在doc文档中的内容会因为此注解的信息内容不同而不同。 @Inherited 允许子类继承父类中的注解。 3. 自定义注解 一般使用元注解 @Target，指明在哪里使用 @Retention， 指明在什么时候起作用 例如： 12345678@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)@Retention(value = RetentionPolicy.RUNTIME)public@interface User&#123; //下面是注解的参数，定义格式：“类型 参数名();” , 默认值看自己要不要写 String name() default &quot;&quot;; //默认值为空 int id() default -1; //默认值-1，代表不存在&#125;"},{"title":"","date":"2024-03-31T14:49:40.671Z","updated":"2024-03-31T14:49:40.671Z","comments":true,"path":"notes/javase/javase_3/index.html","permalink":"https://blog.ajream.top/notes/javase/javase_3/","excerpt":"","text":"访问修饰符 区分： 有 public、private、protected 没有修饰符即为默认：package/friendly/default private：只有类自身可以访问；由该类实例的对象不能访问，子类不能继承 public：所有类均可以继承、访问：（同包/不同包）子类可继承；（同包/不同包）类可以访问 protected：不同包且没有继承关系的类不能访问 没有修饰符（package）：只能在自己包使用；不同包不能访问、继承 总结(红色字体表示不可行) ​ 下面以Hero为研究对象，弄清楚各个类之间的关系 **自身：**指的是Hero自己 **同包子类：**ADHero这个类是Hero的子类，并且和Hero处于同一个包下 不同包子类：Support这个类是Hero的子类，但是在另一个包下 同包类： GiantDragon 这个类和Hero是同一个包，但是彼此没有继承关系 **其他类：**Item这个类，在不同包，也没有继承关系的类 什么情况使用什么修饰符 属性通常使用private封装起来 方法一般使用public用于被调用 会被子类继承的方法，通常使用protected package用的不多，一般新手会用package,因为还不知道有修饰符这个东西 作用范围最小原则: 简单说，能用private就用private，不行就放大一级，用package,再不行就用protected，最后用public。 这样就能把数据尽量的封装起来，没有必要露出来的，就不用露出来了"},{"title":"","date":"2024-03-31T14:49:40.671Z","updated":"2024-03-31T14:49:40.671Z","comments":true,"path":"notes/javase/javase_4/index.html","permalink":"https://blog.ajream.top/notes/javase/javase_4/","excerpt":"","text":"数据类型 基本数据类型 整型 （4种） byte (8位)，最高位表示正负，−27-2^7−27~27−12^7-127−1 byte a = 15; short(16位)，−215-2^{15}−215~215−12^{15}-1215−1 short a = 567; int(32位)，−231-2^{31}−231~231−12^{31}-1231−1，默认为int型 10进制：int a = 123; 16进制：int a = 0x4f; 8进制：int a = 0123; long(64位)，−263-2^{63}−263~263−12^{63}-1263−1 long a = 678L; 1234567891011public class HelloWorld&#123; public static void main(String[] args)&#123; byte b = 1; short s = 200; int i = 300; long l = 400; /*如果试图给byte类型的变量赋予超出其范围的值，就会产生编译错误*/ byte b2 = 200; //报错 &#125;&#125; 123456789public class HelloWorld &#123; public static void main(String[] args) &#123; long val = 26L; //以L结尾的字面值表示long型 int decVal = 26; //默认就是int型 int hexVal = 0x1a; //16进制 int oxVal = 032; //8进制 int binVal = 0b11010; //2进制 &#125;&#125; 字符型 （1种） char类型用于存放一个字符，值用单引号 '' 表示 (双引号表示字符串)； 长度和short一样，也是16位的，只能存放一个字符，超过一个字符就会产生编译错误； 中文字符与英文字母一样，都占用2个字节，即16位 123456789101112public class HelloWorld&#123; public static void main(String[] args)&#123; char c = &#x27;中&#x27;; char A = 65; //char 只能存放一个字符，超过一个字符就会产生编译错误 char c2 = &#x27;中国&#x27;; //报错 char c3 = &#x27;ab&#x27;; //报错 &#125;&#125; char与short区别： ​ 在java中，char和short都是两个字节的长度。但char表示的是16位无符号整数，表示的范围是0~65535。short表示的是16位有符号整数，范围为-32768～32767。char用来保存一个Unicode编码的字符。char和short之间类型转换需要强转。 浮点型 （2种） float(32位) double(64位)，小数默认都是double类型，因此要声明float类型的数，要在末尾加一个字母f 123456789101112public class HelloWorld&#123; public static void main(String[] args)&#123; float f = 54.321;//报错,因为54.321是double型的 float f2 = 54.321f; double d1 = 1.234; double d2 = 1.2e3 //即1.2*1000 &#125;&#125; 布尔型（1种） boolen（1位）：用于表示真假，true或 false，注意不能用1或0来代替 12345678910111213public class HelloWorld &#123; public static void main(String[] args) &#123; boolean b1 = true; boolean b2 = false; // 虽然布尔型真正存放的数据是0(false) 1(true) // 但是，不能直接使用0 1 进行赋值 boolean b3 = 1; &#125;&#125; 引用数据类型 引用数据类型存储的是数据存放的地址 类 在Java中，可以创建一个类，再利用类来创建一个新的实例（对象），该实例的类型就是一种引用数据类型 123456public class Date&#123; int year; int month; int day;&#125; 1Date d1 = new Date() //d1为引用数据类型 字符串(String) String将字符串当作一个整体来处理，不能修改串中的字符元素，可看作一个字符串常量。 如&quot;This is a string.\\n&quot;。注意使用双引号。 定义一个String： 123456String s1 = new String(&quot;123abc&quot;);String s2;s2 = &quot;123abc&quot;;String s3 = &quot;123abc&quot;; 连接两个字符串用 + 1234String s1 = &quot;123&quot;;String s2 = &quot;abc&quot;;String s3;s3 = s1 + s2; 数组 数组是一个固定长度的，包含了相同类型数据的 容器 声明数组（不会创建数组） 1234567891011121314public class HelloWorld &#123; public static void main(String[] args) &#123; // 声明一个数组 int[] a; &#125;&#125;/*int[] a; 声明了一个数组变量。[]表示该变量是一个数组int 表示数组里的每一个元素都是一个整数a 是变量名但是，仅仅是这一句声明，不会创建数组*/ 创建数组 123//先声明再创建int[] a;a = new int[5] 12//声明的同时，创建一个数组int[] a = new int[5]; 数组名 a是一个引用 初始化数组 如果数组的类型为int，未初始化时每个元素默认为0 先声明，创建数组，再一个个元素进行赋值 12345678910111213int[] a = new int[5]; //声明和创建 //没有赋值，那么就会使用默认值//作为int类型的数组，默认值是0System.out.println(a[0]); //进行赋值a[0] = 100;a[1] = 101;a[2] = 103;a[3] = 120;a[4] = 140; 声明、创建的同时初始化 12345678910public class HelloWorld &#123; public static void main(String[] args) &#123; //写法一： 分配空间同时赋值 int[] a = new int[]&#123;100,102,444,836,3236&#125;; //写法二： 省略了new int[],效果一样 int[] b = &#123;100,102,444,836,3236&#125;; &#125;&#125; 注意：初始化的同时不能指定数组长度： 1int[] c = new int[5]&#123;100,102,444,836,3236&#125;; 访问数组 123a[0]=1;a[1]=2;a[2]=3; 数组长度 .length属性用于访问一个数组的长度 1System.out.println(a.length) 二维数组 下面声明、创建并初始化了一个二维数组 12345int[][] b = new int[][]&#123; &#123;1,2,3&#125;, &#123;4,5,6&#125;, &#123;7,8,9&#125;&#125;;"},{"title":"","date":"2024-03-31T14:49:40.671Z","updated":"2024-03-31T14:49:40.671Z","comments":true,"path":"notes/javase/javase_5/index.html","permalink":"https://blog.ajream.top/notes/javase/javase_5/","excerpt":"","text":"Arrays类 常用数组操作 操作 简介 copyOfRange 拷贝数组 toString 数组转为字符串 sort() 数组排序 binarySearch 搜索数组中的某一元素 equals 判断是否相同 fill 填充 copyOfRange(int[] original, int from, int to) original表示源数组 from表示拷贝开始下标 to表示结束位置下标（不包含to位置） 123456789101112131415import java.util.Arrays; public class HelloWorld &#123; public static void main(String[] args) &#123; int a[] = new int[] &#123; 18, 62, 68, 82, 65, 9 &#125;; int[] b = Arrays.copyOfRange(a, 0, 3); //0 &lt;= i &lt;3 for (int i = 0; i &lt; b.length; i++) &#123; System.out.print(b[i] + &quot; &quot;); &#125; &#125; //输出：18 62 68&#125; toString(a) 将数组a转为字符串 123456789101112import java.util.Arrays; public class HelloWorld &#123; public static void main(String[] args) &#123; int a[] = new int[] &#123; 18, 62, 68, 82, 65, 9 &#125;; String content = Arrays.toString(a); System.out.println(content); &#125;&#125;// 输出：[18, 62, 68, 82, 65, 9] binarySearch(a, b) a为数组，b为该数组中的一个元素 使用binarySearch进行查找之前，必须使用sort进行排序； 如果数组中有多个相同的元素，查找结果是不确定的 注意输出位置从1开始，而不是0 123456789101112131415import java.util.Arrays; public class HelloWorld &#123; public static void main(String[] args) &#123; int a[] = new int[] &#123; 18, 62, 68, 82, 65, 9 &#125;; Arrays.sort(a);//用binarySearch前，必须先使用sort进行排序 System.out.println(&quot;数字 62 出现的位置:&quot;+Arrays.binarySearch(a, 62)); &#125;&#125;//输出：//数字 62 出现的位置:2 equals(a1, a2) 判断a1, a2两个数组是否相同 返回值为 boolean值 123456789101112import java.util.Arrays; public class HelloWorld &#123; public static void main(String[] args) &#123; int a[] = new int[] &#123; 18, 62, 68, 82, 65, 9 &#125;; int b[] = new int[] &#123; 18, 62, 68, 82, 65, 8 &#125;; System.out.println(Arrays.equals(a, b)); &#125;&#125;//输出：false fill(a, b) 往数组a中填充元素b（如果a已经有值，则a中的所有值会被替换为b） 无返回值 1234567891011121314import java.util.Arrays; public class HelloWorld &#123; public static void main(String[] args) &#123; int a[] = new int[10]; Arrays.fill(a, 5); System.out.println(Arrays.toString(a)); &#125;&#125;//输出：[5, 5, 5, 5, 5, 5, 5, 5, 5, 5]"},{"title":"","date":"2024-03-31T14:49:40.671Z","updated":"2024-03-31T14:49:40.671Z","comments":true,"path":"notes/javase/javase_6/index.html","permalink":"https://blog.ajream.top/notes/javase/javase_6/","excerpt":"","text":"变量 命名规则 变量名只能使用 字母、数字、$、_ 变量第一个字符 只能使用 字母 、$、 _ 使用完整单词命名 类型转换 低精度向高精度转换可以正常转换 高精度向低精度转换有风险 123456789101112131415161718192021222324public class HelloWorld &#123; public static void main(String[] args) &#123; byte b = 5; int i1 = 10; int i2 = 300; b = (byte) i1; //因为i1的值是在byte范围之内，所以即便进行强制转换 //最后得到的值，也是10 System.out.println(b); //因为i2的值是在byte范围之外，所以就会按照byte的长度进行截取 //i2的值是300，其对应的二进制数是 100101100 //按照byte的长度8位进行截取后，其值为 00101100 即44 b =(byte) i2; System.out.println(b); //查看一个整数对应的二进制的方法： System.out.println(Integer.toBinaryString(i2)); &#125;&#125; 注意：short + short = int 变量分类 成员变量（字段、属性、Field）： 当一个变量被声明在类下面，变量就叫做成员变量，或字段 、属性、Field 比如变量下面例子中，i就是一个属性。那么从第2行这个变量声明的位置开始，整个类都可以访问得到；所以其作用域就是从其声明的位置开始的整个类 12345678910public class HelloWorld &#123; int i = 1; int j = i; //其他的属性可以访问i public void method1()&#123; System.out.println(i); //方法1里可以访问i &#125; public void method2()&#123; System.out.println(i); //方法2里可以访问i &#125;&#125; 参数 如果一个变量，是声明在一个方法上的，就叫做参数，参数的作用域即为该方法内的所有代码，在该方法外面不能使用该参数 123456789101112public class HelloWorld &#123; public void method1(int i)&#123; //参数i的作用域即方法method1 System.out.println(i); &#125; public void method2()&#123; System.out.println(i); //method2 不能访问参数i &#125; int j = i; //类里面也不能访问参数i&#125; 局部变量 声明在方法内的变量，叫做局部变量，其作用域在声明开始的位置，到其所处于的块结束位置。 1234567891011121314public class HelloWorld &#123; public void method1() &#123; int i = 5; //其作用范围是从声明的第4行，到其所处于的块结束12行位置 System.out.println(i); &#123; //子块 System.out.println(i); //可以访问i int j = 6; System.out.println(j); //可以访问j &#125; System.out.println(j); //不能访问j,因为其作用域到第10行就结束了 &#125; &#125; 静态变量 1static int age; //(类变量) final变量 用final修饰的变量，只能赋值1次，因此常用于定义常量 12345678910public class HelloWorld &#123; public void method1() &#123; final int i = 5; i = 10; //i在第4行已经被赋值过了，所以这里会出现编译错误 &#125; &#125; 但是对于引用类型的数据，变量存储的是地址，地址不可变，但地址里存放的值可以改变 12345678910111213public class HelloWorld &#123; public static void main(String[] args) &#123; final int []a = &#123;1,2,3&#125;; a[1] = 10; a[2] = 100; System.out.println(a[1]); System.out.println(a[2]); // 注意这样写：a = &#123;4,5,6&#125;; 是错误的 &#125;&#125; 输出如下"},{"title":"","date":"2024-03-31T14:49:40.671Z","updated":"2024-03-31T14:49:40.671Z","comments":true,"path":"notes/javase/javase_7/index.html","permalink":"https://blog.ajream.top/notes/javase/javase_7/","excerpt":"","text":"操作符 算数操作符 基本操作符： 1+ - * / % 5.1.2 任意运算单元的长度超过int 如果有任何运算单元的长度超过int,那么运算结果就按照最长的长度计算 比如: 123int a = 5;long b = 6;// a+b 结果类型是long 任意运算单元的长度小于int 如果任何运算单元的长度都不超过int，那么运算结果就按照int来计算 如：byte + byte -&gt; int, short + short -&gt; int 自增、自减 12345//以++为例int i = 5;int s;s = i++; //先取值，再运算，结果s的值即表达式的值，为5，i的值为6 12345以++为例int i = 5;int s;s = ++i; //先运算，再取值，结果s的值即表达式的值，为6，i的值为6 关系操作符 比较两个变量之间关系，返回true或false 123456&gt;&lt;== 等于&gt;=&lt;=!= 不等于 逻辑操作符 操作符 简称 意义 &amp; 长路与 无论第一个表达式的值是true或者false，第二个的值，都会被运算 &amp;&amp; 短路与 只要第一个表达式的值是false的，第二个表达式就不进行运算了 | 长路或 符号两侧的表达式都被计算 || 短路或 只要第一个是true的，第二个就不进行运算了 ! 取反 真的将变成假，假的将变成真 ^ 异或 符号两边一真一假，返回真；两边同为真或同为假，返回假 操作符 同 异 &amp;、&amp;&amp; 运算符两边都为真时，结果才为真 第二个表达式是否被计算 |、|| 运算符两边都为假时，结果才为假 位运算符 运算符 简介 Integer.toBinaryString() 一个整数的二进制表达 ` ` &amp; 位与 ^ 异或 ~ 取反 &lt;&lt; 左移，即乘以2n2^n2n &gt;&gt; 右移 三元操作符 条件运算符?:是一个三元操作符 用法： 123表达式?值1:值2如果表达式为真，返回值1如果表达式为假，返回值2"},{"title":"","date":"2024-03-31T14:49:40.671Z","updated":"2024-03-31T14:49:40.671Z","comments":true,"path":"notes/javase/javase_8/index.html","permalink":"https://blog.ajream.top/notes/javase/javase_8/","excerpt":"","text":"输入语句 java使用 Scanner语句进行输入操作，使用前需在前面加上： 1import java.util.Scanner; 输入一个整数 包括两个步骤： 进入输入状态 读取输入的指定类型的数据 12Scanner s = new Scanner(System.in); //进入读取状态int a = s.nextInt(); //读取数据 输入一个浮点数 12Scanner s = new Scanner(System.in);float b = s.nextFloat() 输入一个字符串 123Scanner s = new Scanner(System.in);String s1 = s.nextLine();String s2 = s.next(); next()与nextLine()区别 next从第一个非空格字符开始读取，遇到空格就会停止（读取的数据不含空格），返回的是一个字符串 nextLine读取一整行数据，遇到回车就停止（读取的数据不包含回车），返回的是一个字符串 1234567891011121314import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); String s1 = in.next(); String s2 = in.nextLine(); System.out.print(s1); System.out.print(s2.length()); System.out.print(&quot;===================&quot;); &#125;&#125; 按下面格式输入： 12abcdef 输出如下： 1abc0=================== 说明：abc是s1的内容，0是s2的长度（即s2什么也没得到） next(),nextInt(),nextFloat()…这些只读取内容（不包含空格）部分，遇到空格或回车就截止了，把空格或回车放到了缓冲区 nextLine()则是读取一整行，返回字符串，遇到回车（不读取回车）就截止 因此，如果在next()后使用nextLine()，在输入数据后，按下回车，则数据会被next()获取， 此时nextLine()紧接着进行读取，正好遇到回车，因此，nextLine什么也没得到。"},{"title":"","date":"2024-03-31T14:49:40.671Z","updated":"2024-03-31T14:49:40.671Z","comments":true,"path":"notes/javase/javase_9/index.html","permalink":"https://blog.ajream.top/notes/javase/javase_9/","excerpt":"","text":"条件语句 if语句 3种基本用法 123456789101112131415161718192021222324252627----------1------------if()&#123;&#125;----------2------------if()&#123; &#125;else&#123; &#125;----------3------------ if()&#123; &#125;else if()&#123; &#125;else if()&#123; &#125;else&#123; &#125;----------------------- switch语句 switch可以使用byte,short,int,char,String,enum 每个表达式结束，都应该有一个break String在Java1.7之前是不支持的, Java从1.7开始支持switch用String的，编译后是把String转化为hash值，其实还是整数 enum是枚举类型 123456789101112131415161718192021222324252627282930313233public class HelloWorld &#123; public static void main(String[] args) &#123; int day = 5; switch(day)&#123; case 1: System.out.println(&quot;星期一&quot;); break; case 2: System.out.println(&quot;星期二&quot;); break; case 3: System.out.println(&quot;星期三&quot;); break; case 4: System.out.println(&quot;星期四&quot;); break; case 5: System.out.println(&quot;星期五&quot;); break; case 6: System.out.println(&quot;星期六&quot;); break; case 7: System.out.println(&quot;星期天&quot;); break; default: System.out.println(&quot;这个是什么鬼？&quot;); &#125; &#125;&#125;"},{"title":"","date":"2024-03-31T14:49:40.671Z","updated":"2024-03-31T14:49:40.671Z","comments":true,"path":"notes/smarthome/smarthome_1/index.html","permalink":"https://blog.ajream.top/notes/smarthome/smarthome_1/","excerpt":"","text":"功能介绍 STM32单片机通过DHT11温湿度传感器采集温湿度 通过模数转换器ADC采集光敏电阻分压后的电压，然后转成光照强度 串口接收ESP8266的信息，提取出时间、天气信息，以及报警温度、最低光照信息（来自APP，用于控制蜂鸣器、led的开闭） 当室内温度超过报警温度时，蜂鸣器启动；当室内光照较暗（低于设定的最低光照）时，led点亮 总体框图如下： 具体实现 完整代码开源地址-Gitee 完整代码开源地址-Github 采集温度、湿度 123456789101112131415161718192021222324//从DHT11读取一次数据，存储到参数变量temp、humi中//temp:温度值(范围:0~50°)//humi:湿度值(范围:20%~90%)//返回值：0,正常;1,读取失败u8 DHT11_Read_Data(u8 *temp,u8 *humi) &#123; u8 buf[5]; u8 i; DHT11_Rst(); if(DHT11_Check()==0) &#123; for(i=0;i&lt;5;i++)//读取40位数据 &#123; buf[i]=DHT11_Read_Byte(); &#125; if((buf[0]+buf[1]+buf[2]+buf[3])==buf[4]) &#123; *humi=buf[0]; *temp=buf[2]; &#125; &#125;else return 1; return 0; &#125; color:green DHT11相关代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//DHT11初始化 //返回0：初始化成功，1：失败u8 DHT11_Init()&#123; GPIO_InitTypeDef GPIO_InitStructure; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOG,ENABLE); GPIO_InitStructure.GPIO_Pin=DHT11; GPIO_InitStructure.GPIO_Mode=GPIO_Mode_Out_PP; GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz; GPIO_Init(GPIO_DHT11,&amp;GPIO_InitStructure); GPIO_SetBits(GPIO_DHT11,DHT11); //拉高 DHT11_Rst(); return DHT11_Check(); &#125;//复位DHT11void DHT11_Rst() &#123; DHT11_IO_OUT(); //SET OUTPUT DHT11_DQ_OUT=0; //拉低DQ delay_ms(20); //拉低至少18ms DHT11_DQ_OUT=1; //DQ=1 delay_us(30); //主机拉高20~40us&#125;//等待DHT11的回应//返回1:未检测到DHT11的存在//返回0:存在u8 DHT11_Check() &#123; u8 retry=0; DHT11_IO_IN();//SET INPUT while (DHT11_DQ_IN&amp;&amp;retry&lt;100)//DHT11会拉低40~50us &#123; retry++; delay_us(1); &#125;; if(retry&gt;=100)return 1; else retry=0; while (!DHT11_DQ_IN&amp;&amp;retry&lt;100)//DHT11拉低后会再次拉高40~50us &#123; retry++; delay_us(1); &#125;; if(retry&gt;=100)return 1; return 0;&#125;12345678910111213141516171819202122232425262728293031323334//从DHT11读取一个位//返回值：1/0u8 DHT11_Read_Bit(void) &#123; u8 retry=0; while(DHT11_DQ_IN&amp;&amp;retry&lt;100)//等待变为低电平 12-14us 开始 &#123; retry++; delay_us(1); &#125; retry=0; while(!DHT11_DQ_IN&amp;&amp;retry&lt;100)//等待变高电平 26-28us表示0,116-118us表示1 &#123; retry++; delay_us(1); &#125; delay_us(40);//等待40us if(DHT11_DQ_IN)return 1; else return 0; &#125;//从DHT11读取一个字节//返回值：读到的数据u8 DHT11_Read_Byte(void) &#123; u8 i,dat; dat=0; for (i=0;i&lt;8;i++) &#123; dat&lt;&lt;=1; dat|=DHT11_Read_Bit(); &#125; return dat;&#125; 采集光照 通过ADC3模数转换器采集电压（为模拟量） 12345678910111213u8 Lsens_Get_Val(void)&#123; u32 temp_val=0; u8 t; for(t=0;t&lt;LSENS_READ_TIMES;t++) &#123; temp_val+=Get_ADC3(ADC_Channel_6); //读取ADC值 delay_ms(5); &#125; temp_val/=LSENS_READ_TIMES;//得到平均值 if(temp_val&gt;4000)temp_val=4000; return (u8)(100-(temp_val/40));&#125; color:green ADC3初始化及读取数据代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768//初始化光敏传感器void Lsens_Init(void)&#123; GPIO_InitTypeDef GPIO_InitStructure; ADC_InitTypeDef ADC_InitStructure; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOF,ENABLE);//使能PORTF时钟 RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC3, ENABLE ); //使能ADC3通道时钟 RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC3, ENABLE);//ADC复位 RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC3, DISABLE);//复位结束 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8;//PF8 anolog输入 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN; //模拟输入引脚 GPIO_Init(GPIOF, &amp;GPIO_InitStructure); ADC_DeInit(ADC3); //复位ADC3,将外设 ADC3的全部寄存器重设为缺省值 ADC_InitStructure.ADC_Mode = ADC_Mode_Independent; //ADC工作模式: 独立模式 ADC_InitStructure.ADC_ScanConvMode = DISABLE; //模数转换工作在单通道模式 ADC_InitStructure.ADC_ContinuousConvMode = DISABLE; //模数转换工作在单次转换模式 ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None; //转换由软件而不是外部触发启动 ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right; //ADC数据右对齐 ADC_InitStructure.ADC_NbrOfChannel = 1; //顺序进行规则转换的ADC通道的数目 ADC_Init(ADC3, &amp;ADC_InitStructure); //根据ADC_InitStruct中指定的参数初始化外设ADCx的寄存器 ADC_Cmd(ADC3, ENABLE); //使能指定的ADC3 ADC_ResetCalibration(ADC3); //使能复位校准 while(ADC_GetResetCalibrationStatus(ADC3)); //等待复位校准结束 ADC_StartCalibration(ADC3); //开启AD校准 while(ADC_GetCalibrationStatus(ADC3)); //等待校准结束&#125;//获得ADC3某个通道的值//ch:通道值 0~16//返回值:转换结果u16 Get_ADC3(u8 ch) &#123; //设置指定ADC的规则组通道，一个序列，采样时间 ADC_RegularChannelConfig(ADC3, ch, 1, ADC_SampleTime_239Cycles5 ); //ADC3,ADC通道,采样时间为239.5周期 ADC_SoftwareStartConvCmd(ADC3, ENABLE); //使能指定的ADC3的软件转换启动功能 while(!ADC_GetFlagStatus(ADC3, ADC_FLAG_EOC ));//等待转换结束 return ADC_GetConversionValue(ADC3); //返回最近一次ADC3规则组的转换结果&#125; //读取Light Sens的值//0~100:0,最暗;100,最亮 u8 Lsens_Get_Val(void)&#123; u32 temp_val=0; u8 t; for(t=0;t&lt;LSENS_READ_TIMES;t++) &#123; temp_val+=Get_ADC3(ADC_Channel_6); //读取ADC值 delay_ms(5); &#125; temp_val/=LSENS_READ_TIMES;//得到平均值 if(temp_val&gt;4000)temp_val=4000; return (u8)(100-(temp_val/40));&#125; 串口（USART2）获取数据 123456789101112131415161718192021222324252627282930313233343536char USART2_RX_BUF[RX_BUF_MAX_LEN];u16 USART2_RX_STA = 0; void USART2_IRQHandler(void)&#123; u8 r; if(USART_GetITStatus(USART2, USART_IT_RXNE) != RESET) //接收中断 &#123; r = USART_ReceiveData(USART2);//(USART2-&gt;DR); //读取接收到的数据 if((USART2_RX_STA&amp;0x8000)==0)//接收未完成 &#123; if(USART2_RX_STA&amp;0x4000)//接收到了0x0d(即&#x27;\\r&#x27;) &#123; if(r!=0x0a)USART2_RX_STA=0;//接收错误(即没有接收到&#x27;\\n&#x27;),重新开始 else &#123; //USART2_RX_STA|=0x8000; //接收完成了 (接收到&#x27;\\r&#x27;后接收到&#x27;\\n&#x27;) USART2_RX_STA = 0; //接收到\\n, 重新等待下一次接收 //PC_Usart(&quot;%s&quot;, USART2_RX_BUF); &#125; &#125; else //还没收到0X0D(即&#x27;\\r&#x27;) &#123; if(r==0x0d)USART2_RX_STA|=0x4000; //如果接收到\\r, 让USART2_RX_STA的14位置1 else &#123; USART2_RX_BUF[USART2_RX_STA&amp;0X3FFF]=r; USART2_RX_STA++; if(USART2_RX_STA&gt;(RX_BUF_MAX_LEN-1))USART2_RX_STA=0;//接收数据错误,重新开始接收 &#125; &#125; &#125; &#125; &#125; color:green USART2初始化等代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445void usart2_init( void )&#123; GPIO_InitTypeDef GPIO_InitStructure; USART_InitTypeDef USART_InitStructure; NVIC_InitTypeDef NVIC_InitStructure; RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE); RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE); RCC_APB2PeriphClockCmd( RCC_APB2Periph_GPIOA, ENABLE ); RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE); GPIO_PinRemapConfig(GPIO_Remap_SWJ_JTAGDisable,ENABLE); GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2; //PA2 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; //复用推挽输出 GPIO_Init(GPIOA, &amp;GPIO_InitStructure); GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3;//PA3 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;//浮空输入 GPIO_Init(GPIOA, &amp;GPIO_InitStructure);//初始化GPIOA //USART2 初始化设置 USART_InitStructure.USART_BaudRate = 115200;//串口波特率 USART_InitStructure.USART_WordLength = USART_WordLength_8b;//字长为8位数据格式 USART_InitStructure.USART_StopBits = USART_StopBits_1;//一个停止位 USART_InitStructure.USART_Parity = USART_Parity_No;//无奇偶校验位 USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;//无硬件数据流控制 USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx; //收发模式 USART_Init(USART2, &amp;USART_InitStructure); //初始化串口2 USART_ClearFlag(USART2, USART_FLAG_TC); USART_ITConfig(USART2, USART_IT_RXNE, ENABLE);//开启串口接受和总线空闲中断 //USART_ITConfig(USART2, USART_IT_IDLE, ENABLE); USART_Cmd(USART2, ENABLE); //使能串口2 //USART2 NVIC 配置 NVIC_InitStructure.NVIC_IRQChannel = USART2_IRQn; NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=3 ;//抢占优先级3 NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3; //子优先级3 NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; //IRQ通道使能 NVIC_Init(&amp;NVIC_InitStructure); //根据指定的参数初始化VIC寄存器&#125; 串口数据处理 提取时间、天气信息；为了方便，ESP8266发给STM32的数据都是用逗号隔开的，如 时间,天气,气温,湿度,…… 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778struct WeatherData processWdata3(char data[])&#123; //char data[] = &quot;2022-22-22 33:33:33,yin,47,48,&lt;=7&quot;; u8 i=0, j=0, i0=0, k=0; u8 ind=0, jnd=0; int slen = strlen(data); struct WeatherData weather; //初始化 for(ind=0; ind&lt;8; ind++)&#123; switch(ind)&#123; case 0: &#123; for(jnd=0; jnd&lt;20; jnd++)&#123; weather.datetime[jnd]=&#x27;\\0&#x27;; &#125; &#125;;break; case 1: &#123; for(jnd=0; jnd&lt;10; jnd++)&#123; weather.city[jnd]=&#x27;\\0&#x27;; &#125; &#125;;break; case 2: &#123; for(jnd=0; jnd&lt;10; jnd++)&#123; weather.humi[jnd]=&#x27;\\0&#x27;; &#125; &#125;;break; case 3: &#123; for(jnd=0; jnd&lt;10; jnd++)&#123; weather.temp[jnd]=&#x27;\\0&#x27;; &#125; &#125;;break; case 4: &#123; for(jnd=0; jnd&lt;10; jnd++)&#123; weather.weather[jnd]=&#x27;\\0&#x27;; &#125; &#125;;break; case 5: &#123; for(jnd=0; jnd&lt;10; jnd++)&#123; weather.windpower[jnd]=&#x27;\\0&#x27;; &#125; &#125;;break; case 6: &#123; for(jnd=0; jnd&lt;10; jnd++)&#123; minLsens_str[jnd]=&#x27;\\0&#x27;; &#125; &#125;;break; case 7: &#123; for(jnd=0; jnd&lt;10; jnd++)&#123; alarmTemp_str[jnd]=&#x27;\\0&#x27;; &#125; &#125;;break; &#125; &#125; strcpy(weather.city, &quot;西安&quot;); for(i=0; i&lt;slen; i++)&#123; if(data[i]==&#x27;,&#x27;) &#123; i0++; for(j=k; j&lt;i; j++)&#123; if(i0==1) weather.datetime[j-k]=data[j]; else if(i0==2) weather.weather[j-k]=data[j]; else if(i0==3) weather.temp[j-k]=data[j]; else if(i0==4) weather.humi[j-k]=data[j]; else if(i0==5) weather.windpower[j-k]=data[j]; else if(i0==6) alarmTemp_str[j-k]=data[j]; else if(i0==7) minLsens_str[j-k]=data[j]; &#125; k=i+1; &#125; &#125; return weather;&#125; 发送数据 通过定时器TIM2定时1s发送一次数据（json字符串格式）给ESP8266模块 12345678910void TIM2_IRQHandler(void)&#123; if(TIM_GetITStatus(TIM2, TIM_IT_Update) != RESET)&#123; ESP8266_Usart(&quot;&#123;\\&quot;temp\\&quot;:\\&quot;%d\\&quot;,\\&quot;humi\\&quot;:\\&quot;%d\\&quot;,\\&quot;light\\&quot;:\\&quot;%d\\&quot;,\\&quot;ledsta\\&quot;:\\&quot;%d\\&quot;,\\&quot;beepsta\\&quot;:\\&quot;%d\\&quot;&#125;\\r\\n&quot;, dhtData.temp, dhtData.humi, lsens, ledSta, beepSta);//输出【光照、温度、湿度、led、beep状态】到esp8266，再发送给手机 TIM_ClearITPendingBit(TIM2, TIM_IT_Update); &#125;&#125; color:green 初始化TIM2 12345678910111213141516171819202122232425//初始化TIM2void TIM2_init(u16 arr, u16 psc)&#123; TIM_TimeBaseInitTypeDef TIM_Structure; NVIC_InitTypeDef NVIC_Structure; RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE); //延时时间（单位:s）：arr/(72000000/psc) TIM_Structure.TIM_Period = arr - 1; //装载值 TIM_Structure.TIM_Prescaler = psc-1; //分频系数 TIM_Structure.TIM_ClockDivision = 0; TIM_Structure.TIM_CounterMode = TIM_CounterMode_Up; TIM_TimeBaseInit(TIM2, &amp;TIM_Structure); TIM_ITConfig(TIM2, TIM_IT_Update, ENABLE); //开启定时器TIM2中断 TIM_ClearITPendingBit(TIM2, TIM_IT_Update); NVIC_Structure.NVIC_IRQChannel = TIM2_IRQn; NVIC_Structure.NVIC_IRQChannelPreemptionPriority = 6; //抢占优先级 NVIC_Structure.NVIC_IRQChannelSubPriority = 4; //子优先级 NVIC_Structure.NVIC_IRQChannelCmd = ENABLE; NVIC_Init(&amp;NVIC_Structure); TIM_ClearFlag(TIM2, TIM_FLAG_Update); TIM_Cmd(TIM2, ENABLE);&#125; LED与蜂鸣器控制 1234567891011121314151617181920void ledBeepOnOrNot(u8 lsens, u8 mlsens, u8 t, u8 alarmT)&#123; //是否启动LED、BEEP if(lsens &lt; mlsens)&#123; LED1 = 0; //点亮 ledSta = 1; &#125; else&#123; LED1 = 1; //熄灭 ledSta = 0; &#125; if(t&gt;alarmT)&#123; BEEP=1; //叫 beepSta = 1; &#125; else&#123; BEEP=0; //不叫 beepSta = 0; &#125;&#125; 效果预览"},{"title":"","date":"2024-03-31T14:49:40.671Z","updated":"2024-03-31T14:49:40.671Z","comments":true,"path":"notes/smarthome/smarthome_2/index.html","permalink":"https://blog.ajream.top/notes/smarthome/smarthome_2/","excerpt":"","text":"介绍 在嵌入式课程作业中做了个智能家居的简单产品，用到了ESP8266的NodeMCU开发板和stm32开发板(程序后面介绍)，为了能够将采集的数据通过网络发布出去，这里采用了MQTT协议，服务端采用的是腾讯云MQTT服务 数据发布到服务器后，Android客户端可以向服务器订阅主题来获取到消息，然后进行展示。ESP8266客户端通过订阅也能获取到Android客户端发布的消息。 这是通信过程框图： 功能 连接WiFi 启动后led点亮，连接上MQTT服务端后闪烁，未连接常亮 通过网络获取如下信息 时间：使用苏宁易购的API 天气：使用高德地图的天气API（参数key要自己获取，city是城市编码） 与STM32通过串口进行数据通信 建立与MQTT服务器的连接 向服务器指定的主题发布消息和接收消息 json数据处理 完整代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301#include &lt;ESP8266WiFi.h&gt;#include &lt;PubSubClient.h&gt;#include &lt;ArduinoJson.h&gt;#include &lt;ESP8266HTTPClient.h&gt;#include &lt;WiFiManager.h&gt; //wifi配置const char* ssid = &quot;xxxxxx&quot;;const char* password = &quot;xxxxxxxx&quot;;//mqtt服务器连接配置const char *mqttBroker = &quot;xxxxxx.iotcloud.tencentdevices.com&quot;;const char *mqttUsername = &quot;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot;;const char *mqttPassword = &quot;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot;;char *mqttClientId = &quot;xxxxxxxxxxxesp8266&quot;;const char *pubTopic = &quot;xxxxxx/esp8266/data&quot;;const char *subTopic = &quot;xxxxxx/esp8266/data&quot;;const int mqttPort = 1883;WiFiClient wifiClient;PubSubClient mqttClient(wifiClient);struct Weather&#123; String wea=&quot;&quot;; String temp=&quot;&quot;; String windpower=&quot;&quot;; //风力,单位：级 String humi=&quot;&quot;;&#125;;struct ServerMsg&#123; String alarmTemp=&quot;&quot;; String minLight=&quot;&quot;;&#125;;//时间apiconst String timeUrl = &quot;http://quan.suning.com/getSysTime.do&quot;;//高德地图api(自己获取key, city是城市编码)const String gaoDeUrl = &quot;http://restapi.amap.com/v3/weather/weatherInfo?key=xxxxx&amp;city=610100&quot;;String timeMsg=&quot;&quot;;String weatherMsg=&quot;&quot;;String timeAfterParse=&quot;&quot;;struct Weather weatherAfterParse;String data2stm=&quot;&quot;; //打包后发送给stm32的信息String data2server=&quot;&quot;; //发布到mqtt服务器的信息String callHttp(String httpUrl);String parseJsonTime(String tjson);struct Weather parseJsonWeather(String wjson);void ledOnOff();String tqzh2py(String zhtq); //中文天气转拼音String windpowerFormat(String wp);void connectWifi();void setLedOnOff();void publishTopic(const char* topic, char* jsonMsg);void subscribeTopic(const char* topic);struct ServerMsg parseServerMsg(String jsonMsg);void getSerialDataAndProcess();void setup() &#123; pinMode(LED_BUILTIN, OUTPUT); // 设置板上LED引脚为输出模式 digitalWrite(LED_BUILTIN, LOW); // 启动后打开板上LED Serial.begin(115200); // 启动串口通讯 connectWifi(); mqttInit(); connectMqttServer(); timeMsg = callHttp(timeUrl); weatherMsg = callHttp(gaoDeUrl);&#125;struct ServerMsg serverMsgAfterParse;String serverMsg=&quot;&quot;;String stm32Msg=&quot;&quot;;int n = 0;void loop() &#123; delay(500); n++; //获取网络数据（时间、天气） if(n % 2 == 0)&#123; ledOnOff(); timeMsg = callHttp(timeUrl); if(n &gt;= 20)&#123; //10s获取一次天气 weatherMsg = callHttp(gaoDeUrl); n=0; &#125; &#125; //获取stm32数据，并发送到mqtt服务器 getSerialDataAndProcess(); //对网络获取到的数据处理 if(timeMsg!=&quot;&quot;)&#123; timeAfterParse = parseJsonTime(timeMsg); &#125; if(weatherMsg!=&quot;&quot;)&#123; weatherAfterParse = parseJsonWeather(weatherMsg); &#125; if(serverMsg!=&quot;&quot;)&#123; serverMsgAfterParse = parseServerMsg(serverMsg); &#125; //打包发送到stm32 if(timeMsg!=&quot;&quot; &amp;&amp; weatherMsg!=&quot;&quot;)&#123; data2stm = (timeAfterParse + &quot;,&quot; + tqzh2py(weatherAfterParse.wea) + &quot;,&quot; + weatherAfterParse.temp + &quot;,&quot; +weatherAfterParse.humi +&quot;,&quot; + windpowerFormat(weatherAfterParse.windpower) + &quot;,&quot; + serverMsgAfterParse.alarmTemp + &quot;,&quot; + serverMsgAfterParse.minLight + &quot;,&quot; + &quot;\\r\\n&quot;); //日期,天气,温度,湿度,风力等级,报警温度,最低光照 Serial.print(data2stm); &#125; if (mqttClient.connected()) &#123; // 如果开发板成功连接服务器 mqttClient.loop(); // 处理信息以及心跳 &#125; else &#123; // 如果开发板未能成功连接服务器 connectMqttServer(); // 则尝试连接服务器 &#125; &#125;void mqttInit()&#123; mqttClient.setServer(mqttBroker, mqttPort); // 设置MQTT订阅回调函数 mqttClient.setCallback(receiveCallback);&#125;// 连接MQTT服务器并订阅信息void connectMqttServer()&#123; while (!mqttClient.connected()) &#123; if (mqttClient.connect(mqttClientId, mqttUsername, mqttPassword)) &#123; subscribeTopic(subTopic); //订阅主题 &#125; else &#123; delay(2000);// Serial.println(&quot;连接失败&quot;); &#125; &#125; &#125;// 订阅指定主题void subscribeTopic(const char* topic)&#123; if(mqttClient.subscribe(topic))&#123; &#125; else &#123; &#125; &#125;// 收到信息后的回调函数void receiveCallback(char* topic, byte* payload, unsigned int length) &#123; serverMsg = &quot;&quot;; //当下次调用时清空数据 for (int i = 0; i &lt; length; i++) &#123;// Serial.print((char)payload[i]); serverMsg += (char)payload[i]; &#125;// Serial.println(&quot;\\n&quot;);// Serial.println(serverMsg);&#125;struct ServerMsg parseServerMsg(String jsonMsg)&#123; struct ServerMsg smsg; const size_t capacity = 96; DynamicJsonDocument sdoc(capacity); // 反序列化数据 deserializeJson(sdoc, jsonMsg); smsg.alarmTemp = sdoc[&quot;atemp&quot;].as&lt;String&gt;(); smsg.minLight = sdoc[&quot;mlight&quot;].as&lt;String&gt;(); return smsg;&#125;void publishTopic(const char* topic, char* jsonMsg)&#123; mqttClient.publish(topic, jsonMsg, false);&#125;void ledOnOff()&#123; static bool LEDState=0; if(mqttClient.connected())&#123; LEDState = !LEDState; //连上，led闪烁 &#125; else&#123; LEDState = 0; //没连上，led常亮 &#125; digitalWrite(LED_BUILTIN, LEDState);&#125;String callHttp(String httpUrl) &#123; HTTPClient hClient; String message; hClient.begin(httpUrl); int httpCode = hClient.GET(); if (httpCode &gt; 0) &#123; if (httpCode == HTTP_CODE_OK) &#123; String payload = hClient.getString(); message = payload; &#125; &#125; else &#123; message = &quot;[1-HTTP]failed, error:&quot; + String(hClient.errorToString(httpCode).c_str()); &#125; hClient.end(); return message;&#125;void getTimeMsg()&#123; timeMsg = callHttp(timeUrl);&#125;void getWeatherMsg()&#123; weatherMsg = callHttp(gaoDeUrl); &#125;String parseJsonTime(String tjson)&#123; const size_t capacity = 96; DynamicJsonDocument tdoc(capacity); // 反序列化数据 deserializeJson(tdoc, tjson); // 获取解析后的数据信息 String datetime = tdoc[&quot;sysTime2&quot;].as&lt;String&gt;(); return datetime;&#125;//&#123;&quot;status&quot;:&quot;1&quot;,&quot;count&quot;:&quot;1&quot;,&quot;info&quot;:&quot;OK&quot;,&quot;infocode&quot;:&quot;10000&quot;,&quot;lives&quot;:[&#123;&quot;province&quot;:&quot;陕西&quot;,&quot;city&quot;:&quot;西安市&quot;,&quot;adcode&quot;:&quot;610100&quot;,&quot;weather&quot;:&quot;晴&quot;,&quot;temperature&quot;:&quot;13&quot;,&quot;winddirection&quot;:&quot;北&quot;,&quot;windpower&quot;:&quot;≤3&quot;,&quot;humidity&quot;:&quot;88&quot;,&quot;reporttime&quot;:&quot;2021-10-29 21:03:10&quot;&#125;]&#125;struct Weather parseJsonWeather(String wjson)&#123; struct Weather weather; const size_t capacity = 512; DynamicJsonDocument wdoc(capacity); // 反序列化数据 deserializeJson(wdoc, wjson); JsonObject lives_0 = wdoc[&quot;lives&quot;][0]; weather.wea = lives_0[&quot;weather&quot;].as&lt;String&gt;(); // &quot;晴&quot; weather.temp = lives_0[&quot;temperature&quot;].as&lt;String&gt;(); // &quot;13&quot; weather.humi = lives_0[&quot;humidity&quot;].as&lt;String&gt;(); // &quot;88&quot; weather.windpower = lives_0[&quot;windpower&quot;].as&lt;String&gt;(); // &quot;≤3&quot; return weather;&#125;String tqzh2py(String zhtq)&#123; String zh_cn[68] = &#123;&quot;晴&quot;,&quot;少云&quot;,&quot;晴间多云&quot;,&quot;多云&quot;,&quot;阴&quot;,&quot;有风&quot;,&quot;平静&quot;,&quot;微风&quot;,&quot;和风&quot;,&quot;清风&quot;,&quot;强风/劲风&quot;,&quot;疾风&quot;,&quot;大风&quot;,&quot;烈风&quot;,&quot;风暴&quot;,&quot;狂爆风&quot;,&quot;飓风&quot;,&quot;热带风暴&quot;,&quot;霾&quot;,&quot;中度霾&quot;,&quot;重度霾&quot;,&quot;严重霾&quot;,&quot;阵雨&quot;,&quot;雷阵雨&quot;,&quot;雷阵雨并伴有冰雹&quot;,&quot;小雨&quot;,&quot;中雨&quot;,&quot;大雨&quot;,&quot;暴雨&quot;,&quot;大暴雨&quot;,&quot;特大暴雨&quot;,&quot;强阵雨&quot;,&quot;强雷阵雨&quot;,&quot;极端降雨&quot;,&quot;毛毛雨/细雨&quot;,&quot;雨&quot;,&quot;小雨-中雨&quot;,&quot;中雨-大雨&quot;,&quot;大雨-暴雨&quot;,&quot;暴雨-大暴雨&quot;,&quot;大暴雨-特大暴雨&quot;,&quot;雨雪天气&quot;,&quot;雨夹雪&quot;,&quot;阵雨夹雪&quot;,&quot;冻雨&quot;,&quot;雪&quot;,&quot;阵雪&quot;,&quot;小雪&quot;,&quot;中雪&quot;,&quot;大雪&quot;,&quot;暴雪&quot;,&quot;小雪-中雪&quot;,&quot;中雪-大雪&quot;,&quot;大雪-暴雪&quot;,&quot;浮尘&quot;,&quot;扬沙&quot;,&quot;沙尘暴&quot;,&quot;强沙尘暴&quot;,&quot;龙卷风&quot;,&quot;雾&quot;,&quot;浓雾&quot;,&quot;强浓雾&quot;,&quot;轻雾&quot;,&quot;大雾&quot;,&quot;特强浓雾&quot;,&quot;热&quot;,&quot;冷&quot;,&quot;未知&quot;,&#125;; String py[68] = &#123;&quot;qing&quot;,&quot;shaoyun&quot;,&quot;qingjianduoyun&quot;,&quot;duoyun&quot;,&quot;yin&quot;,&quot;youfeng&quot;,&quot;pingjing&quot;,&quot;weifeng&quot;,&quot;hefeng&quot;,&quot;qingfeng&quot;,&quot;qiangfeng/jinfeng&quot;,&quot;jifeng&quot;,&quot;dafeng&quot;,&quot;liefeng&quot;,&quot;fengbao&quot;,&quot;kuangbaofeng&quot;,&quot;jufeng&quot;,&quot;redaifengbao&quot;,&quot;mai&quot;,&quot;zhongdumai&quot;,&quot;zhongdumai&quot;,&quot;yanzhongmai&quot;,&quot;zhenyu&quot;,&quot;leizhenyu&quot;,&quot;leizhenyubingbanyoubingbao&quot;,&quot;xiaoyu&quot;,&quot;zhongyu&quot;,&quot;dayu&quot;,&quot;baoyu&quot;,&quot;dabaoyu&quot;,&quot;tedabaoyu&quot;,&quot;qiangzhenyu&quot;,&quot;qiangleizhenyu&quot;,&quot;jiduanjiangyu&quot;,&quot;maomaoyu/xiyu&quot;,&quot;yu&quot;,&quot;xiaoyu-zhongyu&quot;,&quot;zhongyu-dayu&quot;,&quot;dayu-baoyu&quot;,&quot;baoyu-dabaoyu&quot;,&quot;dabaoyu-tedabaoyu&quot;,&quot;yuxuetianqi&quot;,&quot;yujiaxue&quot;,&quot;zhenyujiaxue&quot;,&quot;dongyu&quot;,&quot;xue&quot;,&quot;zhenxue&quot;,&quot;xiaoxue&quot;,&quot;zhongxue&quot;,&quot;daxue&quot;,&quot;baoxue&quot;,&quot;xiaoxue-zhongxue&quot;,&quot;zhongxue-daxue&quot;,&quot;daxue-baoxue&quot;,&quot;fuchen&quot;,&quot;yangsha&quot;,&quot;shachenbao&quot;,&quot;qiangshachenbao&quot;,&quot;longjuanfeng&quot;,&quot;wu&quot;,&quot;nongwu&quot;,&quot;qiangnongwu&quot;,&quot;qingwu&quot;,&quot;dawu&quot;,&quot;teqiangnongwu&quot;,&quot;re&quot;,&quot;leng&quot;,&quot;weizhi&quot;&#125;; for(int i=0; i&lt;68; i++)&#123; // if(strstr()) if(zh_cn[i] == zhtq) return py[i]; &#125; return zhtq; //没有就返回中文&#125; String windpowerFormat(String wp)&#123; if(wp==&quot;≤3&quot;)&#123; return &quot;&lt;=3&quot;; &#125; return wp;&#125;//得到数据后处理方式,把它当作一个串口(伪)中断函数void getSerialDataAndProcess()&#123; if (Serial.available()) &#123; //串口读取到的转发到wifi，因为串口是一位一位的发送所以在这里缓存完再发送 size_t countBytes = Serial.available(); char sbuf[countBytes]; Serial.readBytes(sbuf, countBytes);// Serial.write(sbuf, countBytes); publishTopic(pubTopic, sbuf); Serial.flush(); &#125;&#125;void connectWifi()&#123; // WiFiManager wifiManager;// // 自动连接WiFi。以下语句的参数是连接ESP8266时的WiFi名称// wifiManager.autoConnect(&quot;IamESP8266&quot;); WiFi.mode(WIFI_STA); //WIFI_STA、WIFI_AP、WIFI_AP_STA WiFi.begin(ssid, password); while (WiFi.status() != WL_CONNECTED) &#123; delay(500); &#125;&#125; 在实现MQTT通信之前通过Socket与Android客户端进行通信，缺点是只能在同一个网络下（局域网）才能通信，这里也把代码呈上 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319#include &lt;ESP8266HTTPClient.h&gt;#include &lt;ArduinoJson.h&gt;#include &lt;ESP8266WiFi.h&gt;#include &lt;vector&gt;#include &lt;Ticker.h&gt;Ticker ticker;struct Weather&#123; String wea=&quot;&quot;; String temp=&quot;&quot;; String windpower=&quot;&quot;; //风力,单位：级 String humi=&quot;&quot;;&#125;;const char* ssid = &quot;xxxxx&quot;; const char* password = &quot;xxxxxx&quot;; const String timeUrl = &quot;http://quan.suning.com/getSysTime.do&quot;;const String gaoDeUrl = &quot;http://restapi.amap.com/v3/weather/weatherInfo?key=xxxxxx&amp;city=610100&quot;;String timeMsg=&quot;&quot;;String weatherMsg=&quot;&quot;;String timeAfterParse=&quot;&quot;;struct Weather weatherAfterParse;String data2stm=&quot;&quot;; //打包后发送给stm32的信息String data2client=&quot;&quot;; //发送给socket客户端的信息String callHttp(String httpUrl);String parseJsonTime(String tjson);struct Weather parseJsonWeather(String wjson);void led_on_off();String tqzh2py(String zhtq);//中文天气转拼音String windpowerFormat(String wp);void connectWIFI(char* ssid, char* password);void NewClient();void setLedOnOff(WiFiClient serverClient);void sendData2Client(WiFiClient serverClient, uint8_t sbuf[], int len);void receiveDataFromClient(WiFiClient serverClient);void getSerialDataAndProcess();WiFiServer server(5045); //端口号，随意修改，范围0-65535WiFiClient serverClient; //连接到服务器的客户端//初始化void setup() &#123; Serial.begin(115200); server.begin(); pinMode(2, OUTPUT); //设置内置LED引脚为输出模式 digitalWrite(2, LOW); connectWIFI(ssid, password);// ticker.attach(1, getTimeMsg);// ticker.attach(10, getWeatherMsg); timeMsg = callHttp(timeUrl); weatherMsg = callHttp(gaoDeUrl);&#125;String clientMsg=&quot;&quot;;String stm32Msg=&quot;&quot;;int n = 0;void loop() &#123; n++; NewClient(); setLedOnOff(serverClient); //指示灯提示是否连接到客户端 //get data from client, Internet timeMsg = callHttp(timeUrl); if(n &gt;= 12)&#123; //大概10s请求一次 //timeMsg = callHttp(timeUrl); weatherMsg = callHttp(gaoDeUrl); n=0; &#125; receiveDataFromClient(serverClient); //get data from stm32 and process getSerialDataAndProcess(); //data process if(timeMsg!=&quot;&quot;)&#123; timeAfterParse = parseJsonTime(timeMsg); &#125; if(weatherMsg!=&quot;&quot;)&#123; weatherAfterParse = parseJsonWeather(weatherMsg); &#125; //打包数据发到stm32 //data2stm += (clientMsg + &quot;,&quot;); if(timeMsg!=&quot;&quot; &amp;&amp; weatherMsg!=&quot;&quot;)&#123; data2stm = (timeAfterParse + &quot;,&quot; + tqzh2py(weatherAfterParse.wea) + &quot;,&quot; + weatherAfterParse.temp + &quot;,&quot; +weatherAfterParse.humi +&quot;,&quot; + windpowerFormat(weatherAfterParse.windpower) + &quot;,&quot; + clientMsg + &quot;,&quot; + &quot;\\r\\n&quot;); //日期,天气,温度,湿度,风力等级 Serial.print(data2stm);// if(n%6 == 0)&#123;// Serial.print(data2stm);// &#125; &#125; //data2stm=&quot;&quot;; //send data to stm32// if(n==5 &amp;&amp; data2stm!=&quot;&quot;)&#123;// Serial.print(&quot;data to stm: &quot; + data2stm);// &#125; // send data to client// if(stm32Msg!=&quot;&quot;)&#123;// data2client = stm32Msg;// sendData2Client(serverClient, data2client);// stm32Msg=&quot;&quot;;// &#125; //delay(100);&#125;void led_on_off()&#123; static bool LEDState=0; LEDState = !LEDState; digitalWrite(LED_BUILTIN, LEDState);&#125;String callHttp(String httpUrl) &#123; HTTPClient hClient; String message; hClient.begin(httpUrl); int httpCode = hClient.GET(); if (httpCode &gt; 0) &#123; if (httpCode == HTTP_CODE_OK) &#123; String payload = hClient.getString(); message = payload; &#125; &#125; else &#123; message = &quot;[1-HTTP]failed, error:&quot; + String(hClient.errorToString(httpCode).c_str()); &#125; hClient.end(); return message;&#125;void getTimeMsg()&#123; timeMsg = callHttp(timeUrl);&#125;void getWeatherMsg()&#123; weatherMsg = callHttp(gaoDeUrl); &#125;String parseJsonTime(String tjson)&#123; const size_t capacity = 96; DynamicJsonDocument tdoc(capacity); // 反序列化数据 deserializeJson(tdoc, tjson); // 获取解析后的数据信息 String datetime = tdoc[&quot;sysTime2&quot;].as&lt;String&gt;(); return datetime;&#125;//&#123;&quot;status&quot;:&quot;1&quot;,&quot;count&quot;:&quot;1&quot;,&quot;info&quot;:&quot;OK&quot;,&quot;infocode&quot;:&quot;10000&quot;,&quot;lives&quot;:[&#123;&quot;province&quot;:&quot;陕西&quot;,&quot;city&quot;:&quot;西安市&quot;,&quot;adcode&quot;:&quot;610100&quot;,&quot;weather&quot;:&quot;晴&quot;,&quot;temperature&quot;:&quot;13&quot;,&quot;winddirection&quot;:&quot;北&quot;,&quot;windpower&quot;:&quot;≤3&quot;,&quot;humidity&quot;:&quot;88&quot;,&quot;reporttime&quot;:&quot;2021-10-29 21:03:10&quot;&#125;]&#125;struct Weather parseJsonWeather(String wjson)&#123; struct Weather weather; const size_t capacity = 512; DynamicJsonDocument wdoc(capacity); // 反序列化数据 deserializeJson(wdoc, wjson); JsonObject lives_0 = wdoc[&quot;lives&quot;][0]; weather.wea = lives_0[&quot;weather&quot;].as&lt;String&gt;(); // &quot;晴&quot; weather.temp = lives_0[&quot;temperature&quot;].as&lt;String&gt;(); // &quot;13&quot; weather.humi = lives_0[&quot;humidity&quot;].as&lt;String&gt;(); // &quot;88&quot; weather.windpower = lives_0[&quot;windpower&quot;].as&lt;String&gt;(); // &quot;≤3&quot; return weather;&#125;String tqzh2py(String zhtq)&#123; String zh_cn[68] = &#123;&quot;晴&quot;,&quot;少云&quot;,&quot;晴间多云&quot;,&quot;多云&quot;,&quot;阴&quot;,&quot;有风&quot;,&quot;平静&quot;,&quot;微风&quot;,&quot;和风&quot;,&quot;清风&quot;,&quot;强风/劲风&quot;,&quot;疾风&quot;,&quot;大风&quot;,&quot;烈风&quot;,&quot;风暴&quot;,&quot;狂爆风&quot;,&quot;飓风&quot;,&quot;热带风暴&quot;,&quot;霾&quot;,&quot;中度霾&quot;,&quot;重度霾&quot;,&quot;严重霾&quot;,&quot;阵雨&quot;,&quot;雷阵雨&quot;,&quot;雷阵雨并伴有冰雹&quot;,&quot;小雨&quot;,&quot;中雨&quot;,&quot;大雨&quot;,&quot;暴雨&quot;,&quot;大暴雨&quot;,&quot;特大暴雨&quot;,&quot;强阵雨&quot;,&quot;强雷阵雨&quot;,&quot;极端降雨&quot;,&quot;毛毛雨/细雨&quot;,&quot;雨&quot;,&quot;小雨-中雨&quot;,&quot;中雨-大雨&quot;,&quot;大雨-暴雨&quot;,&quot;暴雨-大暴雨&quot;,&quot;大暴雨-特大暴雨&quot;,&quot;雨雪天气&quot;,&quot;雨夹雪&quot;,&quot;阵雨夹雪&quot;,&quot;冻雨&quot;,&quot;雪&quot;,&quot;阵雪&quot;,&quot;小雪&quot;,&quot;中雪&quot;,&quot;大雪&quot;,&quot;暴雪&quot;,&quot;小雪-中雪&quot;,&quot;中雪-大雪&quot;,&quot;大雪-暴雪&quot;,&quot;浮尘&quot;,&quot;扬沙&quot;,&quot;沙尘暴&quot;,&quot;强沙尘暴&quot;,&quot;龙卷风&quot;,&quot;雾&quot;,&quot;浓雾&quot;,&quot;强浓雾&quot;,&quot;轻雾&quot;,&quot;大雾&quot;,&quot;特强浓雾&quot;,&quot;热&quot;,&quot;冷&quot;,&quot;未知&quot;,&#125;; String py[68] = &#123;&quot;qing&quot;,&quot;shaoyun&quot;,&quot;qingjianduoyun&quot;,&quot;duoyun&quot;,&quot;yin&quot;,&quot;youfeng&quot;,&quot;pingjing&quot;,&quot;weifeng&quot;,&quot;hefeng&quot;,&quot;qingfeng&quot;,&quot;qiangfeng/jinfeng&quot;,&quot;jifeng&quot;,&quot;dafeng&quot;,&quot;liefeng&quot;,&quot;fengbao&quot;,&quot;kuangbaofeng&quot;,&quot;jufeng&quot;,&quot;redaifengbao&quot;,&quot;mai&quot;,&quot;zhongdumai&quot;,&quot;zhongdumai&quot;,&quot;yanzhongmai&quot;,&quot;zhenyu&quot;,&quot;leizhenyu&quot;,&quot;leizhenyubingbanyoubingbao&quot;,&quot;xiaoyu&quot;,&quot;zhongyu&quot;,&quot;dayu&quot;,&quot;baoyu&quot;,&quot;dabaoyu&quot;,&quot;tedabaoyu&quot;,&quot;qiangzhenyu&quot;,&quot;qiangleizhenyu&quot;,&quot;jiduanjiangyu&quot;,&quot;maomaoyu/xiyu&quot;,&quot;yu&quot;,&quot;xiaoyu-zhongyu&quot;,&quot;zhongyu-dayu&quot;,&quot;dayu-baoyu&quot;,&quot;baoyu-dabaoyu&quot;,&quot;dabaoyu-tedabaoyu&quot;,&quot;yuxuetianqi&quot;,&quot;yujiaxue&quot;,&quot;zhenyujiaxue&quot;,&quot;dongyu&quot;,&quot;xue&quot;,&quot;zhenxue&quot;,&quot;xiaoxue&quot;,&quot;zhongxue&quot;,&quot;daxue&quot;,&quot;baoxue&quot;,&quot;xiaoxue-zhongxue&quot;,&quot;zhongxue-daxue&quot;,&quot;daxue-baoxue&quot;,&quot;fuchen&quot;,&quot;yangsha&quot;,&quot;shachenbao&quot;,&quot;qiangshachenbao&quot;,&quot;longjuanfeng&quot;,&quot;wu&quot;,&quot;nongwu&quot;,&quot;qiangnongwu&quot;,&quot;qingwu&quot;,&quot;dawu&quot;,&quot;teqiangnongwu&quot;,&quot;re&quot;,&quot;leng&quot;,&quot;weizhi&quot;&#125;; for(int i=0; i&lt;68; i++)&#123; // if(strstr()) if(zh_cn[i] == zhtq) return py[i]; &#125; return zhtq; //没有就返回中文&#125; String windpowerFormat(String wp)&#123; if(wp==&quot;≤3&quot;)&#123; return &quot;&lt;=3&quot;; &#125; return wp;&#125;void connectWIFI(const char* ssid, const char* password) &#123; WiFi.mode(WIFI_STA); //WIFI_STA、WIFI_AP、WIFI_AP_STA WiFi.begin(ssid, password); while (WiFi.status() != WL_CONNECTED) &#123; delay(500); &#125;&#125;//检测新的clientvoid NewClient() &#123; uint8_t i=0; //检测是否有新的client请求进来 if (server.hasClient()) &#123; //释放旧无效或者断开的client if (!serverClient || !serverClient.connected()) &#123; if (serverClient) &#123; serverClient.stop(); &#125; //分配最新的client serverClient = server.available(); //Serial.print(&quot;New client: &quot;); //Serial.print(i); i=1; &#125; if(i==1)&#123; //当达到最大连接数 无法释放无效的client，需要拒绝连接 WiFiClient serverClient = server.available(); serverClient.stop(); //Serial.println(&quot;Connection rejected &quot;); &#125; &#125;&#125;//客户端连接时常亮，无连接时闪烁void setLedOnOff(WiFiClient serverClient) &#123; //连接情况 用led灯的状态显示 if(serverClient.connected())&#123; digitalWrite(2, LOW); delay(800); &#125; else&#123; digitalWrite(2, HIGH); delay(400); digitalWrite(2, LOW); delay(400); &#125;&#125;//接收客户端的数据void receiveDataFromClient(WiFiClient serverClient) &#123; uint8_t buffLen=0; char buff[100]; if (serverClient &amp;&amp; serverClient.connected()) &#123;// while (serverClient.available())&#123;// r[i] = serverClient.read();// i++;// &#125;// if (serverClient.read() == -1)&#123;// Serial.printf(&quot;%s&quot;, r);// &#125; if(serverClient.available())&#123; buffLen = serverClient.available(); serverClient.readBytes(buff, buffLen); //Serial.write(buff, buffLen); //Serial.printf(&quot;\\r\\nbufflen: %d\\r\\n&quot;, buffLen); serverClient.flush(); clientMsg = &quot;&quot;; for(uint8_t i=2; i&lt;buffLen; i++)&#123; //i=2表示舍弃客户端发送的第一个字符（安卓客户端在数据开头会发送一个特殊字符，由于是UTF-8编码方式，占用2Bytes） clientMsg += (buff[i]); &#125; //Serial.println(&quot;msg: &quot;+ clientMsg); &#125; //else Serial.println(&quot;--------------------&quot;); &#125;&#125;void sendData2Client(WiFiClient serverClient, char data[], uint8_t len) &#123; //len为字节数 if (serverClient &amp;&amp; serverClient.connected()) &#123; serverClient.write(data, len); //将数据发送给客户端// Serial.write(sbuf, len); delay(200); &#125;&#125;//得到数据后处理方式,把它当作一个串口(伪)中断函数void getSerialDataAndProcess()&#123; if (Serial.available()) &#123; //串口读取到的转发到wifi，因为串口是一位一位的发送所以在这里缓存完再发送 size_t countBytes = Serial.available(); char sbuf[countBytes]; Serial.readBytes(sbuf, countBytes);// Serial.write(sbuf, countBytes); sendData2Client(serverClient, sbuf, countBytes); Serial.flush(); &#125;&#125;"},{"title":"","date":"2024-03-31T14:49:40.671Z","updated":"2024-03-31T14:49:40.671Z","comments":true,"path":"notes/smarthome/smarthome_3/index.html","permalink":"https://blog.ajream.top/notes/smarthome/smarthome_3/","excerpt":"","text":"MQTT服务端 我做的这个App是作为MQTT的一个客户端，因此必须要有一个MQTT服务端来让它连接上，之后就可以发布、订阅消息了；有一些公共MQTT服务器（可以自行百度），我在腾讯云创建了一个自己的MQTT服务端，下面介绍如何创建。 登录腾讯云。进入控制台，在搜索框搜索”物联网通信“ 点击创建新产品（可以把产品理解为一个MQTT服务器），我之前已经创建过一些了，所以下面显示有几个产品 填写相关信息 然后点击自己刚新建的产品，进入创建一个新设备 我们的物理设备要连接刚新建的”MQTT服务器“，需要提供一些验证信息，这些信息在我们新建设备之后可以得到 点击我们刚新建的设备，可以查看设备的信息，其中设备密钥是我们的物理设备连接时需要的信息 下面用桌面软件MQTT.fx尝试连接，打开软件，如左图： 5/6/7步需要自己刚才新建的产品、设备密钥信息，根据官方文档，如右图： 123Broker Address: [产品ID].iotcloud.tencentdevices.comBroker Port: 1883或8883Client ID: 产品ID+设备名 （也可以直接复制新建设备时设备密钥的Client ID） 产品ID 设备密钥 接下来填写用户信息，然后点击ok保存即可 填写信息 查看自己设备的用户名、密码信息（最后2个就是） 接下来可以进行订阅和发布主题了，首先点击connect连接 主题不能随便填，首先回到腾讯云刚新建的设备，点击设备进去，默认提供3个主题，其中2个一个只能发布，一个只能订阅，只有一个既能发布也能订阅，当然，可以自己新建几个主题，根据自己需要 把发布主题粘贴到MQTT.fx软件，就可以发布主题了，发布后在产品（不是设备）的云日志可以查看刚发布的内容 订阅也是这样，订阅后需要在腾讯云 设备界面选择在线调试，然后选择MQTT.fx订阅的主题，发送消息后MQTT.fx即可收到消息，此处不演示 Android MQTT客户端 代码工程已开源，GitHub请点击前去下载，Gitee请点击前去下载 使用Android Studio（自行百度下载），新建一个空白工程 添加MQTT依赖 在自己[project]下的 build.gradle添加如下代码 12345678repositories &#123; google() mavenCentral() //添加下面这句代码 maven &#123; url &quot;https://repo.eclipse.org/content/repositories/paho-releases/&quot; &#125; &#125; 在[project]/app下的build.gradle添加如下代码 1234dependencies &#123; compile &#x27;org.eclipse.paho:org.eclipse.paho.android.service:1.1.1&#x27; compile &#x27;org.eclipse.paho:org.eclipse.paho.client.mqttv3:1.1.1&#x27;&#125; 然后选择顶部弹出的 Sync Now 信息 撸代码 修改AndroidManifest.xml，添加权限 1234&lt;!--允许程序打开网络套接字--&gt;&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&lt;!--允许程序获取网络状态--&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt; 修改视图文件activity_main.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; &gt; &lt;TextView android:layout_marginTop=&quot;20dp&quot; android:layout_marginLeft=&quot;20dp&quot; android:layout_marginBottom=&quot;10dp&quot; android:id=&quot;@+id/house_env&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;室内环境&quot; android:textStyle=&quot;bold&quot; android:textSize=&quot;20dp&quot; /&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;TextView android:id=&quot;@+id/show_temp&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;10dp&quot; android:layout_marginLeft=&quot;20dp&quot; android:layout_marginBottom=&quot;10dp&quot; android:text=&quot;温度(°C)&quot; android:textSize=&quot;20dp&quot; /&gt; &lt;TextView android:id=&quot;@+id/temp&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;10dp&quot; android:layout_marginLeft=&quot;20dp&quot; android:layout_marginBottom=&quot;10dp&quot; android:text=&quot;0&quot; android:textSize=&quot;20dp&quot; /&gt; &lt;TextView android:id=&quot;@+id/show_humi&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;10dp&quot; android:layout_marginLeft=&quot;20dp&quot; android:layout_marginBottom=&quot;10dp&quot; android:text=&quot;湿度(%RH)&quot; android:textSize=&quot;20dp&quot; /&gt; &lt;TextView android:id=&quot;@+id/humi&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;10dp&quot; android:layout_marginLeft=&quot;20dp&quot; android:layout_marginBottom=&quot;10dp&quot; android:text=&quot;0&quot; android:textSize=&quot;20dp&quot; /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; &gt; &lt;TextView android:id=&quot;@+id/show_light&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginLeft=&quot;20dp&quot; android:layout_marginTop=&quot;10dp&quot; android:layout_marginBottom=&quot;10dp&quot; android:text=&quot;光照强度&quot; android:textSize=&quot;20dp&quot; /&gt; &lt;TextView android:id=&quot;@+id/light&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginLeft=&quot;20dp&quot; android:layout_marginTop=&quot;10dp&quot; android:layout_marginBottom=&quot;10dp&quot; android:text=&quot;0&quot; android:textSize=&quot;20dp&quot; /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;TextView android:id=&quot;@+id/ledsta1&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginLeft=&quot;20dp&quot; android:layout_marginTop=&quot;10dp&quot; android:layout_marginBottom=&quot;10dp&quot; android:text=&quot;LED状态&quot; android:textSize=&quot;20dp&quot; /&gt; &lt;TextView android:id=&quot;@+id/ledsta2&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginLeft=&quot;20dp&quot; android:layout_marginTop=&quot;10dp&quot; android:layout_marginBottom=&quot;10dp&quot; android:text=&quot;关&quot; android:textSize=&quot;20dp&quot; /&gt; &lt;TextView android:id=&quot;@+id/beepsta1&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginLeft=&quot;20dp&quot; android:layout_marginTop=&quot;10dp&quot; android:layout_marginBottom=&quot;10dp&quot; android:text=&quot;蜂鸣器状态&quot; android:textSize=&quot;20dp&quot; /&gt; &lt;TextView android:id=&quot;@+id/beepsta2&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginLeft=&quot;20dp&quot; android:layout_marginTop=&quot;10dp&quot; android:layout_marginBottom=&quot;10dp&quot; android:text=&quot;关&quot; android:textSize=&quot;20dp&quot; /&gt; &lt;/LinearLayout&gt; &lt;TextView android:id=&quot;@+id/sets&quot; android:layout_column=&quot;1&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginLeft=&quot;20dp&quot; android:layout_marginTop=&quot;10dp&quot; android:layout_marginBottom=&quot;10dp&quot; android:text=&quot;设置&quot; android:textStyle=&quot;bold&quot; android:textSize=&quot;20dp&quot; /&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;TextView android:id=&quot;@+id/set_temp&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginLeft=&quot;20dp&quot; android:layout_marginTop=&quot;10dp&quot; android:layout_marginBottom=&quot;10dp&quot; android:text=&quot;报警温度(当前温度超过该值蜂鸣器将报警)&quot; android:textSize=&quot;15dp&quot; /&gt; &lt;TextView android:id=&quot;@+id/seekbarval1&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;10dp&quot; android:layout_marginLeft=&quot;10dp&quot; android:text=&quot;40&quot;/&gt; &lt;/LinearLayout&gt; &lt;SeekBar android:id=&quot;@+id/seekBar1&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;10dp&quot; android:layout_marginBottom=&quot;10dp&quot; android:layout_gravity=&quot;center&quot; android:max=&quot;100&quot; android:progress=&quot;40&quot;/&gt;&lt;!-- android:progressDrawable=&quot;@drawable/seekbar_progress&quot; /&gt;--&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;TextView android:id=&quot;@+id/set_tlight&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginLeft=&quot;20dp&quot; android:layout_marginTop=&quot;10dp&quot; android:layout_marginBottom=&quot;10dp&quot; android:text=&quot;最低光照(当前光照小于该值将点亮led灯)&quot; android:textSize=&quot;15dp&quot; /&gt; &lt;TextView android:id=&quot;@+id/seekbarval2&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;10dp&quot; android:layout_marginLeft=&quot;20dp&quot; android:text=&quot;12&quot;/&gt; &lt;/LinearLayout&gt; &lt;SeekBar android:id=&quot;@+id/seekBar2&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;10dp&quot; android:layout_marginBottom=&quot;10dp&quot; android:layout_gravity=&quot;center&quot; android:max=&quot;100&quot; android:progress=&quot;12&quot;/&gt;&lt;!-- android:progressDrawable=&quot;@drawable/seekbar_progress2&quot; /&gt;--&gt; &lt;LinearLayout android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; &gt; &lt;Button android:layout_marginLeft=&quot;100dp&quot; android:layout_marginTop=&quot;20dp&quot; android:id=&quot;@+id/connectbtn&quot; android:layout_height=&quot;wrap_content&quot; android:layout_width=&quot;wrap_content&quot; android:textColor=&quot;@color/white&quot; android:text=&quot;连接&quot;/&gt; &lt;Button android:layout_marginTop=&quot;20dp&quot; android:layout_marginRight=&quot;20dp&quot; android:layout_marginLeft=&quot;20dp&quot; android:id=&quot;@+id/exitbtn&quot; android:layout_height=&quot;wrap_content&quot; android:layout_width=&quot;wrap_content&quot; android:textColor=&quot;@color/white&quot; android:text=&quot;退出&quot;/&gt; &lt;/LinearLayout&gt; &lt;TextView android:layout_margin=&quot;5dp&quot; android:id=&quot;@+id/msgTxt&quot; android:layout_height=&quot;wrap_content&quot; android:layout_width=&quot;wrap_content&quot; android:scrollbars=&quot;vertical&quot; android:text=&quot;&quot;/&gt;&lt;/LinearLayout&gt; 效果图 接下来修改MainActivity.java，添加控制操作，上面只是完成一个界面的创建 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288package com.ajream.mqttdemo4;import android.annotation.SuppressLint;import android.os.Bundle;import android.os.Handler;import android.os.Message;import android.widget.Button;import android.widget.SeekBar;import android.widget.TextView;import android.widget.Toast;import androidx.appcompat.app.AppCompatActivity;import org.eclipse.paho.client.mqttv3.IMqttDeliveryToken;import org.eclipse.paho.client.mqttv3.MqttCallback;import org.eclipse.paho.client.mqttv3.MqttClient;import org.eclipse.paho.client.mqttv3.MqttConnectOptions;import org.eclipse.paho.client.mqttv3.MqttException;import org.eclipse.paho.client.mqttv3.MqttMessage;import org.eclipse.paho.client.mqttv3.persist.MemoryPersistence;import org.json.JSONException;import org.json.JSONObject;import java.util.concurrent.Executors;import java.util.concurrent.ScheduledExecutorService;import java.util.concurrent.TimeUnit;public class MainActivity extends AppCompatActivity &#123; //定义成员 private Button connectbtn; private Button exitbtn; private TextView temptv; private TextView humitv; private TextView lighttv; private TextView ledtv; private TextView beeptv; private TextView bar1tv; private TextView bar2tv; private TextView showmsgtv; private SeekBar tempbar; private SeekBar lightbar; //MQTT客户端配置所需信息 private String host = &quot;tcp://xxxxxxx.iotcloud.tencentdevices.com:1883&quot;; //mqtt服务器（腾讯云）地址、端口 private String userName = &quot;xxxxxxxxxx&quot;; //用户名（在腾讯云查看自己的设备信息） private String passWord = &quot;xxxxxxxxxx&quot;; //密码（在腾讯云查看自己的设备信息） private String mqtt_id = &quot;xxxxxxxxxxxxxxxxxxx&quot;; private String mqtt_sub_topic = &quot;xxxxxxxxxx/AndroidClient/data&quot;; private String mqtt_pub_topic = &quot;xxxxxxxxxx/AndroidClient/data&quot;; private ScheduledExecutorService scheduler; private MqttClient mqttClient; private MqttConnectOptions options; private Handler handler; private String msgToPublish = &quot;&quot;; //要发布的消息 private String alarmTempMsg = &quot;&quot;; private String minLightMsg = &quot;&quot;; JSONObject msgGet; @SuppressLint(&quot;HandlerLeak&quot;) @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //关联控件 connectbtn = findViewById(R.id.connectbtn); exitbtn = findViewById(R.id.exitbtn); temptv = findViewById(R.id.temp); humitv = findViewById(R.id.humi); lighttv = findViewById(R.id.light); ledtv = findViewById(R.id.ledsta2); beeptv = findViewById(R.id.beepsta2); bar1tv = findViewById(R.id.seekbarval1); bar2tv = findViewById(R.id.seekbarval2); showmsgtv = findViewById(R.id.msgTxt); tempbar = findViewById(R.id.seekBar1); lightbar = findViewById(R.id.seekBar2); alarmTempMsg = String.valueOf(tempbar.getProgress()); minLightMsg = String.valueOf(lightbar.getProgress()); /*点击按钮连接*/ connectbtn.setOnClickListener(view -&gt; &#123; Mqtt_init(); startReconnect(); &#125;); exitbtn.setOnClickListener(view -&gt; &#123; android.os.Process.killProcess(android.os.Process.myPid()); &#125;); tempbar.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() &#123; @Override public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) &#123; Toast.makeText(MainActivity.this, &quot;设置报警温度为: &quot; + progress, Toast.LENGTH_LONG).show(); bar1tv.setText(check(progress)); alarmTempMsg = check(progress); &#125; @Override public void onStartTrackingTouch(SeekBar seekBar) &#123; &#125; @Override public void onStopTrackingTouch(SeekBar seekBar) &#123;// msgToPublish = alarmTempMsg + &quot;,&quot; + minLightMsg; msgToPublish = &quot;&#123;\\&quot;atemp\\&quot;:\\&quot;&quot; + alarmTempMsg + &quot;\\&quot;,\\&quot;mlight\\&quot;:\\&quot;&quot; + minLightMsg+&quot;\\&quot;&#125;&quot;; publishMsg(mqtt_pub_topic, msgToPublish); &#125; &#125;); lightbar.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() &#123; @Override public void onProgressChanged(SeekBar seekBar, int i, boolean b) &#123; Toast.makeText(MainActivity.this, &quot;设置最低光照为: &quot; + i, Toast.LENGTH_LONG).show(); bar2tv.setText(check(i)); minLightMsg = check(i); &#125; @Override public void onStartTrackingTouch(SeekBar seekBar) &#123; &#125; @Override public void onStopTrackingTouch(SeekBar seekBar) &#123; msgToPublish = &quot;&#123;\\&quot;atemp\\&quot;:\\&quot;&quot; + alarmTempMsg + &quot;\\&quot;,\\&quot;mlight\\&quot;:\\&quot;&quot; + minLightMsg+&quot;\\&quot;&#125;&quot;; publishMsg(mqtt_pub_topic, msgToPublish); &#125; &#125;); handler = new Handler() &#123; @SuppressLint(&quot;SetTextI18n&quot;) public void handleMessage(Message msg) &#123; super.handleMessage(msg); switch (msg.what) &#123; case 1: //开机校验更新回传 break; case 2: // 反馈回传 break; case 3: //MQTT 收到消息回传 UTF8Buffer msg=newUTF8Buffer(object.toString());// Toast.makeText(MainActivity.this,msg.obj.toString(),Toast.LENGTH_SHORT).show(); showmsgtv.setText(msg.obj.toString()); JSONObject msgGet = null; try &#123; msgGet = new JSONObject(msg.obj.toString()); temptv.setText(msgGet.get(&quot;temp&quot;).toString()); humitv.setText(msgGet.get(&quot;humi&quot;).toString()); lighttv.setText(msgGet.get(&quot;light&quot;).toString()); if(Integer.parseInt(msgGet.get(&quot;ledsta&quot;).toString())==0) ledtv.setText(&quot;关&quot;); else ledtv.setText(&quot;开&quot;); if(msgGet.get(&quot;beepsta&quot;).toString().charAt(0)==&#x27;0&#x27;) beeptv.setText(&quot;关&quot;); else beeptv.setText(&quot;开&quot;); &#125; catch (JSONException e) &#123; e.printStackTrace(); &#125; break; case 30: //连接失败 Toast.makeText(MainActivity.this,&quot;连接失败&quot; ,Toast.LENGTH_SHORT).show(); break; case 31: //连接成功 Toast.makeText(MainActivity.this,&quot;连接成功&quot; ,Toast.LENGTH_SHORT).show(); try &#123; mqttClient.subscribe(mqtt_sub_topic,1); &#125; catch (MqttException e) &#123; e.printStackTrace(); &#125; break; default: break; &#125; &#125; &#125;; &#125; private String check(int progress) &#123; int curValue = 100 * progress/Math.abs(100); return String.valueOf(curValue); &#125; private void publishMsg(String topic, String message2) &#123; if (mqttClient == null || !mqttClient.isConnected()) &#123; return; &#125; MqttMessage message = new MqttMessage(); message.setPayload(message2.getBytes()); try &#123; mqttClient.publish(topic, message); &#125; catch (MqttException e) &#123; e.printStackTrace(); &#125; &#125; private void Mqtt_init() &#123; try &#123; //host为主机名，test为clientid即连接MQTT的客户端ID，一般以客户端唯一标识符表示，MemoryPersistence设置clientid的保存形式，默认为以内存保存 mqttClient = new MqttClient(host, mqtt_id, new MemoryPersistence()); //MQTT的连接设置 options = new MqttConnectOptions(); //设置是否清空session,这里如果设置为false表示服务器会保留客户端的连接记录，这里设置为true表示每次连接到服务器都以新的身份连接 options.setCleanSession(false); options.setUserName(userName); //设置连接的用户名 options.setPassword(passWord.toCharArray()); //设置连接的密码 // 设置超时时间 单位为秒 options.setConnectionTimeout(10); // 设置会话心跳时间 单位为秒 服务器会每隔1.5*20秒的时间向客户端发送个消息判断客户端是否在线，但这个方法并没有重连的机制 options.setKeepAliveInterval(20); //设置回调函数 mqttClient.setCallback(new MqttCallback() &#123; @Override public void connectionLost(Throwable cause) &#123; //连接丢失后，一般在这里面进行重连// System.out.println(&quot;connectionLost----------&quot;);// startReconnect(); &#125; @Override public void deliveryComplete(IMqttDeliveryToken token) &#123; //publish后会执行到这里 System.out.println(&quot;deliveryComplete---------&quot; + token.isComplete()); &#125; @Override public void messageArrived(String topicName, MqttMessage message) throws Exception &#123; //subscribe后得到的消息会执行到这里面 System.out.println(&quot;getMsg: &quot;); Message msg = new Message(); msg.what = 3; //收到消息标志位 msg.obj = message.toString(); handler.sendMessage(msg); // hander 回传 &#125; &#125;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; private void Mqtt_connect() &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; if(!(mqttClient.isConnected())) &#123; mqttClient.connect(options); Message msg = new Message(); msg.what = 31; handler.sendMessage(msg); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); Message msg = new Message(); msg.what = 30; handler.sendMessage(msg); &#125; &#125; &#125;).start(); &#125; private void startReconnect() &#123; scheduler = Executors.newSingleThreadScheduledExecutor(); scheduler.scheduleAtFixedRate(new Runnable() &#123; @Override public void run() &#123; if (!mqttClient.isConnected()) &#123; Mqtt_connect(); &#125; &#125; &#125;, 0 * 1000, 10 * 1000, TimeUnit.MILLISECONDS); &#125;&#125; 来两张运行截图"},{"title":"","date":"2024-03-31T14:49:40.671Z","updated":"2024-03-31T14:49:40.671Z","comments":true,"path":"notes/stm32/stm32_1/index.html","permalink":"https://blog.ajream.top/notes/stm32/stm32_1/","excerpt":"","text":"MDK Keil卸载packs 比如我要卸载包：STM32F4XXX 打开MDK keil5软件，点击图中箭头所指的选项 在左边选择devices，搜索 “stm32”,然后选择 重启mdk keil5即可"},{"title":"","date":"2024-03-31T14:49:40.671Z","updated":"2024-03-31T14:49:40.671Z","comments":true,"path":"notes/stm32/stm32_10/index.html","permalink":"https://blog.ajream.top/notes/stm32/stm32_10/","excerpt":"","text":"复用与重映射 在芯片原理图上经常可以看到GPIO端口后边接很长一串，比如PA2/USART2_TX/ADC123_IN2/TIM5_CH3/TIM2_CH3，意思就是PA2引脚除了可以作为简单的I/O输入输出电平，还可以有复用功能，可以复用为USART2_TX、ADC123_IN2……。 从原理图来看，比如PA2，可以作为USART2的发送端，也可以作为ADC123_IN2/TIM5_CH3/TIM2_CH3端来使用 因此，这就是复用，即某个GPIO可以被多个设备使用，但同时只能被一个设备使用，因此如果这个GPIO被某个设备占用了怎么办，莫慌，一个外设除了可以默认使用这个GPIO外，还可以使用其它GPIO，这就是接下来要讲的重映射 在stm32中外设太多了，因此如果这个外设默认使用的引脚被其它外设占用了，那就使用其它引脚，这就是重映射。 比如USART2，默认是使用PA2、PA3的，但如果这两个引脚被占用了（被其它设备使用了），就可以重映射到其它引脚，重映射到哪个引脚，这要查表（在《STM32F1xx中文参考手册》8.3中有），人家已经规定好重映射时可以使用哪个引脚，比如USART2的TX和RX端可以重映射到PD5、PD6 总结：复用和重映射是同一个概念，只是对于GPIO来说是复用，对于外设来说是重映射 另外，从外设的角度来看，某些外设的重映射分为三种 不使用重映射 使用部分重映射 使用完全重映射 也就是说，某些外设可以关联到三种不同的GPIO，具体看你想要用以上的哪一种重映射方案。以定时器3输出PWM信号为例，其不同通道映射到不同的GPIO引脚，如图： 假如想要使用通道2生成PWM信号，这时可以选择通过PA7/PB5/PC7进行输出，接下来如果想要通过PB5进行输出，就要对定时器3采用【部分重映射】方案，具体如何通过代码配置，看下面最后的一部分。 常用外设的重映射功能，点击查看 如何使用重映射 如上面所说，当某个外设的默认使用的GPIO被占用了，就可以重映射到其它GPIO，那么如何使用呢，继续以定时器3为例，主要分为以下几步： 查看手册，了解自己想要使用的外设都可以映射到哪些GPIO引脚，比如定时器3的CH2通道 开启GPIOx时钟，开启外设时钟，打开AFIO时钟，配置外设的重映射方案，配置GPIO的输出模式为 GPIO_Mode_AF_PP 【假如使用PB5（即部分重映射）进行输出】 12345678910RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE); // 使能GPIOB时钟RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE); // 使能定时器3时钟RCC_APB1PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE); // 使能AFIO时钟(好像有些情况可以不打开，本人不太清除，具体还得查手册，不过开了也没事)GPIO_PinRemapConfig(GPIO_PartialRemap_TIM3, ENABLE); // 对TIM3使用【部分重映射】GPIO_InitTypeDef GPIO_InitStructure;GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; //复用推挽输出GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;GPIO_Init(GPIOB, &amp;GPIO_InitStructure); 【假如使用PA7（即不使用重映射）进行输出】 12345678910RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); // 使能GPIOA时钟RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE); // 使能定时器3时钟// RCC_APB1PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE); // 不使用重映射不需要开启// GPIO_PinRemapConfig(GPIO_PartialRemap_TIM3, ENABLE); // 【不使用重映射】就不需要配置重映射方案GPIO_InitTypeDef GPIO_InitStructure;GPIO_InitStructure.GPIO_Pin = GPIO_Pin_7;GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; //复用推挽输出（注意，只要是外设的输出都要使用GPIO_Mode_AF_PP，即便没有使用重映射）GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;GPIO_Init(GPIOA, &amp;GPIO_InitStructure); 【假如使用PC7（使用完全重映射）进行输出】 12345678910RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE); // 使能GPIOC时钟RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE); // 使能定时器3时钟RCC_APB1PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE); // 开启AFIO时钟GPIO_PinRemapConfig(GPIO_FullRemap_TIM3, ENABLE); // 配置重映射方案GPIO_InitTypeDef GPIO_InitStructure;GPIO_InitStructure.GPIO_Pin = GPIO_Pin_7;GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; //复用推挽输出GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;GPIO_Init(GPIOC, &amp;GPIO_InitStructure); 再举个例子，配置USART2的重映射 查阅手册，发现只有2种映射方案，默认（不重映射时）通过PA2发送，PA3接收，这里我们选择通过PD5发送，PD6接收 打开GPIO时钟，打开USART2外设时钟，打开AFIO时钟，配置外设的重映射方案，配置GPIO的输出模式为 GPIO_Mode_AF_PP 只需要打开AFIO时钟和相应外设(例如USART2)的重映射功能即可，如： 123456789101112131415RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOD, ENABLE); // 使能GPIOD时钟RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE); //使能 AFIO 时钟RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE); //使能USART2时钟GPIO_PinRemapConfig(GPIO_Remap_USART2, ENABLE); // 开启重映射（不重映射也不需要这行代码），由于只有2种重映射方案，因此名称中不含Partial或Full // 配置PD5GPIO_InitTypeDef GPIO_InitStructure;GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; //复用推挽输出GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;GPIO_Init(GPIOD, &amp;GPIO_InitStructure);//配置PD6，只需要改引脚，其它不变GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;GPIO_Init(GPIOD, &amp;GPIO_InitStructure); 禁用重映射功能 有些引脚在系统复位后就被某些外设专用，即默认只能被这些设备使用，但有时不想用这些设备，于是可以禁用这些设备的重映射功能，释放相关的GPIO，这时这些GPIO就变成普通IO了 比如禁用JTAG-DP调试接口: 1GPIO_PinRemapConfig(GPIO_Remap_SWJ_Disable, ENABLE);"},{"title":"","date":"2024-03-31T14:49:40.675Z","updated":"2024-03-31T14:49:40.675Z","comments":true,"path":"notes/stm32/stm32_11/index.html","permalink":"https://blog.ajream.top/notes/stm32/stm32_11/","excerpt":"","text":"相关概念介绍 USART与UART USART(通用同步/异步收发器)是STM32系列微控制器内部集成的UART模块 并行和串行通信 并行：各个位同时在不同的数据线上进行数据传输 串行：各个位一位位在同一根数据线上进行数据传输 单工、半双工、双工 单工：数据只能单向传输，一端发送、一端接收（设备只有发送端或者接收端） 半双工：数据在同一根线上可以双向传输，但同一时间内数据只能单向传输 双工：同一时间内数据可以双向传输（两根线，每个设备都有发送端和接收端） 同步与异步 串行通信又可以分为同步、异步方式 同步：发送和接收方之间使用共同的时钟从而使他们的通信保持协调，因此发送和接收端需要额外的一根时钟线进行相连 异步：发送端和接收端不存在共同的时钟。在异步通信中，数据以指定的格式打包成帧进行传输，并在一个数据帧的开头和结尾使用起始位和停止位来实现收发的协调。起始位和停止位用于告诉接收端数据帧的开头和结尾。由于多了起始位和停止位，异步传输速率远低于同步传输速率。 UART通信原理 UART物理层 UART UART接口 这里介绍异步串行全双工通信的UART接口，所以最简单的UART设备需要有3个接口（TXD、RXD、GND，没有时钟接口），两个UART设备之间互联方式如下图。如果需要实现更复杂的功能，需要增加更多接口（如CTS、RTS） UART电平 UART电平采用TTL/CMOS的逻辑电平标准（0~5V, 0~3.3V, 0~2.5V, 0~1.8V表示数据），1表示高电平，0表示低电平。例如在TTL电平标准中，1通常表示+5V, 0 通常表示0V RS232 UART采用的电平标准决定了它的通信距离较短，因此为了增加传输距离，产生了RS232，RS232是在UART的基础上扩展产生的，PC机上的COM口就是RS232的应用实例。 RS232接口 通常采用DB-25或者DB-9的形式，目前以DB-9（使用9根线）最为常见 RS232电平 RS232采用负逻辑：-3V~-15V表示逻辑1，+3V~+15V表示逻辑0；这样的好处是可以降低信号因传输距离远带来的衰减 UART接口要与RS232接口连接，需要采用电平转换芯片 UART协议层 数据格式 UART通过一定格式将数据打包成帧，包括 起始位（必须，占1位） 数据位（必须，占5~8位） 校验位（可选，占0/1位） 停止位（必须，占1/1.5/2位） 空闲位（数据传输完毕，线路保持逻辑电平1，即空闲状态）等 传输速率 UART双方必须约定使用相同的传输速率进行发送和接收 传输速率可以用比特率（单位bps，kbps等）或波特率来表示，由于UART使用NRZ（不归零）编码，所以其波特率与比特率是相同的。常用UART的传输速率有：1200、2400、4800、9600、19200、38400、115200……（单位bps） STM32的UART工作原理 color:blue 内部结构 主要特性 全双工的，异步通信 NRZ标准格式 分数波特率发生器系统 发送和接收共用的可编程波特率，最高达4.5Mbits/s 可编程数据字长度(8位或9位) 可配置的停止位 支持1或2个停止位 智能卡模拟功能 智能卡接口支持ISO7816-3标准里定义的异步智能卡协议 智能卡用到的0.5和1.5个停止位 单线半双工通信 可配置的使用DMA的多缓冲器通信 ─ 在SRAM里利用集中式DMA缓冲接收/发送字节 单独的发送器和接收器使能位 检测标志 接收缓冲器满 发送缓冲器空 传输结束标志 校验控制 ─ 发送校验位 ─ 对接收数据进行校验 四个错误检测标志 溢出错误 噪音错误 帧错误 校验错误 10个带标志的中断源 ─ CTS改变 ─ LIN断开符检测 ─ 发送数据寄存器空 ─ 发送完成 ─ 接收数据寄存器满 ─ 检测到总线为空闲 ─ 溢出错误 ─ 帧错误 ─ 噪音错误 ─ 校验错误 多处理器通信 – 如果地址不匹配，则进入静默模式 从静默模式中唤醒(通过空闲总线检测或地址标志检测) 两种唤醒接收器的方式：地址位(MSB，第9位)，总线空闲 USART功能 接口通过三个引脚与其他设备连接在一起(见内部结构图)。 任何USART双向通信至少需要两个脚：接收数据输入(RX)和发送数据输出(TX)。 RX：接收数据串行输。通过过采样技术来区别数据和噪音，从而恢复数据。 TX：发送数据输出。 当发送器被禁止时，输出引脚恢复到它的I/O端口配置。 当发送器被激活， 并且不发送数据时，TX引脚处于高电平。（在单线和智能卡模式里，此I/O口被同时用于数据的发送和接收） 总线在发送或接收前应处于空闲状态 一个起始位 一个数据字(8或9位)，最低有效位在前 0.5，1.5，2个的停止位，由此表明数据帧的结束 使用分数波特率发生器 —— 12位整数和4位小数的表示方法。 一个状态寄存器(USART_SR) 数据寄存器(USART_DR) 一个波特率寄存器(USART_BRR)，12位的整数和4位小数 一个智能卡模式下的保护时间寄存器(USART_GTPR) 在同步模式中需要下列引脚： CK：发送器时钟输出。此引脚输出用于同步传输的时钟， (在Start位和Stop位上没有时钟 脉冲，软件可选地，可以在最后一个数据位送出一个时钟脉冲)。数据可以在RX上同步被接收。这可以用来控制带有移位寄存器的外部设备(例如LCD驱动器)。时钟相位和极性都是软件可编程的。在智能卡模式里，CK可以为智能卡提供时钟。 在IrDA模式里需要下列引脚： IrDA_RDI: IrDA模式下的数据输入。 IrDA_TDO: IrDA模式下的数据输出。 下列引脚在硬件流控模式中需要： nCTS: 清除发送，若是高电平，在当前数据传输结束时阻断下一次的数据发送 nRTS: 发送请求，若是低电平，表明USART准备好接收数据 波特率控制 通过改变USART外设的时钟源(不同的USART挂载的APB总线可能不同)的分频系数USARTDIV可以设置USART的波特率 收发控制 由若干寄存器组成，如CR1,CR2,CR3,USART状态寄存器（SR）等，通过向寄存器写入各种参数来控制USART数据的发送和接收；同时，通过读取状态寄存器可以查询USART当前状态 数据存储转移 核心为两个移位寄存器：发送移位寄存器、接收移位寄存器，用于收发数据同时完成并串转换 发送数据过程 发送数据时，先将数据从内存写入发送数据寄存器TDR，发送控制器适时的把数据从TDR中加载到发送移位寄存器，再通过TX端发送出去 当数据全部从TDR中转移出去后，会产生TDR已空的事件TXE；当数据移位寄存器将数据全部发送到TX后，产生发送完成事件TC。这些事件可以在状态寄存器查到。 接收数据过程 接收数据时，数据从RX端一位位输入到接收移位寄存器，然后接收控制器将移位寄存器的数据转移至接收数据寄存器RDR，最后内核指令或DMA将RDR的数据读取进内存中。 当数据全部从接收移位寄存器转移至RDR寄存器后，产生接收寄存器RDR非空或RDR已满事件RXNE 数据传输整个过程如下： USART中断 发送期间 中断事件包括 TXE(发送数据寄存器空) TC(发送完成) CTS(清除发送) 接收期间 IDLE(空闲总线检测) ORE(溢出错误) RXNE(接收数据寄存器非空) PE(校验错误) LBD(LIN断开检测) NE(噪声错误，仅在多缓冲器通信) FE(帧错误，仅在多缓冲器通信) 使用USART进行通信 初始化USART GPIO初始化（输出模式为推挽输出，输入模式为浮空输入，速率50MHz） USART基本配置 波特率，数据位数，奇偶校验，停止位数，工作模式，硬件数据流控制 清除标志、使能USART、开启相关中断 中断向量配置（中断通道配置——监听哪个外设产生的中断，优先级配置，使能通道） 12345678910111213141516171819202122232425262728293031323334353637383940414243void USART1_Init(u32 bound)&#123; //GPIO端口设置 GPIO_InitTypeDef GPIO_InitStructure; USART_InitTypeDef USART_InitStructure; NVIC_InitTypeDef NVIC_InitStructure; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE); ////使能 GPIOA 时钟 RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1,ENABLE); //使能 USART1时钟 /*配置GPIO的模式和IO口 */ GPIO_InitStructure.GPIO_Pin=GPIO_Pin_9; // 串口输出 PA9&lt;-&gt;TX GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz; GPIO_InitStructure.GPIO_Mode=GPIO_Mode_AF_PP; // 复用推挽输出 GPIO_Init(GPIOA,&amp;GPIO_InitStructure); // 初始化串口输出 GPIO_InitStructure.GPIO_Pin=GPIO_Pin_10; // 串口输入 PA10&lt;-&gt;RX GPIO_InitStructure.GPIO_Mode=GPIO_Mode_IN_FLOATING; //浮空输入 GPIO_Init(GPIOA, &amp;GPIO_InitStructure); // 初始化串口输入 //USART1 初始化设置 USART_InitStructure.USART_BaudRate = bound;//波特率设置 USART_InitStructure.USART_WordLength = USART_WordLength_8b;//字长为8位数据格式 USART_InitStructure.USART_StopBits = USART_StopBits_1;//一个停止位 USART_InitStructure.USART_Parity = USART_Parity_No;//无奇偶校验位 USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;//无硬件数据流控制 USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx; //收发模式 USART_Init(USART1, &amp;USART_InitStructure); //初始化串口1 USART_Cmd(USART1, ENABLE); //使能串口1 USART_ClearFlag(USART1, USART_FLAG_TC); USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);//开启相关中断 //Usart1 NVIC 配置 NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;//串口1中断通道 NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=3;//抢占优先级3 NVIC_InitStructure.NVIC_IRQChannelSubPriority =3; //子优先级3 NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; //IRQ通道使能 NVIC_Init(&amp;NVIC_InitStructure); //根据指定的参数初始化VIC寄存器、 &#125; 中断处理 判断该外设产生的中断类型（这里是接收到数据产生的中断RXNE） 数据处理 1234567891011void USART1_IRQHandler()&#123; u8 r; if(USART_GetITStatus(USART1,USART_IT_RXNE) != RESET)&#123; //如果产生接收中断RXNE r = USART_ReceiveData(USART1); //(USART1-&gt;DR); 读取接收到的数据（一个字符） USART_SendData(USART1, r); //发送数据 while(USART_GetFlagStatus(USART1, USART_FLAG_TC) != SET); //标志位TC==1时（表示发送完成）退出循环 USART_ClearFlag(USART1, USART_FLAG_CTS); //清除中断标志 &#125;&#125; 解释： 12345u8 r; //用于存储接收到的数据，因为每次接收的数据是8位的，所以r大小也是8位r = USART_ReceiveData(USART1); //每次只能接收一个字符，若发送多个字符，会依次发送每个字符，每次发送一个字符都会产生一次USART1中断USART_SendData(USART1, r); //发送数据时也是一个个字符发送 main函数 初始化USART； 12345678int main()&#123; USART1_Init(115200); //初始化完成后，USART1等待接收数据，接收到数据后产生中断RXNE，执行中断处理函数 while(1)&#123; &#125;&#125; printf重定向 用printf函数将变量的值通过串口打印到pc机的串口调试工具的接收区 首先要重写 fputc函数 123456int fputc(int ch, FILE *p)&#123; USART_SendData(USART1,(u8)ch); while(USART_GetFlagStatus(USART1, USART_FLAG_TXE) == RESET); //发送寄存器空标志TXE，数据全部发送后被置1，导致循环停止 return ch;&#125; 这样就能使用 printf函数将数据通过USART1发送到pc机进行查看变量的值了，例如 12345678910int main()&#123; char str[] = &quot;我是str&quot;; USART1_Init(115200); printf(&quot;打印字符串str：%s\\n1234&quot;, str); while(1)&#123; &#125;&#125; 打印在串口调试器接收区："},{"title":"","date":"2024-03-31T14:49:40.675Z","updated":"2024-03-31T14:49:40.675Z","comments":true,"path":"notes/stm32/stm32_12/index.html","permalink":"https://blog.ajream.top/notes/stm32/stm32_12/","excerpt":"","text":"ADC相关介绍 基本原理：采样、量化、编码 性能参数： 量程： 允许输入模拟电压的范围 分辨率：所能检测到最小的模拟输入量 精度：对于ADC的数字输出，实际需要的模拟输入值与理论上需要的模拟输入值之差（比如模拟输入值为1.95，假设转为数字量【量化】后为2，理论上需要模拟输入值为2，所以误差是0.05） 转换时间：ADC完成一次A/D转换所需要的时间，包括从启动开始到获得相应数据所需要的总时间（转换时间=采样时间+量化和编码时间） ADC主要类型： 逐次逼近型 电压时间转换型（V-T）：模拟电压信号转为与之成正比的时间宽度信号，然后在这个时间宽度内对固定频率的时钟脉冲计数，计数结果就是转化后的输出的数字信号 电压频率转换型（V-F）：模拟电压信号转为与之成正比的频率信号，然后在固定的时间间隔内对得到的频率信号计数，计数结果即输出的数字量 ADC工作原理 ADC特性 stm32f103微控制器内部集成1~3个12位逐次逼近型ADC，主要特性如下： 每个ADC最多有18路模拟输入通道，可测量16个外部信号（ADCx_IN0~ADCx_IN15），2个内部信号 18路通道可分为规则通道组（最多包含16路）和注入通道组（最多包含4路），仅有规则通道组可以产生DMA请求 供电要求：2.4V~3.6V 模拟输入信号Vin要求：Vref- &lt;= Vin &lt;= Vref+(Vref-, Vref+分别是负极和正极的参考电压) 工作模式： 单次（单次转换模式下，ADC只执行一次转换） 连续（连续转换模式中，当前面ADC转换一结束马上就启动另一次转换） 扫描（扫描多路通道） 间断 转换结束后，以左对齐或者右对齐方式存入16位数据寄存器，同时产生中断请求（ADC1、ADC3还可以产生DMA请求） 系统时钟为56MHz时，ADC时钟为14MHz，采样时间为1.5个ADC时钟周期，ADC获得最短转换时间为1us color:blue 内部结构 ADC通道及分组 输入通道 ADC的信号输入就是通过通道来实现的，信号通过通道输入到单片机中，单片机经过转换后，将模拟信号输出为数字信号。STM32中的ADC有着18个通道，其中外部的16个通道已经在框图中标出，如下： 这16个通道对应着不同的IO口，此外ADC1/2/3 还有内部通道： ADC1 的通道 16 连接到了芯片内部的温度传感器， Vrefint 连接到了通道 17。 ADC2 的模拟通道 16 和 17 连接到了内部的 VSS。 外部的16个通道在转换时又分为规则通道和注入通道，其中规则通道最多有16路，注入通道最多有4路（注入通道貌似使用不多），下面简单介绍一下俩种通道： 规则通道 规则通道顾名思义就是，最平常的通道、也是最常用的通道，通常的ADC转换都是用规则通道实现的。 注入通道 注入通道是相对于规则通道的，注入通道可以在规则通道转换时，强行插入转换，相当于一个“中断通道”。当有注入通道需要转换时，规则通道的转换会停止，优先执行注入通道的转换，当注入通道的转换执行完毕后，再回到之前规则通道进行转换。 转换顺序 知道了ADC的转换通道后，如果ADC只使用一个通道来转换，那就很简单，但如果是使用多个通道进行转换就涉及到一个先后顺序了，毕竟规则转换通道只有一个数据寄存器。多个通道的使用顺序分为俩种情况：规则通道的转换顺序和注入通道的转换顺序。 color:blue 规则通道转换顺序 规则通道中的转换顺序由三个寄存器控制：SQR1、SQR2、SQR3，它们都是32位寄存器。SQR寄存器控制着转换通道的数目和转换顺序，只要在对应的寄存器位SQx中写入相应的通道，这个通道就是第x个转换。具体的对应关系如下：通过SQR1寄存器就能了解其转换顺序在寄存器上的实现 color:blue 注入通道转换顺序 和规则通道转换顺序的控制一样，注入通道的转换也是通过注入寄存器来控制，只不过只有一个JSQR寄存器来控制，控制关系如下：需要注意的是，只有当JL=4的时候，注入通道的转换顺序才会按照JSQ1、JSQ2、JSQ3、JSQ4的顺序执行。当JL&lt;4时，注入通道的转换顺序恰恰相反，也就是执行顺序为：JSQ4、JSQ3、JSQ2、JSQ1。 触发源 ADC转换的输入、通道、转换顺序都已经说明了，但ADC转换是怎么触发的呢？就像通信协议一样，都要规定一个起始信号才能传输信息，ADC也需要一个触发信号来实行模/数转换。 通过直接配置寄存器触发，通过配置控制寄存器CR2的ADON位，写1时开始转换，写0时停止转换。在程序运行过程中只要调用库函数，将CR2寄存器的ADON位置1就可以进行转换，比较好理解。 还可以通过内部定时器或者外部IO触发转换，也就是说可以利用内部时钟让ADC进行周期性的转换，也可以利用外部IO使ADC在需要时转换，具体的触发由控制寄存器CR2决定。 ADC_CR2寄存器的详情如下： color:blue 展开 转换时间 ADC的每一次信号转换都要时间，这个时间就是转换时间，转换时间由输入时钟和采样周期来决定。 输入时钟 由于ADC在STM32中是挂载在APB2总线上的，所以ADC得时钟是由PCLK2（72MHz）经过分频得到的，分频因子由 RCC 时钟配置寄存器RCC_CFGR 的位 15:14 ADCPRE[1:0]设置，可以是 2/4/6/8 分频，一般配置分频因子为8，即8分频得到ADC的输入时钟频率为9MHz。 采样周期 采样周期是确立在输入时钟上的，配置采样周期可以确定使用多少个ADC时钟周期来对电压进行采样，采样的周期数可通过 ADC采样时间寄存器 ADC_SMPR1 和 ADC_SMPR2 中的 SMP[2:0]位设置，ADC_SMPR2 控制的是通道 0~9， ADC_SMPR1 控制的是通道 10~17。每个通道可以配置不同的采样周期，但最小的采样周期是1.5个周期，也就是说如果想最快时间采样就设置采样周期为1.5. 转换时间 转换时间 = 采样时间 + 12.5个周期 12.5个周期是固定的，一般我们设置 PCLK2=72M，经过 ADC 预分频器能分频到最大的时钟只能是 12M，采样周期设置为 1.5 个周期，算出最短的转换时间为 1.17us。 数据寄存器 转换完成后的数据就存放在数据寄存器中，但数据的存放也分为规则通道转换数据和注入通道转换数据的。 规则数据寄存器 规则数据寄存器负责存放规则通道转换的数据，通过32位寄存器ADC_DR来存放。 当使用ADC独立模式（也就是只使用一个ADC，可以使用多个通道）时，数据存放在低16位中，当使用ADC多模式时高16位存放ADC2的数据。需要注意的是ADC转换的精度是12位，而寄存器中有16个位来存放数据，所以要规定数据存放是左对齐还是右对齐。 左对齐：数据存放在16位中的左边12位，（右边）低4位补0 右对齐：高（左边）4位补0，右边12位填采集到的数据 当使用多个通道转换数据时，会产生多个转换数据，然鹅数据寄存器只有一个，多个数据存放在一个寄存器中会覆盖数据导致ADC转换错误，所以我们经常在一个通道转换完成之后就立刻将数据取出来，方便下一个数据存放。一般开启DMA模式将转换的数据，传输在一个数组中，程序对数组读操作就可以得到转换的结果。 注入数据寄存器 注入通道转换的数据寄存器有4个，由于注入通道最多有4个，所以注入通道转换的数据都有固定的存放位置，不会跟规则寄存器那样产生数据覆盖的问题。 ADC_JDRx 是 32 位的，低 16 位有效，高 16 位保留，数据同样分为左对齐和右对齐，具体是以哪一种方式存放，由ADC_CR2 的 11 位 ALIGN 设置。 数据转换完成 从框图中可以知道数据转换完成之后可以产生中断，有三种情况： 规则通道转换完成中断 规则通道数据转换完成之后，可以产生一个中断，可以在中断函数中读取规则数据寄存器的值。这也是单通道时读取数据的一种方法。 注入通道转换完成中断 注入通道数据转换完成之后，可以产生一个中断，并且也可以在中断中读取注入数据寄存器的值，达到读取数据的作用。 模拟看门狗事件 当输入的模拟量（电压）不再阈值范围内就会产生看门狗事件，就是用来监视输入的模拟量是否正常。 以上中断的配置都由ADC_SR寄存器决定： 当然，在转换完成之后也可以产生DMA请求，从而将转换好的数据从数据寄存器中读取到内存中。 电压转换 要知道，转换后的数据是一个12位的二进制数，我们需要把这个二进制数代表的模拟量（电压）用数字表示出来。 比如测量的电压范围是0~3.3V，转换后的二进制数是x，因为12位ADC在转换时将电压的范围大小（也就是3.3）分为4096（2^12）份，所以转换后的二进制数x代表的真实电压的计算方法就是： y = 3.3 * x / 4096 ADC用法 初始化结构体 123456789typedef struct&#123; uint32_t ADC_Mode; // ADC 工作模式选择 FunctionalState ADC_ScanConvMode; // ADC 扫描（多通道）或者单次（单通道）模式选择 FunctionalState ADC_ContinuousConvMode; // ADC 单次转换或者连续转换选择 uint32_t ADC_ExternalTrigConv; // ADC 转换触发信号选择 uint32_t ADC_DataAlign; // ADC 数据寄存器对齐格式 uint8_t ADC_NbrOfChannel; // ADC 采集通道数 &#125; ADC_InitTypeDef; 例如： 123456789101112131415161718192021222324252627282930313233343536void Adc_Init(void)&#123; ADC_InitTypeDef ADC_InitStructure; GPIO_InitTypeDef GPIO_InitStructure; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA |RCC_APB2Periph_ADC1, ENABLE ); //使能ADC1通道时钟 RCC_ADCCLKConfig(RCC_PCLK2_Div6); //设置ADC分频因子6 72M/6=12,ADC最大时间不能超过14M GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1; //PA1 作为模拟通道输入引脚 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN; //模拟输入引脚 GPIO_Init(GPIOA, &amp;GPIO_InitStructure); ADC_DeInit(ADC1); //复位ADC1 ADC_InitStructure.ADC_Mode = ADC_Mode_Independent; //ADC工作模式:ADC1和ADC2工作在独立模式 ADC_InitStructure.ADC_ScanConvMode = DISABLE; //模数转换工作在单通道模式 ADC_InitStructure.ADC_ContinuousConvMode = DISABLE; //模数转换工作在单次转换模式 ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None; //转换由软件而不是外部触发启动 ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right; //ADC数据右对齐 ADC_InitStructure.ADC_NbrOfChannel = 1; //顺序进行规则转换的ADC通道的数目 ADC_Init(ADC1, &amp;ADC_InitStructure); //初始化外设ADC1 ADC_Cmd(ADC1, ENABLE); //使能指定的ADC1 ADC_ResetCalibration(ADC1); //使能复位校准 while(ADC_GetResetCalibrationStatus(ADC1)); //等待复位校准结束 ADC_StartCalibration(ADC1); //开启AD校准 while(ADC_GetCalibrationStatus(ADC1)); //等待校准结束 // ADC_SoftwareStartConvCmd(ADC1, ENABLE); //使能指定的ADC1的软件转换启动功能&#125;"},{"title":"","date":"2024-03-31T14:49:40.675Z","updated":"2024-03-31T14:49:40.675Z","comments":true,"path":"notes/stm32/stm32_2/index.html","permalink":"https://blog.ajream.top/notes/stm32/stm32_2/","excerpt":"","text":"固件库介绍 STM32 标准函数库，由 ST 公司针对 STM32 提供的函数接口，即API(Application Program Interface)，开发者可调用这些函数接口来配置STM32的寄存器，使开发人员得以脱离最底层的寄存器操作，有开发快速，易于阅读，维护成本低等优点。 下载 建议去官网搜索下载最新版 下载（第一次下载需要输入邮箱，然后会发来一封邮件，点击邮件的链接进行下载） 下载完成随便找个位置进行解压即可，后面建立工程时要使用的话再把其中的文件复制到我们自己的工程即可 体系架构 这是解压后固件库的目录结构 体系架构： 用户层 用户层位于架构的最顶端，包含与用户编程有关的所有文件，main.c, stm32f10x_it.c, stm32f10x_it.h, stm32f10x_conf.h, 用户使用固件库进行开发，主要编写main.c和stm32f10x_it.c CMSIS层 CMSIS层位于体系架构的中间，向下负责与内核和各个外设打交道，向上提供函数接口供用户程序或操作系统调用。CMSIS层主要由设备外设函数和CMSIS核心层构成 设备外设函数：由各个芯片产商提供 misc.c/misc.h：NVIC代码 stm32f10x_ppp.c/stm32f10x_ppp.h：外设驱动代码 CMSIS核心层：包括核内外设访问层（arm公司提供）和设备外设访问层（ST公司提供） core_cm3.c/core_cm3.h：Cortex-M3内核通用源文件、头文件 stm32f10x.h/stm32f10x.c/system_stm32f10x.h等：包含了核外外设寄存器名称、地址、中断向量定义等 微控制器(MCU)层 微控制器层也叫硬件层，位于架构体系最底层"},{"title":"","date":"2024-03-31T14:49:40.675Z","updated":"2024-03-31T14:49:40.675Z","comments":true,"path":"notes/stm32/stm32_3/index.html","permalink":"https://blog.ajream.top/notes/stm32/stm32_3/","excerpt":"","text":"工程结构建立 点击跳转到工程查看 初始化工程目录结构 首先创建一个文件夹test, 用于存放该工程，然后在该文件夹下创建以下几个文件夹(目的是让工程管理起来更有条理)： lib: 用于存放库文件（像Libraries、Lib等文件名字也是可以的，根据自己的风格，最好是能&quot;见名知义&quot;） CMSIS: 存放内核核心库文件 STM32F10x_StdPeriph_Driver: 是STM32Fl0x标准外设驱动库函数目录，存放STM32F10x微控制器的外设驱动（这个文件夹可以不建立，等下直接把库的拷贝过来） obj: 用于存放程序编译输出的各种文件 user: 用于存放main.c等用户自己的文件 添加相关文件 固件库说明 color:blue 展开 首先要去官网或其他渠道下载STM32固件库，这个库包含了我们创建要用到的所有文件，其包含的文件如下【Libraries】文件夹存放STM32F10x开发要用到的各种库函数和启动文件，包括CMSIS和STM32F10x_StdPeriph_Driver两个子文件夹:【CMSIS】文件夹是内核库核心文件夹，包括CoreSupport和DeviceSupport等两个文件夹CoreSupport文件夹包括Cortcx-M3内核通用源文件core_cm3.c和头文件core_cm3.h【DeviceSupport】文件夹STM32F0x头文件stm32f10x.h和系统初始化文件system_stm32f10x.c【STM32F10x_StdPeriph_Driver】文件夹是STM32Fl0x标准外设驱动库函数目录，包括了所有STM32F10x微控制器的外设驱动【Project】文件夹对应STM32F10x标准外设库体系架构中的用户层，用来存放ST官方提供的STM32F10x工程模板和外设驱动示例【Utilities】文件夹用于存放ST官方评估板的BSP(Board Support Package, 板级支持包)和额外的第三方固件 添加库文件到自己的模板 lib目录-1 在库文件找到下面的文件拷贝到自己刚建立的lib/CMSIS目录 添加完成后 lib/CMSIS目录是这样： 这些文件去哪里找：在库文件的 【Libraries】目录下 内核通用源文件 启动文件，只需要红框圈起来的那个，对应 stm32f103ZE开发板芯片 系统初始化文件 lib目录-2 去固件库的【Libraries】文件夹下【如下图】把文件夹STM32F10x_StdPeriph_Driver拷贝到自己建立的 lib 目录下 user目录 这是添加完成后的user目录： 这些文件在哪里找： main.c: 可以自己新建一个空的main.c文件，也可以去官方模板那里拷贝过来(官方模板在 /Project/STM32F10x_StdPeriph_Template/目录下, 下面第1幅图) 最下面的三个stm32f10x_conf.h、stm32f10x_it.c、stm32f10x_it.h: 去官方模板拷贝 第二个stm32f10x.h: 在库的Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x路径下找(下面第2幅图) 注意注意，以上步骤只是在磁盘上建立了这么一个目录结构，keil还不知道有这个工程，所以我们要在keil新建一个工程，然后把这个工程与存放在磁盘上的目录（还不能叫工程）进行关联，这样才能形成一个完整结构的工程。 打开mdk keil新建stm32工程 这个步骤是为了在keil中新建一个工程与存放在磁盘上的目录（还不能叫工程）进行关联映射，所以有2步：1-新建工程， 2-进行关联 新建工程 注意新建工程时，有几个步骤： 工程名，任意（根据自己的命名风格，不能有中文） 选择芯片，这里使用 STM32F103ZE 选择库，这里先不选，后面再选，直接跳过 color:blue 具体步骤 点击 new uVision Project自己命名，选择保存；选择芯片 STM32F103ZE选择库，直接跳过，后面再选完成 完善工程结构 这里要把这个工程与磁盘上的目录和文件进行映射关联 选择工程管理，如下： 依次新建这几个目录： user: 存放用户代码文件 startup: 存放启动文件 CMSIS: 内核库文件 StdPeriph_Driver: 外设库文件 分别往这几个目录添加文件： user(从 /user/目录下选择) main.c stm32f10x_it.c startup(从 /lib/CMSIS/ 目录下选择) startup_stm32f10x_hd.s（注意添加时没显示出来要选择 文件类型为 “All files(*.*)”） CMSIS(从 /lib/CMSIS/目录下选择) core_cm3.c system_stm32f10x.c StdPeriph_Driver(从/lib/STM32F10x_StdPeriph_Driver/src/目录下选择，可以选择全部，也可以只选择下面两个，根据自己需要，下面这2个一般都会用到，所以都添加进来) stm32f10x_rcc.c stm32f10x_gpio.c 添加完成如下： 注意到此工程结构已经建立完成，可以在main.c文件下写代码了，但是现在还不能编译，因为编译需要的头文件还没包含进来，以及编译时的其它一些配置还没完成 编译配置 选择这个魔法棒 配置Target项 配置output项 配置 listing项 配置 C/C++ 项，目的是为了把头文件添加进来 下图的第2步添加的是：USE_STDPERIPH_DRIVER,STM32F10X_HD（注意中间有个英文逗号），表示使用外部库函数驱动 配置Debug项：ARM仿真器选项配置（手中有开发板可以先通过ARM仿真器连接电脑） 下载配置（在上一步的Debugger配置中：Debugger-&gt;Settings-&gt;FlashDownload） 注意到此所有配置完成，选择ok，可以愉快的写代码了 测试 打开main.c文件，删除原有代码（如果有的话），添加如下代码： 123456789#include &quot;stm32f10x.h&quot;int main()&#123; while(1)&#123; &#125;&#125; 编译运行，没有报错，完美。。。。"},{"title":"","date":"2021-09-11T08:41:28.000Z","updated":"2024-03-31T14:49:40.675Z","comments":true,"path":"notes/stm32/stm32_4/index.html","permalink":"https://blog.ajream.top/notes/stm32/stm32_4/","excerpt":"","text":"新建工程 看这篇文章 建立完成后工程结构如图： 编写main.c文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &quot;stm32f10x.h&quot;void ledConfig(void);void ledOn(void);void ledOff(void);void delay(unsigned long x);int main()&#123; ledConfig(); while(1)&#123; ledOn(); delay(0x5FFFFF); ledOff(); delay(0x5FFFFF); &#125;&#125;void ledConfig(void)&#123; GPIO_InitTypeDef GPIO_InitStructure; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz; GPIO_Init(GPIOA, &amp;GPIO_InitStructure);&#125;void ledOn()&#123; GPIO_ResetBits(GPIOA, GPIO_Pin_8);&#125;void ledOff()&#123; GPIO_SetBits(GPIOA, GPIO_Pin_8);&#125;void delay(unsigned long x)&#123; unsigned long i; for(i=0; i&lt;x; ++i);&#125; 仿真调试 调试前配置 按图中顺序修改配置，其中第4、5步为： CPU DLL: SARMCM3.DLL, Parameter为空 Dialog DLL: DARMSTM.DLL, Parameter: -pSTM32F103ZE 进入调试模式 选择菜单栏 Debug-&gt;Start/Stop Debug Session或工具栏Debug按钮进入调试模式 打开相关窗口添加监测变量或信号 点击setup按钮，在弹出的窗口添加监测变量 PORTA.8(表示GPIOA_Pin_8) 开始运行 查看仿真结果 把代码编辑区下拉后可以看见输出波形图 关闭仿真"},{"title":"","date":"2024-03-31T14:49:40.675Z","updated":"2024-03-31T14:49:40.675Z","comments":true,"path":"notes/stm32/stm32_5/index.html","permalink":"https://blog.ajream.top/notes/stm32/stm32_5/","excerpt":"","text":"原理 注意以下假设高电平时小灯点亮 原理很简单，使用的是PWM（脉宽调制）机制，就是通过改变波形的占空比（在一个周期中高低电平所占比例） 高电平占比大的时候，小灯比较亮； 低电平占比大的时候，小灯比较暗； 在点亮一个小灯（或者让小灯闪烁）时，我们基本都是写类似下面的代码： 123456789int T1;int T2;while(1)&#123; ledOn(); delay(T1); ledOff(); delay(T2);&#125; 之前我们都是让 T1=T2 , 这样小灯就可以交替闪烁；在这里为了让高电平时间 T1 变长，低电平时间 T2 变短，可以像下面这样写： 123456789101112131415161718192021const int T = 300; //这是一个周期的时间int T1; // 高电平时间int T2; // 低电平时间int deltaT = 10; // 每次变化的变化量， 不能太大否则会亮度突变太大，会出现闪烁现象int flag = 1; //计算的符号，表示增加（flag=1）或减小（flag=0）while(1)&#123; T1 = T1 + deltaT * flag; T2 = T - T1; if(T1 &gt;= T) flag = -1; //当增加到超过T时就开始减小 if(T1 &lt;= 0) flag = 1; //当减小到小于等于0就开始增加 //此处省略其它代码 ledOn(); delay(T1); ledOff(); delay(T2);&#125; 一个周期的时间T则保持不变，而随着 T1 变大， T2就会变小，这样就能进行脉宽调制。完整实现可以像下面： 123456789101112131415161718192021222324int main()&#123; int T = 300; //周期 int T1 = 0; //高电平时间，初始为0，表示小灯灭; int T2 = T; //低电平时间， 初始为 T2 = T-T1 = T; int deltaT = 10; // 每次变化的变化量 int flag = 1; //计算的符号，表示增加（flag=1）或减小（flag=0） ledConfig(); // 初始化led while(1)&#123; T1 = T1 + deltaT * flag; T2 = T - T1; if(T1 &gt;= T) flag = -1; //当增加到超过T时就开始减小 if(T1 &lt;= 0) flag = 1; //当减小到小于等于0就开始增加 ledOn(); delay(T1); ledOff(); delay(T2); &#125;&#125; 用代码实现 点击跳转到项目查看工程 这里使用的是stm32f103开发板 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &quot;stm32f10x.h&quot;void led1Config(void);void led1On(void);void led1Off(void);void led2Config(void);void led2On(void);void led2Off(void);void delay(unsigned long x);int main()&#123; int T = 300; int T1 = 0; int T2 = T; int deltaT = 10; int flag = 1; int i0; led1Config(); led2Config(); while(1)&#123; T1 = T1 + deltaT * flag; T2 = T - T1; if(T1 &gt;= T) T1 = T, flag = -1; if(T1 &lt;= 0) T1 = 0, flag = 1; //这个循环用于控制在每个占空比下，小灯闪烁次数，次数越小表示每个占空比下闪烁次数越少，呼吸就会比较快 // 次数不能过多，否则在某个占空比下闪烁太久，消耗时间比较多(感觉静止了一样)，当到达下一个占空比时，小灯亮度突然改变，就不流畅了，看起来会出现闪烁效果 for(i0=0; i0&lt;10; ++i0)&#123; led1On(); led2On(); delay(T1); led1Off(); led2Off(); delay(T2); &#125; if(i0 &gt;= 10) i0 = 0; &#125;&#125;void led1Config(void)&#123; GPIO_InitTypeDef GPIO_InitStructure1; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOE, ENABLE); GPIO_InitStructure1.GPIO_Pin = GPIO_Pin_5; GPIO_InitStructure1.GPIO_Mode = GPIO_Mode_Out_PP; GPIO_InitStructure1.GPIO_Speed = GPIO_Speed_2MHz; GPIO_Init(GPIOE, &amp;GPIO_InitStructure1);&#125;void led2Config(void)&#123; GPIO_InitTypeDef GPIO_InitStructure2; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE); GPIO_InitStructure2.GPIO_Pin = GPIO_Pin_5; GPIO_InitStructure2.GPIO_Mode = GPIO_Mode_Out_PP; GPIO_InitStructure2.GPIO_Speed = GPIO_Speed_2MHz; GPIO_Init(GPIOB, &amp;GPIO_InitStructure2);&#125;void led1On()&#123; GPIO_ResetBits(GPIOE, GPIO_Pin_5);&#125;void led1Off()&#123; GPIO_SetBits(GPIOE, GPIO_Pin_5);&#125;void led2On()&#123; GPIO_ResetBits(GPIOB, GPIO_Pin_5);&#125;void led2Off()&#123; GPIO_SetBits(GPIOB, GPIO_Pin_5);&#125;void delay(unsigned long x)&#123; unsigned long i, j; for(i=0; i&lt;x; ++i) for(j=0; j&lt;112;++j);&#125;"},{"title":"","date":"2024-03-31T14:49:40.675Z","updated":"2024-03-31T14:49:40.675Z","comments":true,"path":"notes/stm32/stm32_6/index.html","permalink":"https://blog.ajream.top/notes/stm32/stm32_6/","excerpt":"","text":"时钟介绍 众所周知，要让单片机的各个设备（如ADC、定时器TIMx……）正常工作，必须要为其提供一定的时钟频率，因此，为了能进行更多、更灵活的时钟配置，stm32单片机提供了了多个时钟源，通过对时钟源进行简单配置（如倍频、分频），然后提供给各个需要使用的设备，使其正常工作。 时钟树 图中的梯形符号可以理解为一个多入单出的开关，即从多个输入中选择一个输出 时钟源 从上图可以看出，stm32有5个时钟源：HSI、HSE、LSI、LSE、PLL（其实只有四个，因为PLL时钟并不能算“源”，因为它也是来源于HSI或者HSE，从时钟树中也能看出来） 说明：时钟源的字母&quot;H&quot;代表高速时钟，&quot;L&quot;代表低速时钟，&quot;I&quot;代表内部时钟，&quot;E&quot;代表外部时钟，外部时钟都有2个引脚引出去，用来接外部晶振。 高速内部时钟(HSI)：由内部RC振荡器产生，频率为8MHz，但不稳定。 高速外部时钟(HSE)：以外部晶振作时钟源，晶振频率可取范围为4~16MHz，一般采用8MHz的晶振。 低速内部时钟(LSI)：由内部RC振荡器产生，也主要提供给实时时钟模块，频率大约为40KHz。 低速外部时钟(LSE)：以外部晶振作时钟源，主要提供给实时时钟模块，所以一般采用32.768KHz。 高速、低速时钟 高速时钟(HSE和HSI)提供给芯片主体的主时钟 低速时钟(LSE和LSI)只是提供给芯片中的RTC(实时时钟)及独立看门狗使用 从图中可以看出高速时钟也可以提供给RTC。 外部、内部时钟 内部时钟是在芯片内部RC振荡器产生的，起振较快，所以时钟在芯片刚上电的时候，默认使用内部高速时钟。 外部时钟信号是由外部的晶振输入的，在精度和稳定性上都有很大优势，所以上电之后我们再通过软件配置，转而采用外部时钟信号。 外部高速时钟HSE 从外部晶振（8MHz）接到OSC_OUT和OSC_IN引脚开始 经过第一个分频器PLLXTPRE（不分频或者分频——频率除以2） 遇到开关PLLSRC(PLL entry clock source)，我们可以选择其输出，输出为外部高速时钟(HSE)或是内部高速时钟(HSI)。这里选择输出为HSE 接着遇到锁相环PLL，具有倍频作用，在这里我们可以输入倍频因子PLLMUL（可以是 2,3,4,...,16），建议不要超过72MHz，但要是想超频，就得在这个寄存器上做手脚啦。 PLLCLK与SYSCLK时钟输出到外设 系统时钟SYSCLK经过一系列配置后提供给相应外设。 经过PLL的时钟称为PLLCLK。分频因子选1，即不分频；倍频因子我们设定为9倍频。也就是说，经过PLL之后，我们的时钟从原来HSE的8MHz变为72MHz的PLLCLK（8M/1 * 9=72M） 紧接着又遇到了一个开关SW，通过这个开关，可以切换SYSCLK的时钟源，可以选择为HSI、PLLCLK、HSE；经过这个开关之后就是STM32的系统时钟SYSCLK了。 我们选择PLLCLK时钟，所以得到SYSCLK为72MHz。PLLCLK在输入到SW前，还流向了USB预分频器，这个分频器输出为USB外设的时钟(USBCLK) SYSCLK经过AHB预分频器，分频后再通过一些其它配置（如APB1，APB2分频等）输出到其它外设，给这些外设提供时钟 经过AHB预分频的时钟可以成为HCLK时钟，经过APB1预分频的时钟称为PCLK1时钟，经过APB2预分频的时钟称为PCLK2时钟 GPIO外设挂载在APB2总线上，所以把APB2预分频器设置为不分频，就可以得到GPIO外设的时钟也等于HCLK，为72MHz了 总结： SYSCLK：系统时钟，STM32大部分器件的时钟来源。主要由AHB预分频器分配到各个部件，一般最大配置为72MHz（虽然可以超频，但不建议，因为会不稳定） HCLK：由AHB预分频器直接输出得到，它是高速总线AHB的时钟信号，提供给存储器，DMA及cortex内核，是cortex内核运行的时钟，cpu主频就是这个信号，它的大小与STM32运算速度，数据存取速度密切相关。 FCLK：同样由AHB预分频器输出得到，是内核的“自由运行时钟”。“自由”表现在它不来自时钟 HCLK，因此在HCLK时钟停止时 FCLK 也继续运行。它的存在，可以保证在处理器休眠时，也能够采样和到中断和跟踪休眠事件 ，它与HCLK互相同步。 PCLK1：外设时钟，由APB1预分频器输出得到，最大频率为36MHz，提供给挂载在APB1总线上的外设 PCLK2：外设时钟，由APB2预分频器输出得到，最大72MHz，提供给挂载在APB2总线上的外设如GPIO color:blue 查看APBx总线挂载的外设 【在头文件 stm32f10x_rcc.h头文件中指出了各个外设挂载在哪个总线上】123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** @defgroup APB2_peripheral * @&#123; */#define RCC_APB2Periph_AFIO ((uint32_t)0x00000001)#define RCC_APB2Periph_GPIOA ((uint32_t)0x00000004)#define RCC_APB2Periph_GPIOB ((uint32_t)0x00000008)#define RCC_APB2Periph_GPIOC ((uint32_t)0x00000010)#define RCC_APB2Periph_GPIOD ((uint32_t)0x00000020)#define RCC_APB2Periph_GPIOE ((uint32_t)0x00000040)#define RCC_APB2Periph_GPIOF ((uint32_t)0x00000080)#define RCC_APB2Periph_GPIOG ((uint32_t)0x00000100)#define RCC_APB2Periph_ADC1 ((uint32_t)0x00000200)#define RCC_APB2Periph_ADC2 ((uint32_t)0x00000400)#define RCC_APB2Periph_TIM1 ((uint32_t)0x00000800)#define RCC_APB2Periph_SPI1 ((uint32_t)0x00001000)#define RCC_APB2Periph_TIM8 ((uint32_t)0x00002000)#define RCC_APB2Periph_USART1 ((uint32_t)0x00004000)#define RCC_APB2Periph_ADC3 ((uint32_t)0x00008000)#define RCC_APB2Periph_TIM15 ((uint32_t)0x00010000)#define RCC_APB2Periph_TIM16 ((uint32_t)0x00020000)#define RCC_APB2Periph_TIM17 ((uint32_t)0x00040000)#define RCC_APB2Periph_TIM9 ((uint32_t)0x00080000)#define RCC_APB2Periph_TIM10 ((uint32_t)0x00100000)#define RCC_APB2Periph_TIM11 ((uint32_t)0x00200000)#define IS_RCC_APB2_PERIPH(PERIPH) ((((PERIPH) &amp; 0xFFC00002) == 0x00) &amp;&amp; ((PERIPH) != 0x00))/** * @&#125; */ /** @defgroup APB1_peripheral * @&#123; */#define RCC_APB1Periph_TIM2 ((uint32_t)0x00000001)#define RCC_APB1Periph_TIM3 ((uint32_t)0x00000002)#define RCC_APB1Periph_TIM4 ((uint32_t)0x00000004)#define RCC_APB1Periph_TIM5 ((uint32_t)0x00000008)#define RCC_APB1Periph_TIM6 ((uint32_t)0x00000010)#define RCC_APB1Periph_TIM7 ((uint32_t)0x00000020)#define RCC_APB1Periph_TIM12 ((uint32_t)0x00000040)#define RCC_APB1Periph_TIM13 ((uint32_t)0x00000080)#define RCC_APB1Periph_TIM14 ((uint32_t)0x00000100)#define RCC_APB1Periph_WWDG ((uint32_t)0x00000800)#define RCC_APB1Periph_SPI2 ((uint32_t)0x00004000)#define RCC_APB1Periph_SPI3 ((uint32_t)0x00008000)#define RCC_APB1Periph_USART2 ((uint32_t)0x00020000)#define RCC_APB1Periph_USART3 ((uint32_t)0x00040000)#define RCC_APB1Periph_UART4 ((uint32_t)0x00080000)#define RCC_APB1Periph_UART5 ((uint32_t)0x00100000)#define RCC_APB1Periph_I2C1 ((uint32_t)0x00200000)#define RCC_APB1Periph_I2C2 ((uint32_t)0x00400000)#define RCC_APB1Periph_USB ((uint32_t)0x00800000)#define RCC_APB1Periph_CAN1 ((uint32_t)0x02000000)#define RCC_APB1Periph_CAN2 ((uint32_t)0x04000000)#define RCC_APB1Periph_BKP ((uint32_t)0x08000000)#define RCC_APB1Periph_PWR ((uint32_t)0x10000000)#define RCC_APB1Periph_DAC ((uint32_t)0x20000000)#define RCC_APB1Periph_CEC ((uint32_t)0x40000000) 时钟配置 系统初始化函数 系统在复位后，会首先调用系统初始化函数SystemInit()进行初始化配置，包括一些时钟初始化配置等，之后才会调用 main 函数进行执行。 在执行 SystemInit()函数后，配置的时钟如下所述： SYSCLK(系统时钟) = 72MHZ AHB总线时钟HCLK = 72MHZ APB1总线时钟PCLK1 = 36MHZ APB2总线时钟PCLK2 = 72MHZ PLL主时钟PLLCLK = 72MHZ （PLL2时钟 = 40MHZ） 系统时钟配置 配置顺序 HSE-&gt;PLL-&gt;SYSCLK 1234567891011121314151617void RCC_HSE_Config(u32 div,u32 pllm) //自定义系统时间（可以修改时钟）&#123; RCC_DeInit(); //将外设RCC寄存器重设为缺省值 RCC_HSEConfig(RCC_HSE_ON);//设置外部高速晶振（HSE） if(RCC_WaitForHSEStartUp()==SUCCESS) //等待HSE起振 &#123; RCC_HCLKConfig(RCC_SYSCLK_Div1);//设置AHB时钟预分频为1（HCLK） RCC_PCLK1Config(RCC_HCLK_Div2);//设置低速AHB时钟（PCLK1） RCC_PCLK2Config(RCC_HCLK_Div1);//设置高速AHB时钟（PCLK2） RCC_PLLConfig(div,pllm);//设置PLL时钟源及倍频系数 RCC_PLLCmd(ENABLE); //使能PLL时钟源 while(RCC_GetFlagStatus(RCC_FLAG_PLLRDY)==RESET);//检查指定的RCC标志位设置与否,PLL就绪 RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);//设置系统时钟（SYSCLK）的时钟源为为PLL时钟 while(RCC_GetSYSCLKSource()!=0x08);//返回用作系统时钟的时钟源,0x08表示时钟源为PLL时钟 &#125;&#125; RCC_PLLConfig(div,pllm)就是配置从 HSE-&gt;PLL的过程中分频、倍频因子的值，如下图： 示例程序: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &quot;stm32f10x.h&quot;#include &quot;led.h&quot;void delay(u32 i)&#123; while(i--);&#125;/******************************************************************************** 函 数 名 : RCC_HSE_Config* 函数功能 : 自定义系统时钟，可以通过修改PLL时钟源和倍频系数实现时钟调整* 输 入 : div：RCC_PLLSource_HSE_Div1/RCC_PLLSource_HSE_Div2 pllm：RCC_PLLMul_2-RCC_PLLMul_16* 输 出 : 无*******************************************************************************/void RCC_HSE_Config(u32 div,u32 pllm) //自定义系统时间（可以修改时钟）&#123; RCC_DeInit(); //将外设RCC寄存器重设为缺省值 RCC_HSEConfig(RCC_HSE_ON);//设置外部高速晶振（HSE） if(RCC_WaitForHSEStartUp()==SUCCESS) //等待HSE起振 &#123; RCC_HCLKConfig(RCC_SYSCLK_Div1);//设置AHB时钟（HCLK） RCC_PCLK1Config(RCC_HCLK_Div2);//设置低速AHB时钟（PCLK1） RCC_PCLK2Config(RCC_HCLK_Div1);//设置高速AHB时钟（PCLK2） RCC_PLLConfig(div,pllm);//设置PLL时钟源及倍频系数 RCC_PLLCmd(ENABLE); //使能PLL时钟源 while(RCC_GetFlagStatus(RCC_FLAG_PLLRDY)==RESET);//检查指定的RCC标志位设置与否,PLL就绪 RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);//设置系统时钟（SYSCLK）的时钟源为为PLL时钟 while(RCC_GetSYSCLKSource()!=0x08);//返回用作系统时钟的时钟源,0x08表示时钟源为PLL时钟 &#125;&#125;int main()&#123; RCC_HSE_Config(RCC_PLLSource_HSE_Div2,RCC_PLLMul_9); // 8M / 2 * 9 = 36M LED_Init(); while(1) &#123; GPIO_ResetBits(LED1_PORT,LED1_PIN);//点亮LED1 delay(6000000); GPIO_SetBits(LED1_PORT,LED1_PIN); delay(6000000); &#125;&#125;"},{"title":"","date":"2024-03-31T14:49:40.675Z","updated":"2024-03-31T14:49:40.675Z","comments":true,"path":"notes/stm32/stm32_7/index.html","permalink":"https://blog.ajream.top/notes/stm32/stm32_7/","excerpt":"","text":"SysTick定时器介绍 在给STM32进行编程的时候，我们在程序中会遇到有的时候需要延时，以前我们采用的是循环多次来达到延时的功能，但这样延时很不准确，而通过STM32的SysTick定时器可以让我们更加精确的进行延时操作。 SysTick定时器是一个24位的倒计数定时器，计到0时，将从 RELOAD 寄存器(下面介绍)中自动重装载定时初值。只要不把它在SysTick控制及状态寄存器中的使能位清除，就永不停息，即使在睡眠模式下也能工作。 SysTick定时器的时钟来源是系统时钟SYSCLK，不分频为 72MHz，8 分频为 9MHz SysTick有4个相关的寄存器： 控制和状态寄存器: CTRL 自动重装载初值寄存器: LOAD 当前值寄存器: VAL 校准值寄存器: CALIB（用于校准，不常用） 控制及状态寄存器 根据下表介绍进行相关位的配置即可 位修改的技巧： 例如，NUM表示一个二进制数，要将它的第2位置1，其它位不变，则可以这样写： 1NUM |= (1&lt;&lt;2); //使用位运算 重装载寄存器 注意这是一个24位寄存器，因此装载的最大值为 224−12^{24}-1224−1 计时范围：[0, 224−12^{24}-1224−1] 计数方向：倒计数 当前值寄存器 看表格描述 校准值寄存器(不常用) SysTick定时器使用 使用SysTick定时器前要导入 misc.c 文件 配置步骤 选择SysTick定时器的时钟源 设定重装载初值 清零定时器当前计数值 开启SysTick定时器 判断什么时候停止 停止后关闭计数，清零计数值 相关库函数 时钟源选择，定义在misc.c文件中 可选择的时钟源： SysTick_CLKSource_HCLK_Div8: AHB 8分频输出 SysTick_CLKSource_HCLK : AHB 时钟输出 123456789101112131415161718192021/** * @brief Configures the SysTick clock source. * @param SysTick_CLKSource: specifies the SysTick clock source. * This parameter can be one of the following values: * @arg SysTick_CLKSource_HCLK_Div8: AHB clock divided by 8 selected as SysTick clock source. * @arg SysTick_CLKSource_HCLK: AHB clock selected as SysTick clock source. * @retval None */void SysTick_CLKSourceConfig(uint32_t SysTick_CLKSource)&#123; /* Check the parameters */ assert_param(IS_SYSTICK_CLK_SOURCE(SysTick_CLKSource)); if (SysTick_CLKSource == SysTick_CLKSource_HCLK) &#123; SysTick-&gt;CTRL |= SysTick_CLKSource_HCLK; &#125; else &#123; SysTick-&gt;CTRL &amp;= SysTick_CLKSource_HCLK_Div8; &#125;&#125; 寄存器的定义，在 core_cm3.h文件中 12345678typedef struct&#123; __IO uint32_t CTRL; /*!&lt; Offset: 0x00 SysTick Control and Status Register */ __IO uint32_t LOAD; /*!&lt; Offset: 0x04 SysTick Reload Value Register */ __IO uint32_t VAL; /*!&lt; Offset: 0x08 SysTick Current Value Register */ __I uint32_t CALIB; /*!&lt; Offset: 0x0C SysTick Calibration Register */&#125; SysTick_Type; 中断服务函数，在 stm32f10x_it.c文件，使用前要配置CTRL寄存器中关于中断的位，开启中断后即可在此函数写中断处理的语句 12345678/** * @brief This function handles SysTick Handler. * @param None * @retval None */void SysTick_Handler(void)&#123;&#125; 例子 用于实现精确延时us和ms，按照前面说的6个步骤： 选择SysTick定时器的时钟源 设定重装载初值 清零定时器当前计数值 开启SysTick定时器 判断什么时候停止 停止后关闭计数，清零计数值 代码太长不想看的，看后面具体函数解析 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &quot;SysTick.h&quot;static u8 fac_us=0; //代表1us延时需要计数的次数 static u16 fac_ms=0; //代表1ms延时需要计数的次数//初始化延迟函数//SYSTICK的时钟固定为AHB时钟的1/8//SYSCLK:系统时钟频率void SysTick_Init(u8 SYSCLK)&#123; //1. 时钟源选择 SysTick_CLKSourceConfig(SysTick_CLKSource_HCLK_Div8); fac_us = SYSCLK/8; //配置延时1us需要计数的次数, 由于时钟源为HCLK/8=9MHz, 所以SYSCLK应该选择72 fac_ms = (u16)fac_us*1000; //配置延时1ms需要计数的次数 &#125;/******************************************************************************** 函 数 名 : delay_us* 函数功能 : us延时，* 输 入 : nus：要延时的us数 注意:nus的值,不要大于798915us(最大值即2^24/fac_us@fac_us=21)* 输 出 : 无*******************************************************************************/ void delay_us(u32 nus)&#123; u32 temp; //2. 配置重装载值 SysTick-&gt;LOAD = nus*fac_us; //fac_us表示1us需要计数的次数，则nus需要计数nus*fac_us次 //3. 清空计数器 SysTick-&gt;VAL = 0x00; //4. 启动计数（倒计数） SysTick-&gt;CTRL |= SysTick_CTRL_ENABLE_Msk; //实际上SysTick_CTRL_ENABLE_Msk值为1 //5. 判断CTRL寄存器值(赋给temp)的第16位是否为1，如果是1，则计数完成 do &#123; temp = SysTick-&gt;CTRL; &#125;while((temp&amp;0x01)&amp;&amp;!(temp&amp;(1&lt;&lt;16)));//循环条件：第一个表示已经启动定时器，后一个表示还没计数完成 //6. 关闭计数器，清空计数值 SysTick-&gt;CTRL &amp;= ~SysTick_CTRL_ENABLE_Msk; //关闭计数器，将最低位置0 SysTick-&gt;VAL = 0X00; //清空计数器 &#125;/* *对系统时钟为72M的情况, 要求参数 nms&lt;=1864ms 因为 (2^24-1)/(72/8*1000)=1864**/void delay_ms(u16 nms)&#123; u32 temp; SysTick-&gt;LOAD=(u32)nms*fac_ms; //时间加载 SysTick-&gt;VAL =0x00; //清空计数器 SysTick-&gt;CTRL|=SysTick_CTRL_ENABLE_Msk ; //开始倒数 do &#123; temp=SysTick-&gt;CTRL; &#125;while((temp&amp;0x01)&amp;&amp;!(temp&amp;(1&lt;&lt;16))); //等待时间到达 SysTick-&gt;CTRL&amp;=~SysTick_CTRL_ENABLE_Msk; //关闭计数器 SysTick-&gt;VAL =0x00; //清空计数器 &#125; 函数解析 12345678910void SysTick_Init(u8 SYSCLK)&#123; //1. 时钟源选择（HCLK单位为MHz） SysTick_CLKSourceConfig(SysTick_CLKSource_HCLK_Div8); //配置延时1us需要计数的次数, 由于上一行配置SysTick时钟源为HCLK/8 //而系统时钟频率==HCLK频率，所以SysTick计数(HCLK/8)次==1s，1us需要计数HCLK/(8*1000000)次 //即SYSCLK/(8*1000000)次，所以按照下面一行的写法，传入的参数SYSCLK不能写72000000（72000000是默认情况下的系统时钟），而是写72 fac_us = SYSCLK/8; fac_ms = (u16)fac_us*1000; //配置延时1ms需要计数的次数 &#125; 1234567891011121314151617181920void delay_us(u32 nus)&#123; u32 temp; //2. 配置重装载值 SysTick-&gt;LOAD = nus * fac_us; //fac_us表示1us需要计数的次数，则nus需要计数nus*fac_us次 //3. 清空计数器 SysTick-&gt;VAL = 0x00; //4. 启动计数（倒计数） SysTick-&gt;CTRL |= SysTick_CTRL_ENABLE_Msk; //实际上SysTick_CTRL_ENABLE_Msk值为1 //5. 判断CTRL寄存器值(赋给temp)的第16位是否为1，如果是1，则计数完成 do &#123; temp = SysTick-&gt;CTRL; &#125;while((temp&amp;0x01)&amp;&amp;!(temp&amp;(1&lt;&lt;16))); //循环条件：第一个表示已经启动定时器，后一个表示还没计数完成 //6. 关闭计数器，清空计数值 SysTick-&gt;CTRL &amp;= ~SysTick_CTRL_ENABLE_Msk; //将最低位置0，关闭计数器 SysTick-&gt;VAL = 0x00; //清空计数器 &#125; color:red 虚拟调试注意 使用keil进行虚拟调试时，要配置晶振频率为8MHZ，因为使用的是最最最初始的时钟源HSE=8MHZ（个人认为的，还不确定是不是真的这样），如图：调试结果"},{"title":"","date":"2024-03-31T14:49:40.675Z","updated":"2024-03-31T14:49:40.675Z","comments":true,"path":"notes/stm32/stm32_8/index.html","permalink":"https://blog.ajream.top/notes/stm32/stm32_8/","excerpt":"","text":"定时器TIMx介绍 定时器是一个设备，要区别于时钟的概念，时钟是用来配置产生一定频率的电平信号，用于驱动像定时器、ADC等外设工作。TIMx中的 x 即具体的哪一个定时器 分类 基本定时器（TIM6、TIM7） 通用定时器（TIM2—TIM5） 高级控制定时器（TIM1、TIM8） 内部构成模块 自动重装载寄存器：TIMx_ARR 预分频器：TIMx_PSC 这是TIM6、TIM7的主要内部构成（TIM2~5多了一个捕获/比较寄存器TIMx_CCR） 核心部分由自动重装载寄存器TIMx_ARR和CNT计数器构成 来自RCC的时钟信号TIMxCLK（通常是72MHZ）经过预分频器分频后，计数器开始计数（TIM6、TIM7只能从0开始向上计数），直到计数值达到TIMx_ARR中存放的值后，重新回到0，继续重复这一过程。 由此得出3个配置步骤： 选择时钟源 TIMxCLK 频率 预分频系数（注意要-1，比如要选择分频系数为72，那么放入的值应该是71） 确定需要延时多长时间，进而确定自动重装载的值 TIMx_ARR（注意也要-1） 延时时间 = (TIMx_ARR+1) * (TIMx_PSC+1) / TIMxCLK 计数模式 向上计数（基本定时器TIM6/TIM7只有这种模式） 向下计数 双向计数 三种定时器 大家都具有的功能或特点 内部预分频器位数：16 内部计数器位数：16 可以更新中断和DMA 基本定时器 基本定时器包括TIM6、TIM7，只具备基本的定时功能，即累计时钟脉冲数超过装载值后，产生溢出；如果使能了中断或者DMA事件，则使能中断或者DMA操作； 另外，基本定时器可以作为通用定时器的时基，可以为数模转换器DAC提供时钟（事实上，TIM6、TIM7被直接连接到DAC并通过触发直接驱动DAC）； 其它特性： 时钟源：APB1输出 计数模式：向上计数 通用定时器 通用定时器包括TIM2~TIM5共四个 特性： 相比基本定时器添加了 捕获/比较寄存器：TIMx_CCRx (注意每个通用定时器都有4个捕获比较寄存器，因为有4个输出口OCx) 时钟源：APB1（通常提供72MHz）、ITRx、TIx（外部时钟模式1）、ETR（外部时钟模式2）；[初学只需要掌握第一种即可] 计数模式：向上、向下、双向均可 PWM输出模式 PWM即脉冲宽度调制（废话就不多说，不懂的可以去百度等查找相关介绍），通用定时器因为拥有捕获/比较寄存器，所以可以配置PWM输出模式 通用定时器如何配置PWM输出模式？ 配置计数模式（此处设置为向上计数） 配置TIMx_ARR预设值为N（记得要-1），配置捕获/比较寄存器预设值A 配置输出方式：假设配置为当计数值X&lt;A时, 输出高电平；当X&gt;=A时，输出低电平。这样输出波形占空比为A/(N+1) color:blue PWM输出模式 模式1 TIM_OCMode_PWM1:向上计数时，当计数值&lt;CCR存放的值时，输出有效电平，否则为无效电平（之后可以设置低电平有效还是高电平有效）向下计数时，与向上计数一样模式2 TIM_OCMode_PWM2:向上计数时，当计数值&lt;CCR存放的值时，输出无效电平，否则为有效电平（之后可以设置低电平有效还是高电平有效）向下计数时，与向上计数一样这是配置PWM输出的主要步骤，如图：配置PWM输出详细步骤：例如配置TIM3的CH2通道为PWM输出，输出重映射到PB5端口12345678910111213141516171819202122232425262728293031323334353637void TIM3_CH2_PWM_Init(u16 per,u16 psc)&#123; TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure; TIM_OCInitTypeDef TIM_OCInitStructure; GPIO_InitTypeDef GPIO_InitStructure; /* 开启时钟 */ RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB|RCC_APB2Periph_AFIO,ENABLE); RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3,ENABLE); /* 配置GPIO的模式和IO口 */ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; GPIO_Init(GPIOB, &amp;GPIO_InitStructure); GPIO_PinRemapConfig(GPIO_PartialRemap_TIM3, ENABLE);//改变指定管脚的映射 TIM_TimeBaseInitStructure.TIM_Period= per; //自动装载值 TIM_TimeBaseInitStructure.TIM_Prescaler = psc; //分频系数 TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1; TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up; //设置向上计数模式 TIM_TimeBaseInit(TIM3, &amp;TIM_TimeBaseInitStructure); //从这里开始是输出PWM配置 TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1; //PWM输出模式为PWM1 TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_Low; //有效电平设置为低电平 TIM_OCInitStructure.TIM_OutputState=TIM_OutputState_Enable; TIM_OC2Init(TIM3,&amp;TIM_OCInitStructure); //输出比较通道2初始化 TIM_OC2PreloadConfig(TIM3,TIM_OCPreload_Enable); //使能TIMx在 CCR2 上的预装载寄存器 TIM_ARRPreloadConfig(TIM3,ENABLE);//使能预装载寄存器 TIM_Cmd(TIM3,ENABLE); //使能定时器 &#125; PWM输入模式 PWM输入模式用于测量外部输入信号的脉宽，流程是： 从外部输入一个（方波）信号TI，当从输入端第一次捕获到TI的上升沿时，计数器TIMx_CNT复位为0，然后开始不断向上计数(TIMx_ARR足够大)； 当捕获到下降沿时，TIMx_CRR2寄存器记录下当前计数器的计数值；（得出：高电平期间计数次数=CRR2+1，加1是因为计数是从0开始的） 当再次捕获到上升沿时，TIMx_CRR1寄存器记录当前计数器的计数值。（得出：一个周期内计数器计数次数=CRR1+1） 计算得出：占空比=(CRR2+1)/(CRR1+1) 高级定时器 高级定时器包括TIM1、TIM8 功能特性： 时钟源：APB2（72MHz） 计数模式：向上、向下、双向 具备通用定时器所有功能 是6个通道的三相PWM发生器 整体结构和基本、通用定时器相同（多出BPK、DTG两个结构），配置方法差不多 死区时间控制（源于BPK、DTG的结构） 定时器相关库函数 定时器库函数存放在标准外设库的 stm32f10x_tim.h 和 stm32f10x_tim.c 文件中，使用时要在用户程序中导入（#include stm32f10x_tim.h，或者在 stm32f10x_conf.h中去除掉相关注释）； 常用库函数： 12345678910111213TIM_DeInit();TIM_TimeBaseInit(); //根据指定结构体初始化TIMxTIM_OCxInit(); //初始化外设TIM的通道xTIM_Cmd(); // 使能或禁止定时器TIM_GetFlagStatus(); //检测指定TIMx的定时器标志位TIM_ClearFlag();TIM_ITConfig(); //使能或禁止指定TIMx的中断TIM_GetITStatus(); //检测中断标志位状态，判断中断是否发生，中断标志位要软件清零TIM_ClearITPendingBit(); //清除TIMx中断挂起位TIM_CtrlPWMOutputs();TIM_ARRPreloadConfig(); //使能或禁止TIMx在ARR上的预装载寄存器TIM_OCxPreloadConfig(); //使能或禁止TIMx在CCRx上的预装载寄存器 定时器中断 当定时器计数值溢出时，可以让其产生中断信号，然后配置中断服务函数（即产生中断后该做些什么，通常是PPP_IRQHandler()形式的函数） 以定时器TIM2为例，如何初始化让其产生中断 123456789101112131415161718192021222324252627282930313233343536373839void TIM2_init(u16 arr, u16 psc)&#123; TIM_TimeBaseInitTypeDef TIM_Structure; NVIC_InitTypeDef NVIC_Structure; RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE); //延时时间（单位:s）：arr/(72000000/psc) TIM_Structure.TIM_Period = arr - 1; //装载值 TIM_Structure.TIM_Prescaler = psc-1; //分频系数 TIM_Structure.TIM_CounterMode = TIM_CounterMode_Up; TIM_TimeBaseInit(TIM2, &amp;TIM_Structure); TIM_ITConfig(TIM2, TIM_IT_Update, ENABLE); //开启定时器TIM2中断 TIM_ClearITPendingBit(TIM2, TIM_IT_Update); //清除TIMx中断挂起位 NVIC_Structure.NVIC_IRQChannel = TIM2_IRQn; //指明中断服务函数通道 NVIC_Structure.NVIC_IRQChannelPreemptionPriority = 0; //抢占优先级 NVIC_Structure.NVIC_IRQChannelSubPriority = 1; //子优先级 NVIC_Structure.NVIC_IRQChannelCmd = ENABLE; //中断使能配置 NVIC_Init(&amp;NVIC_Structure); TIM_ClearFlag(TIM2, TIM_FLAG_Update); TIM_Cmd(TIM2, ENABLE);&#125;//中断服务函数void TIM2_IRQHandler(void)&#123; if(TIM_GetITStatus(TIM2, TIM_IT_Update) != RESET)&#123; LED_Flag = !LED_Flag; if(LED_Flag) &#123; SetLED_On(LEDE); SetLED_Off(LEDB); &#125; else &#123; SetLED_Off(LEDE); SetLED_On(LEDB); &#125; TIM_ClearITPendingBit(TIM2, TIM_IT_Update); //软件清除中断挂起位 &#125;&#125; color:blue 中断相关知识 优先级：数字越小优先级越高抢占优先级：优先级越高（数字越小）越先被执行，优先级高的可以打断优先级低的，优先级相同时看子优先级子优先级（也叫响应优先级）：两个中断同时到达，抢占优先级相同，子优先级高的先执行；当子优先级高的中断到来时，遇到子优先级低的中断正在执行（两者抢占优先级一样），那子优先级高的中断也要等待子优先级低的中断先执行完；优先级分组：既然每个中断源都需要被指定这两种优先级，就需要有相应的寄存器位记录每个中断的优先级（指优先级这个数字，不能超过分配给它的最大存储值）；在Cortex-M3中定义了8个比特位用于设置中断源的优先级，这8个比特位可以有8种分配方式，如下：所有8位用于指定响应优先级最高1位用于指定抢占式优先级，最低7位用于指定响应优先级最高2位用于指定抢占式优先级，最低6位用于指定响应优先级最高3位用于指定抢占式优先级，最低5位用于指定响应优先级最高4位用于指定抢占式优先级，最低4位用于指定响应优先级最高5位用于指定抢占式优先级，最低3位用于指定响应优先级最高6位用于指定抢占式优先级，最低2位用于指定响应优先级最高7位用于指定抢占式优先级，最低1位用于指定响应优先级这就是优先级分组的概念。Cortex-M3允许具有较少中断源时使用较少的寄存器位指定中断源的优先级，因此STM32把指定中断优先级的寄存器位减少到4位，这4个寄存器位的分组方式如下：第0组：所有4位用于指定响应优先级，此时不会发生中断嵌套第1组：最高1位用于指定抢占式优先级，最低3位用于指定响应优先级第2组：最高2位用于指定抢占式优先级，最低2位用于指定响应优先级第3组：最高3位用于指定抢占式优先级，最低1位用于指定响应优先级第4组：所有4位用于指定抢占式优先级可以通过调用STM32的固件库中的函数NVIC_PriorityGroupConfig()选择使用哪种优先级分组方式，这个函数的参数有下列5种：12345NVIC_PriorityGroup_0 //选择第0组NVIC_PriorityGroup_1 // 选择第1组NVIC_PriorityGroup_2 // 选择第2组NVIC_PriorityGroup_3 // 选择第3组NVIC_PriorityGroup_4 // 选择第4组如何指定中断源的抢占式优先级和响应优先级：12345678910111213141516// 选择使用优先级分组第1组NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1);// 使能EXTI0中断NVIC_InitStructure.NVIC_IRQChannel = EXTI0_IRQChannel;NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1; // 指定抢占式优先级别1NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0; // 指定响应优先级别0NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;NVIC_Init(&amp;NVIC_InitStructure);// 使能EXTI9_5中断NVIC_InitStructure.NVIC_IRQChannel = EXTI9_5_IRQChannel;NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0; // 指定抢占式优先级别0NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1; // 指定响应优先级别1NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;NVIC_Init(&amp;NVIC_InitStructure);"},{"title":"","date":"2024-03-31T14:49:40.675Z","updated":"2024-03-31T14:49:40.675Z","comments":true,"path":"notes/stm32/stm32_9/index.html","permalink":"https://blog.ajream.top/notes/stm32/stm32_9/","excerpt":"","text":"中断介绍 相关概念百度或查找其它资料 中断源 中断屏蔽 中断处理过程（响应中断、执行中断服务函数、中断返回） 中断优先级（抢占优先级、子优先级） 中断嵌套 中断系统 嵌套向量中断控制器NVIC 中断优先级 color:blue 优先级分组 Cortex-M3允许具有较少中断源时使用较少的寄存器位指定中断源的优先级，因此STM32把指定中断优先级的寄存器位减少到4位，这4个寄存器位的分组方式如下：第0组：所有4位用于指定响应优先级，此时不会发生中断嵌套第1组：最高1位用于指定抢占式优先级，最低3位用于指定响应优先级第2组：最高2位用于指定抢占式优先级，最低2位用于指定响应优先级第3组：最高3位用于指定抢占式优先级，最低1位用于指定响应优先级第4组：所有4位用于指定抢占式优先级可以通过调用STM32的固件库中的函数NVIC_PriorityGroupConfig()选择使用哪种优先级分组方式，这个函数的参数有下列5种：12345NVIC_PriorityGroup_0 //选择第0组NVIC_PriorityGroup_1 // 选择第1组NVIC_PriorityGroup_2 // 选择第2组NVIC_PriorityGroup_3 // 选择第3组NVIC_PriorityGroup_4 // 选择第4组 中断服务函数 中断服务函数通常以PPP_IRQHandler命名，PPP是对应外设名 color:blue 中断设置过程 建立中断向量表（必须在用户程序执行前完成，通常在启动过程中完成可以在Flash、RAM中建立中断向量表）在Flash建立（默认情况下）：无需重定位中断向量表，即每个中断对应的中断服务函数不能被修改在RAM中建立：需要重定向中断向量表，在用户程序运行过程，可根据需要动态修改中断服务程序分配栈空间并初始化设置中断优先级分组抢占优先级、子优先级使能中断编写中断服务函数 外部中断/事件控制器EXTI color:blue 原理框图 color:blue 外部中断输入线 一共16个中断输入线EXTI0~EXTI15每个输入线都可以源于PA~PG共7个端口（同一时刻只能启用其中一个端口，比如对于EXTI0，用了PA0作为外部输入，就不能用PB0或者PC0、PD0……） color:blue 原理实现 外部信号通过输入线（GPIO端口）进入EXTIx信号经过边沿检测电路，可以选择上升沿或下降沿触发，或者2种触发都选择然后经过或门，一路输出到NVIC控制器（用于产生中断），一路经过脉冲发生器输出一个脉冲；在这个过程中信号可以被屏蔽。用于产生中断的信号称为“中断”，用于产生脉冲的信号被称为“事件” EXTI_InitTypeDef 定义于文件“stm32f10x_exti.h”： 1234567typedef struct &#123; u32 EXTI_Line; EXTIMode_TypeDef EXTI_Mode; EXTIrigger_TypeDef EXTI_Trigger; FunctionalState EXTI_LineCmd; &#125; EXTI_InitTypeDef;"}],"posts":[{"title":"mingw64下载安装","slug":"mingw64下载方法","date":"2023-03-16T04:45:26.000Z","updated":"2024-03-31T14:49:40.667Z","comments":true,"path":"posts/fdd0441e/","link":"","permalink":"https://blog.ajream.top/posts/fdd0441e/","excerpt":"","text":"下载最新版MinGW-W64 网上有很多方法，但有些只是下载了一个exe安装工具，安装过程还需要联网下载很多东西，如果网络不好容易出问题，因此建议去Github下载，下载后是一个压缩包，解压到任意一个不含中文的路径即可。 github链接如下： https://github.com/niXman/mingw-builds-binaries/releases 我下载的是12.1.0版本 在windows下开发 Linux、Unix、Mac OS 等其他操作系统下的程序，请选择 posix 要使用C++11的多线程新特性，也要下载posix版本，因此建议下载posix 起初我下载了win32-seh这个版本，后来发现要使用std:thread时编译失败，才发现是版本不对造成，后来下载了posix-seh版本 seh/sljl/dwarf是异常处理方式，seh适合64bit系统，sljl适合32/64bit系统，dwarf适合32bit系统； 64bit系统建议使用seh版本 配置环境变量，在用户变量的path那里，添加一条记录如下即可： 1D:\\xxx\\xxx\\mingw64\\bin 在cmd输入命令 gcc -v 输出下面说明环境配置成功 12345678Using built-in specs.COLLECT_GCC=gccCOLLECT_LTO_WRAPPER=D:/Install/mingw64/mingw64_12_1_0/bin/../libexec/gcc/x86_64-w64-mingw32/12.1.0/lto-wrapper.exeTarget: x86_64-w64-mingw32Configured with: ..............【此处省略一大堆】Thread model: win32Supported LTO compression algorithms: zlibgcc version 12.1.0 (x86_64-win32-seh-rev3, Built by MinGW-W64 project)","categories":[{"name":"开发环境搭建","slug":"开发环境搭建","permalink":"https://blog.ajream.top/categories/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://blog.ajream.top/tags/C-C/"}]},{"title":"ESP32+OLED播放视频","slug":"ESP32+OLED播放视频","date":"2023-02-06T07:30:34.000Z","updated":"2023-02-06T11:28:17.000Z","comments":true,"path":"posts/d230206/","link":"","permalink":"https://blog.ajream.top/posts/d230206/","excerpt":"","text":"ESP32+OLED播放视频 1、思路分析 ESP32采用Arduino开发，结合u8g2模块可以很方便地实现在oled上显示图片。因此，只需要将一个视频拆开成一帧帧，然后循环显示即可。 然而，有几个问题： 视频太大，esp32的flash无法存下怎么办？ 答：两种方案：视频存储在电脑，一帧帧发送给ESP32即可，这样ESP32每次只需要存放一帧。 可以通过【串口】发送给ESP32，也可以采用【socket协议】发送。（均可以采用python实现发送方的代码） 如何将图片转换成u8g2能够显示的格式？ 通常我们使用u8g2显示图片，需要使用PCtoLCD2022这个软件将图片格式转换，其配置如下。为了能够传输视频，需要用python【实现这个转换算法】 整体流程： PC通过Python代码读取视频，将视频每一帧读取出来，转换成适合的大小，然后通过图片转换算法，将每一帧转换成符合u8g2显示的数据格式，最后将这些数据通过TCP方式发送到ESP32中 ESP32接收到这些数据后，就保存到img变量中，然后采用 u8g2.drawXBM(img) 来显示图片即可 图片转换算法已经实现：（只实现了PCtoLCD配置中的“阳码”、“逐行式”、“逆向”方案） 阴码、阳码区分：由于oled是由很多个led灯组成的，只能有点亮或不点亮两种状态，因此只能显示两种颜色。 对于阳码，白色点亮小灯，黑色不点亮。阴码则反过来，即黑色点亮，白色不点亮。 12345678910111213141516171819202122232425262728293031323334353637383940import cv2def getU8g2Img(img, newW=0, scale=1)-&gt;list: &#x27;&#x27;&#x27; return: 返回图像取模后的结果 参数: - img: 输入图片（cv2格式(BGR)） - newW: 目标图像的宽度 - scale: 将图像放大(或缩小)倍数 注意：newW与scale二者只需设置其中一个即可 &#x27;&#x27;&#x27; imgGrey = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) h,w = imgGrey.shape if scale!=1: imgGrey = cv2.resize(imgGrey, dsize=None, fx=scale, fy=scale) elif newW!=0: imgGrey = cv2.resize(imgGrey, dsize=None, fx=newW/w, fy=newW/w) h, w = imgGrey.shape ret, imgBin = cv2.threshold(imgGrey, 200, 255, cv2.THRESH_BINARY) # 返回 阈值 和 图像 print(f&quot;最终图片宽=&#123;w&#125; 高=&#123;h&#125;&quot;) resultList = [] for i in range(h): tmp = w k = 0 while True: rowCode = &#x27;&#x27; for j in range(k, min(k+8, tmp)): # 阴码：黑色表示1，白色255表示0， # rowCode += (&#x27;0&#x27; if imgBin[i][j] &gt; 100 else &#x27;1&#x27;) # 阳码，黑色为0，不点亮，白色为1，点亮 rowCode += (&#x27;1&#x27; if imgBin[i][j] &gt; 100 else &#x27;0&#x27;) if len(rowCode) &lt; 8: # rowCode += (&#x27;0&#x27; * (8-len(rowCode))) # 阴码 rowCode += (&#x27;1&#x27; * (8-len(rowCode))) # 阳码 rowCode = rowCode[::-1] # 倒序，对应pctoLCD2002【逆向】 k += 8 resultList.append(&#x27;0x&#x27;+(f&#x27;&#123;int(rowCode, 2):0&gt;2x&#125;&#x27;).upper()) if k &gt;= tmp: break return resultList 2、TCP服务端实现 主要分3个模块实现 GUI配置模块：配置GUI布局等信息 视频处理模块：读取视频，视频尺寸大小修改，将视频转换为u8g2能处理的格式等 主模块：GUI各种功能事件的实现，TCP传输功能的实现 gui.py 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157# -*- coding: utf-8 -*-# Form implementation generated from reading ui file &#x27;gui.ui&#x27;## Created by: PyQt5 UI code generator 5.15.0## WARNING: Any manual changes made to this file will be lost when pyuic5 is# run again. Do not edit this file unless you know what you are doing.from PyQt5 import QtCore, QtGui, QtWidgetsclass Ui_Form(object): def setupUi(self, Form): Form.setObjectName(&quot;Form&quot;) Form.resize(955, 515) Form.setStyleSheet(&quot;background: rgb(0, 0, 0);\\n&quot;&quot;color: #fff;&quot;) self.btnInputVideo = QtWidgets.QPushButton(Form) self.btnInputVideo.setGeometry(QtCore.QRect(840, 200, 51, 31)) self.btnInputVideo.setStyleSheet(&quot;color:#fff;background: #222;&quot;) self.btnInputVideo.setObjectName(&quot;btnInputVideo&quot;) self.editVideoInput = QtWidgets.QLineEdit(Form) self.editVideoInput.setGeometry(QtCore.QRect(570, 200, 261, 31)) self.editVideoInput.setStyleSheet(&quot;color:#fff;&quot;) self.editVideoInput.setInputMask(&quot;&quot;) self.editVideoInput.setText(&quot;&quot;) self.editVideoInput.setMaxLength(32767) self.editVideoInput.setFrame(True) self.editVideoInput.setCursorPosition(0) self.editVideoInput.setObjectName(&quot;editVideoInput&quot;) self.imgLabel = QtWidgets.QLabel(Form) self.imgLabel.setGeometry(QtCore.QRect(20, 50, 512, 256)) self.imgLabel.setStyleSheet(&quot;color:#aaa;background: #111;&quot;) self.imgLabel.setOpenExternalLinks(False) self.imgLabel.setTextInteractionFlags(QtCore.Qt.LinksAccessibleByMouse) self.imgLabel.setObjectName(&quot;imgLabel&quot;) self.btnExit = QtWidgets.QPushButton(Form) self.btnExit.setGeometry(QtCore.QRect(690, 450, 91, 51)) self.btnExit.setObjectName(&quot;btnExit&quot;) self.btnPause = QtWidgets.QPushButton(Form) self.btnPause.setGeometry(QtCore.QRect(270, 340, 81, 41)) self.btnPause.setStyleSheet(&quot;color:#fff;background: #333;&quot;) self.btnPause.setObjectName(&quot;btnPause&quot;) self.btnResume = QtWidgets.QPushButton(Form) self.btnResume.setGeometry(QtCore.QRect(180, 340, 81, 41)) self.btnResume.setStyleSheet(&quot;color:#fff;background: #333;&quot;) self.btnResume.setObjectName(&quot;btnResume&quot;) self.btnConfirm = QtWidgets.QPushButton(Form) self.btnConfirm.setGeometry(QtCore.QRect(900, 200, 51, 31)) self.btnConfirm.setStyleSheet(&quot;color:#fff;background: #222;&quot;) self.btnConfirm.setObjectName(&quot;btnConfirm&quot;) self.btnTcpBegin = QtWidgets.QPushButton(Form) self.btnTcpBegin.setGeometry(QtCore.QRect(590, 100, 91, 31)) self.btnTcpBegin.setStyleSheet(&quot;color:#fff;background: #333;&quot;) self.btnTcpBegin.setObjectName(&quot;btnTcpBegin&quot;) self.textLog = QtWidgets.QTextBrowser(Form) self.textLog.setGeometry(QtCore.QRect(570, 270, 371, 171)) self.textLog.setStyleSheet(&quot;color:#fff;background: #333;&quot;) self.textLog.setLineWidth(1) self.textLog.setObjectName(&quot;textLog&quot;) self.progressBar = QtWidgets.QProgressBar(Form) self.progressBar.setGeometry(QtCore.QRect(40, 350, 118, 23)) self.progressBar.setStyleSheet(&quot;color:#fff;background: #666;&quot;) self.progressBar.setProperty(&quot;value&quot;, 11) self.progressBar.setTextVisible(True) self.progressBar.setObjectName(&quot;progressBar&quot;) self.label = QtWidgets.QLabel(Form) self.label.setGeometry(QtCore.QRect(560, 40, 81, 31)) self.label.setStyleSheet(&quot;color:#fff;&quot;) self.label.setFrameShadow(QtWidgets.QFrame.Plain) self.label.setTextFormat(QtCore.Qt.RichText) self.label.setObjectName(&quot;label&quot;) self.lineEditW = QtWidgets.QLineEdit(Form) self.lineEditW.setGeometry(QtCore.QRect(690, 70, 41, 21)) self.lineEditW.setStyleSheet(&quot;color:#fff;background: #333;&quot;) self.lineEditW.setObjectName(&quot;lineEditW&quot;) self.label_2 = QtWidgets.QLabel(Form) self.label_2.setGeometry(QtCore.QRect(590, 70, 91, 21)) self.label_2.setStyleSheet(&quot;color:#fff;&quot;) self.label_2.setObjectName(&quot;label_2&quot;) self.label_3 = QtWidgets.QLabel(Form) self.label_3.setGeometry(QtCore.QRect(750, 70, 21, 21)) self.label_3.setStyleSheet(&quot;color:#fff;&quot;) self.label_3.setObjectName(&quot;label_3&quot;) self.lineEditH = QtWidgets.QLineEdit(Form) self.lineEditH.setGeometry(QtCore.QRect(770, 70, 41, 21)) self.lineEditH.setStyleSheet(&quot;color:#fff;background: #333;&quot;) self.lineEditH.setObjectName(&quot;lineEditH&quot;) self.label_4 = QtWidgets.QLabel(Form) self.label_4.setGeometry(QtCore.QRect(820, 70, 71, 21)) self.label_4.setStyleSheet(&quot;color:#fff;&quot;) self.label_4.setObjectName(&quot;label_4&quot;) self.lineEditScale = QtWidgets.QLineEdit(Form) self.lineEditScale.setGeometry(QtCore.QRect(890, 70, 41, 21)) self.lineEditScale.setStyleSheet(&quot;color:#fff;background: #333;&quot;) self.lineEditScale.setObjectName(&quot;lineEditScale&quot;) self.label_5 = QtWidgets.QLabel(Form) self.label_5.setGeometry(QtCore.QRect(560, 250, 41, 16)) self.label_5.setStyleSheet(&quot;color:#fff;&quot;) self.label_5.setObjectName(&quot;label_5&quot;) self.sliderThresh = QtWidgets.QSlider(Form) self.sliderThresh.setEnabled(True) self.sliderThresh.setGeometry(QtCore.QRect(690, 150, 160, 22)) self.sliderThresh.setToolTip(&quot;&quot;) self.sliderThresh.setStyleSheet(&quot;color:#f00;background: #222;&quot;) self.sliderThresh.setMaximum(255) self.sliderThresh.setProperty(&quot;value&quot;, 119) self.sliderThresh.setSliderPosition(119) self.sliderThresh.setTracking(True) self.sliderThresh.setOrientation(QtCore.Qt.Horizontal) self.sliderThresh.setTickPosition(QtWidgets.QSlider.NoTicks) self.sliderThresh.setTickInterval(10) self.sliderThresh.setObjectName(&quot;sliderThresh&quot;) self.label_6 = QtWidgets.QLabel(Form) self.label_6.setGeometry(QtCore.QRect(560, 150, 121, 16)) self.label_6.setStyleSheet(&quot;color:#fff;&quot;) self.label_6.setObjectName(&quot;label_6&quot;) self.labelThresh = QtWidgets.QLabel(Form) self.labelThresh.setGeometry(QtCore.QRect(860, 150, 31, 21)) self.labelThresh.setStyleSheet(&quot;background: #222;\\n&quot;&quot;&quot;) self.labelThresh.setObjectName(&quot;labelThresh&quot;) self.retranslateUi(Form) self.btnExit.clicked.connect(Form.btnExitClick) self.btnResume.clicked.connect(Form.btnResumeClick) self.btnPause.clicked.connect(Form.btnPauseClick) self.btnTcpBegin.clicked.connect(Form.btnTcpBeginClick) self.btnInputVideo.clicked.connect(Form.btnInputVideoClick) self.btnConfirm.clicked.connect(Form.btnConfirmClick) QtCore.QMetaObject.connectSlotsByName(Form) def retranslateUi(self, Form): _translate = QtCore.QCoreApplication.translate Form.setWindowTitle(_translate(&quot;Form&quot;, &quot;视频传输&quot;)) self.btnInputVideo.setText(_translate(&quot;Form&quot;, &quot;浏览&quot;)) self.editVideoInput.setPlaceholderText(_translate(&quot;Form&quot;, &quot;输入gif图片或视频地址&quot;)) self.imgLabel.setText(_translate(&quot;Form&quot;, &quot;imgLabel&quot;)) self.btnExit.setStyleSheet(_translate(&quot;Form&quot;, &quot;color:#fff;background: #333;&quot;)) self.btnExit.setText(_translate(&quot;Form&quot;, &quot;退出&quot;)) self.btnPause.setText(_translate(&quot;Form&quot;, &quot;暂停&quot;)) self.btnResume.setText(_translate(&quot;Form&quot;, &quot;继续&quot;)) self.btnConfirm.setText(_translate(&quot;Form&quot;, &quot;确认&quot;)) self.btnTcpBegin.setText(_translate(&quot;Form&quot;, &quot;启动服务器&quot;)) self.label.setText(_translate(&quot;Form&quot;, &quot;基本配置&quot;)) self.lineEditW.setText(_translate(&quot;Form&quot;, &quot;128&quot;)) self.label_2.setText(_translate(&quot;Form&quot;, &quot;OLED屏幕 宽&quot;)) self.label_3.setText(_translate(&quot;Form&quot;, &quot;高&quot;)) self.lineEditH.setText(_translate(&quot;Form&quot;, &quot;64&quot;)) self.label_4.setText(_translate(&quot;Form&quot;, &quot;缩放系数&quot;)) self.lineEditScale.setText(_translate(&quot;Form&quot;, &quot;1&quot;)) self.label_5.setText(_translate(&quot;Form&quot;, &quot;日志&quot;)) self.label_6.setText(_translate(&quot;Form&quot;, &quot;图片对比度调节&quot;)) self.labelThresh.setText(_translate(&quot;Form&quot;, &quot;0&quot;)) videoProcess.py 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import cv2import socket# 读取一帧，参数video为cv2.readCapture(path=&quot;xxx/xxx.mp4&quot;)def getOneFrame(video): ret, frame = video.read() if ret: return (True, frame) return (False, 0)# 修改图像尺寸def frameResize(frame, wid, hei): frame = cv2.resize(frame, dsize=(wid, hei)) return framedef getImgModeList(frame, thresh=127) -&gt; list: &#x27;&#x27;&#x27; return: 返回图像取模后的结果 参数: - frame: 视频中的一帧，实际上是cv2格式(BGR)的图片 - thresh: 二值化灰度图的门限值 &#x27;&#x27;&#x27; imgGrey = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY) ret, imgResult = cv2.threshold(imgGrey, thresh, 255, cv2.THRESH_BINARY) # 返回 阈值 和 图像 h, w = imgResult.shape # return 0 resultList = [] for i in range(h): tmp = w k = 0 while True: rowCode = &#x27;&#x27; for j in range(k, min(k+8, tmp)): # 阴码：黑色表示1，白色255表示0， # rowCode += (&#x27;0&#x27; if imgBin[i][j] &gt; 100 else &#x27;1&#x27;) # 阳码，黑色为0，不点亮，白色为1，点亮 rowCode += (&#x27;1&#x27; if imgResult[i][j] &gt; 200 else &#x27;0&#x27;) if len(rowCode) &lt; 8: # rowCode += (&#x27;0&#x27; * (8-len(rowCode))) # 阴码 rowCode += (&#x27;1&#x27; * (8-len(rowCode))) # 阳码 rowCode = rowCode[::-1] # 倒序，对应pctLot2002顺向 k += 8 resultList.append(int(rowCode, 2)) if k &gt;= tmp: break return resultList main.py 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218from PyQt5 import QtWidgets, QtGui, QtCorefrom gui import Ui_Formimport sysimport cv2import threadingimport socketfrom queue import Queueimport videoProcess as vp# 配置oledWidth, oledHeight= 128, 64imgToOledScale = 0.5 # 发给oled的图片缩放系数# 全局变量modesQue = Queue(5000)imgToQtQue = Queue(5000)isConnected = False# progressValue = 0 # 播放进度值imgToOled = None# frameCount = 0 # 总帧数# curFrame = 0 # 当前帧class MyUi(QtWidgets.QWidget, Ui_Form): def __init__(self) -&gt; None: super().__init__() self.setupUi(self) # QtWidgets.QApplication.setStyle(QtWidgets.QStyleFactory.create(&#x27;windows&#x27;)) # Windows Fusion self.imgLabelWidth = self.imgLabel.width() self.imgLabelHeight = self.imgLabel.height() self.thresh = 130 self.timer1 = QtCore.QTimer() # 10ms self.timer2 = QtCore.QTimer() self.timer3 = QtCore.QTimer() self.timer1.timeout.connect(self.getModesQue) self.timer2.timeout.connect(self.showImgToQt) self.timer3.timeout.connect(self.updateRegularly) self.editVideoInput.setText(&#x27;../../assets/badapple1.mp4&#x27;) # self.labelThresh.setText(str(self.thresh)) self.sliderThresh.setValue(self.thresh) self.videoPath = &#x27;&#x27; self.pauseFlag = False self.exitFlag = False self.frameCount = 0 self.curFrame = 0 self.progressValue = 0 self.timer3.start(50) def btnInputVideoClick(self): self.videoPath, _ = QtWidgets.QFileDialog.getOpenFileName(self, &#x27;打开视频&#x27;, r&#x27;../../assets&#x27;) self.editVideoInput.setText(self.videoPath) def btnConfirmClick(self): if not isConnected: self.printLog(&quot;客户端还未连接。。。&quot;) return self.config() # global frameCount, curFrame # curFrame = 0 self.videoPath = self.editVideoInput.text() self.sliderThresh.setValue(self.thresh) self.printLog(f&quot;开始播放视频: &#123;self.videoPath&#125;&quot;) self.printLog( &#x27;正在播放视频，过程中:\\n&#x27;+ &#x27;1.可以暂停/继续\\n&#x27;+ &#x27;2.切换其它视频(选择视频后可以重新配置OLED信息，之后记得点击确认)\\n&#x27;+ &#x27;3.调节OLED图片对比度&#x27;) imgToQtQue.queue.clear() modesQue.queue.clear() self.video = cv2.VideoCapture(self.videoPath) if self.video.isOpened(): self.frameCount = self.video.get(7) self.timer1.start(20) self.timer2.start(45) def btnTcpBeginClick(self): self.config() self.sockThread = SocketThread() self.sockThread.start() self.printLog(&quot;服务器已启动，请选择要播放的视频或GIF动图，然后等待客户端连接&quot;) def btnPauseClick(self): if not isConnected: return self.pauseFlag = True self.sockThread.pause() self.printLog(&quot;已暂停&quot;) def btnResumeClick(self): if not isConnected: return self.pauseFlag = False self.sockThread.resume() self.printLog(&quot;已继续&quot;) def btnExitClick(self): try: self.sockThread.stop() except: pass self.close() def getModesQue(self): if self.video.isOpened(): ret, frame = vp.getOneFrame(self.video) if ret: imgToQtShow = vp.frameResize( frame, self.imgLabelWidth, self.imgLabelHeight) imgToQtQue.put(imgToQtShow) imgToOLED1 = vp.frameResize(frame, int( oledWidth*imgToOledScale), int(oledHeight*imgToOledScale)) modesQue.put(vp.getImgModeList(imgToOLED1, thresh=self.thresh)) else: self.video.release() def showImgToQt(self): global imgToOled if not imgToQtQue.empty() and (not self.pauseFlag): self.curFrame +=1 self.progressValue = int(self.curFrame/self.frameCount*100) if not modesQue.empty(): imgToOled = modesQue.get() shrink = cv2.cvtColor(imgToQtQue.get(), cv2.COLOR_BGR2RGB) # cv 图片转换成 qt图片 qtImg = QtGui.QImage(shrink.data, # 数据源 shrink.shape[1], # 宽度 shrink.shape[0], # 高度 shrink.shape[1] * 3, # 行字节数 QtGui.QImage.Format_RGB888) # label 控件显示图片 self.imgLabel.setPixmap(QtGui.QPixmap(qtImg)) # self.imgLabel.show() def config(self): global oledHeight, oledWidth, imgToOledScale oledWidth = int(self.lineEditW.text()) oledHeight = int(self.lineEditH.text()) imgToOledScale = float(self.lineEditScale.text()) self.printLog(f&quot;oled宽:&#123;oledWidth&#125; 高:&#123;oledHeight&#125; 缩放系数:&#123;imgToOledScale&#125;&quot;) def printLog(self, text): self.textLog.append(text) # 文本框逐条添加数据 self.textLog.append(&#x27;=&#x27;*40+&#x27;\\n&#x27;) self.textLog.ensureCursorVisible() def updateRegularly(self): self.thresh = self.sliderThresh.value() self.progressBar.setValue(self.progressValue) self.labelThresh.setText(str(self.thresh)) class SocketThread(threading.Thread): def __init__(self, host=&#x27;&#x27;, port=8762, bufferSize=1024): super().__init__() self.__e = threading.Event() self.__e.set() self.__e2 = threading.Event() self.__e2.set() self.host = host self.port = port self.bufferSize = bufferSize def run(self): global isConnected # with socket.socket() as s: with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s: # 绑定服务器地址和端口 s.bind((self.host, self.port)) # 启动服务监听 s.listen(4) myui.printLog(f&#x27;服务器启动，端口: &#123;self.port&#125;，等待用户接入&#x27;) # while video.isOpened(): # 等待客户端连接请求,获取connSock conn, addr = s.accept() isConnected = True myui.printLog(&#x27;客户端:&#123;&#125;已连接，请点击【确认】按钮开始播放视频&#x27;.format(addr)) with conn: while self.__e.isSet(): if modesQue.empty(): continue self.__e2.wait() # 接收请求信息 dataGet = conn.recv(self.bufferSize).decode(&#x27;utf-8&#x27;).strip() # print(&#x27;接收到信息：&#123;&#125;&#x27;.format(dataGet)) if dataGet == &#x27;S&#x27;: # if not modesQue.empty(): w = int(oledWidth * imgToOledScale) h = int(oledHeight * imgToOledScale) dataSend = w.to_bytes( 1, byteorder=&#x27;little&#x27;) + h.to_bytes(1, byteorder=&#x27;little&#x27;) conn.send(dataSend) # else: # print(&#x27;视频传输结束，等待输入新视频&#x27;) # break if dataGet == &#x27;D&#x27; and imgToOled!=None: # modeList = modesQue.get() # 每个元素是十进制的字符串形式 modeList = imgToOled dataSend = b&#x27;&#x27; for i in range(len(modeList)): dataSend += (modeList[i].to_bytes(1, byteorder=&#x27;little&#x27;)) # print(len(modeList)) # print(modeList) conn.send(dataSend) if dataGet == &#x27;N&#x27;: myui.printLog(&#x27;接收请求信息：&#123;&#125;，客户端要求关闭服务器&#x27;.format(dataGet)) break if dataGet == &#x27;&#x27;: myui.printLog(&#x27;客户端异常，连接断开&#x27;) break print(&quot;关闭连接&quot;) s.close() def stop(self): self.__e.clear() def pause(self): self.__e2.clear() def resume(self): self.__e2.set()if __name__ == &#x27;__main__&#x27;: app = QtWidgets.QApplication(sys.argv) myui = MyUi() myui.printLog(&#x27;注意：\\n1.请先配置OLED信息，然后点击【启动服务器】\\n2.选择要播放的视频\\n3.等待客户端连接，直到出现&quot;客户端xxx已连接&quot;即可\\n4.点击【确认】开始播放视频\\n5.播放过程可以随时切换视频、以及暂停&#x27;) myui.show() sys.exit(app.exec()) 3、TCP客户端实现 采用Arduino+u8g2库开发 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;WiFi.h&gt;#include &quot;U8g2lib.h&quot;//接线：SCL=19, SDA=18U8G2_SSD1306_128X64_NONAME_F_HW_I2C u8g2(U8G2_R0, /* reset=*/U8X8_PIN_NONE, /* clock=*/19, /* data=*/18); // ESP32 Thing, HW I2C with pin remapping//U8G2_SSD1306_128X64_NONAME_F_HW_I2C u8g2(U8G2_R0, /* reset=*/ U8X8_PIN_NONE);const char *ssid = &quot;xiaomi&quot;;const char *password = &quot;17191719&quot;;const IPAddress serverIP(192,168,43,157); //欲访问的地址uint16_t serverPort = 8762; //服务器端口号uint8_t w, h; // 图片宽高uint8_t img[4000] PROGMEM = &#123;0&#125;;uint8_t buff[4000] PROGMEM = &#123;0&#125;;WiFiClient client; //声明一个客户端对象，用于与服务器进行连接void setup()&#123; Serial.begin(115200); Serial.println(); WiFi.mode(WIFI_STA); WiFi.setSleep(false); //关闭STA模式下wifi休眠，提高响应速度 WiFi.begin(ssid, password); u8g2.begin(); while (WiFi.status() != WL_CONNECTED) &#123; delay(500); Serial.print(&quot;.&quot;); &#125; Serial.println(&quot;Connected&quot;); Serial.print(&quot;IP Address:&quot;); Serial.println(WiFi.localIP());&#125;uint8_t shape[2]; //宽高uint16_t read_count;//使图片显示到屏幕中间, w, h为图片宽高void showImg(uint8_t w, uint8_t h, uint8_t *img)&#123; uint8_t x, y; x = (128-w)/2; y = (64-h)/2; u8g2.clearBuffer(); u8g2.drawXBMP(x, y, w, h, img); u8g2.setFont(u8g2_font_ncenB14_tr); u8g2.sendBuffer();&#125;void loop()&#123; Serial.println(&quot;尝试连接服务器&quot;); if (client.connect(serverIP, serverPort)) //尝试访问目标地址 &#123; Serial.println(&quot;连接成功&quot;); client.print(&quot;S&quot;); //向服务器发送S,获取帧宽高 while(client.connected())&#123; while(1) &#123; if (client.available()) //如果有数据可读取 &#123; read_count = client.read(shape, 1024);//向缓冲区读取数据，read_count为读取到的数据长度 w = shape[0]; h = shape[1]; client.write(&quot;D&quot;); //发送D，获取图片数据（已经转换为u8g2能显示的格式） &#125; else continue; break; &#125; while(1) &#123; if(client.available()) //如果有数据可读取 &#123; read_count = client.read(buff, 2048); memcpy(img, buff, read_count);//将读取的buff字节地址复制给img_buff数组 client.write(&quot;S&quot;); &#125; else continue; showImg(w, h, img); memset(img,0,sizeof(img));//清空buff break; &#125; &#125; &#125; else &#123; Serial.println(&quot;访问失败&quot;); client.stop(); //关闭客户端 &#125; delay(500);&#125; 4、运行效果","categories":[{"name":"瞎折腾","slug":"瞎折腾","permalink":"https://blog.ajream.top/categories/%E7%9E%8E%E6%8A%98%E8%85%BE/"}],"tags":[{"name":"ESP32","slug":"ESP32","permalink":"https://blog.ajream.top/tags/ESP32/"},{"name":"Python","slug":"Python","permalink":"https://blog.ajream.top/tags/Python/"}]},{"title":"AcWing4622-整数拆分","slug":"哥德巴赫猜想解题","date":"2022-10-07T07:55:23.000Z","updated":"2024-03-31T14:49:40.667Z","comments":true,"path":"posts/87013241/","link":"","permalink":"https://blog.ajream.top/posts/87013241/","excerpt":"","text":"📌题目 题目：4622.整数拆分 我们规定 f(x)f(x)f(x)（x≥2）表示整数 x 的除本身之外的最大因数。 例如，f(6)=3f(6)=3f(6)=3，f(25)=5f(25)=5f(25)=5，f(2)=1f(2)=1f(2)=1 现在，给定一个整数 n，请你将其拆分为 k 份 n1,n2,...,nkn_1,n_2,...,n_kn1​,n2​,...,nk​（也可以不拆分，即 k=1），要求： n1+n2+...+nk=nn_1+n_2+...+n_k=nn1​+n2​+...+nk​=n 对于 1≤i≤k1≤i≤k1≤i≤k，ni≥2n_i≥2ni​≥2 始终成立。 f(n1)+f(n2)+…+f(nk)f(n_1)+f(n_2)+…+f(n_k)f(n1​)+f(n2​)+…+f(nk​) 的值应尽可能小。 输出 f(n1)+f(n2)+…+f(nk)f(n_1)+f(n_2)+…+f(n_k)f(n1​)+f(n2​)+…+f(nk​) 的最小可能值。 输入格式 一个整数 n 输出格式 一个整数，表示f(n1)+f(n2)+…+f(nk)f(n_1)+f(n_2)+…+f(n_k)f(n1​)+f(n2​)+…+f(nk​) 的最小可能值。 数据范围 前 4 个测试点满足 2≤n≤302≤n≤302≤n≤30。 所有测试点满足 2≤n≤2×1092≤n≤2×10^92≤n≤2×109 示例1 输入：4 输出：2 示例2 输入：27 输出：3 🔎题解 f(x)表示整数 x 的除本身之外的最大因数，那么当x为质数时，f(x)=1，所以这一题其实就是让我们用最少的质数相加得到x，质数的个数就是这一题的答案。 那么当x为质数时，f(x)直接就等于1了，不用拆分。 当x为偶数时，这里就要讲一个非常著名的猜想：哥德巴赫猜想。哥德巴赫猜想是说，对于任意一个大于2的偶数都可以拆分成两个质数之和（虽然只是猜想，没法验证，但是用起来是完全没问题的）。所以当x为偶数时，结果就是2。 当x为奇数时，我们要再分情况考虑： 如果x-2是一个质数，那么我们把x拆分成x-2和2就可以得到最小的结果，结果是2； 如果x-2不是质数，我们就可以把x拆分成3和一个偶数，这样的结果是3。 分析源自-&gt; 作者：你好A 链接：https://www.acwing.com/solution/content/140215/ 代码如下： 123456789101112131415161718192021222324252627282930#include &lt;cstdio&gt;#include &lt;cmath&gt;using namespace std;// 判断是否是质数bool isPrime(int n)&#123; for(int i=2; i&lt;=n/i; i++)&#123; if(n%i==0) return false; &#125; return true;&#125;int main()&#123; int n; scanf(&quot;%d&quot;, &amp;n); if(isPrime(n)) printf(&quot;%d&quot;, 1); // 如果是质数，不拆，结果是1 else if(n%2 == 0) printf(&quot;%d&quot;, 2); // 如果是偶数，可以拆成2个质数（哥德巴赫猜想），结果是2 else&#123; // 如果是奇数，看n-2是不是质数，是则拆成 (n-2)+2，否则拆成 3 + 一个偶数，结果是3 if(isPrime(n-2)) printf(&quot;%d&quot;, 2); else&#123; printf(&quot;%d&quot;, 3); &#125; &#125; return 0;&#125;","categories":[{"name":"算法题","slug":"算法题","permalink":"https://blog.ajream.top/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"AcWing","slug":"AcWing","permalink":"https://blog.ajream.top/tags/AcWing/"}]},{"title":"总结一下求极限的技巧","slug":"高数-求极限","date":"2022-09-14T07:55:23.000Z","updated":"2024-03-31T14:49:40.667Z","comments":true,"path":"posts/87d13e4d/","link":"","permalink":"https://blog.ajream.top/posts/87d13e4d/","excerpt":"","text":"等价无穷小替换 替换的前提是： \"x->0\"，x可以是其它表达式，只要满足【趋于0】这一条件即可 x~sin(x)~tan(x)~arcsin(x)~arctan(x)~ln(1+x)~e^x-1 (1+x)α−1∼αx(1+x)^\\alpha -1 \\sim \\alpha x(1+x)α−1∼αx 1−cos⁡x∼12x21-\\cos x \\sim \\frac{1}{2}x^21−cosx∼21​x2 x−sin⁡x∼16x3x-\\sin x \\sim \\frac{1}{6}x^3x−sinx∼61​x3 x−arcsin⁡x∼−16x3x -\\arcsin x \\sim -\\frac{1}{6}x^3x−arcsinx∼−61​x3 tan⁡x−x∼13x3\\tan x-x \\sim \\frac{1}{3}x^3tanx−x∼31​x3 arctan⁡x−x∼−13x3\\arctan x-x \\sim -\\frac{1}{3}x^3arctanx−x∼−31​x3 tan⁡x−sin⁡x∼12x3\\tan x-\\sin x \\sim \\frac{1}{2}x^3tanx−sinx∼21​x3 arctan⁡x−arcsin⁡x∼−12x3\\arctan x-\\arcsin x \\sim -\\frac{1}{2}x^3arctanx−arcsinx∼−21​x3 x−ln⁡(1+x)∼12x2x-\\ln(1+x)\\sim \\frac{1}{2}x^2x−ln(1+x)∼21​x2 替换时：乘除关系直接替换、加减关系尽量转为乘除后再替换 记住：相加的极限=极限的相加，即： 两个函数相加(减、乘、除)的极限=两个函数各自的极限（如果都存在的话）相加（减、乘、除）【如下例题第3题】，如果某个函数的极限不存在，则不成立，因为： 极限存在 + 极限不存在 = 极限不存在 对于 [f(x)+g(x)]/h(x)[f(x)+g(x)]/h(x)[f(x)+g(x)]/h(x)，如果发现f(x)可以进行等价替换，只将f(x)替换是错误的，如下例题第3题 洛必达+等价替换 能用泰勒公式的，都可以用洛必达+等价替换解决，我觉得应该是泰勒公式本身也是不断求导后得到的。（个人经验） 当你想用泰勒公式，但又记不清公式时，洛吧，一般洛个2次都可以做出来了 对于1∞1^∞1∞ 型 lim⁡x→0(1+x)1/x=lim⁡x→0e1xln⁡(1+x)=e\\lim_{x\\to 0}(1+x)^{1/x}=\\lim_{x\\to0}e^{\\frac{1}{x}\\ln(1+x)}=elimx→0​(1+x)1/x=limx→0​ex1​ln(1+x)=e 定积分型 通常是数列极限，能写成 ∑i=1n1nf(in)\\sum_{i=1}^n \\frac{1}{n}f(\\frac{i}n{})∑i=1n​n1​f(ni​) 形式的表达式，例如下面例题的22、23题 例题 源于[汤]-1800题（2022）","categories":[{"name":"考研","slug":"考研","permalink":"https://blog.ajream.top/categories/%E8%80%83%E7%A0%94/"}],"tags":[{"name":"高数","slug":"高数","permalink":"https://blog.ajream.top/tags/%E9%AB%98%E6%95%B0/"}]},{"title":"C语言scanf输入匹配","slug":"C-scanf","date":"2022-09-14T03:30:34.000Z","updated":"2022-09-14T04:46:03.000Z","comments":true,"path":"posts/63ad0f3/","link":"","permalink":"https://blog.ajream.top/posts/63ad0f3/","excerpt":"","text":"限定输入长度 输入int类型时可以限定输入长度 123int a;scanf(&quot;%3d&quot;, &amp;a); //取前3个数字，转为int类型存储到a变量中 输入char类型 注意输入char字符类型时不能限定长度（注意是字符，不是字符串） 笔者目前能查到的信息给出的原因：语法规定，其实想一下也说得通，读取一个字符，总不能scanf(“%2c”)把两个字符塞到一个字符的空间里吧 输入指定长度字符串 12char ss[20];scanf(&quot;%5s&quot;, ss); 输入只有指定字符的字符串 scanf匹配特定字符的格式为：%[xxx]，[ ]包围起来的是需要读取的字符集合 例如输入一个只含有 'x','y','z'的字符串 12char ss[10];scanf(&quot;%[xyz]&quot;, ss); // 输入xzab，则ss为xz，遇到a停止 注意，遇到其它字符就会停止输入 注意：xyz的顺序没有要求，输入yxz，zyx等是可以正常读入的 只含有大写字母 1scanf(&quot;%[A-Z]&quot;, ss); 只含有小写字母 1scanf(&quot;%[a-z]&quot;, ss); 只含有大小写字母 1scanf(&quot;%[a-zA-Z]&quot;, ss); 只含有数字 1scanf(&quot;%[0-9]&quot;, ss); 混合输入 例如要求输入的字符包括大小写字母以及空格 1scanf(&quot;%[a-z A-Z]&quot;, ss); 其实就是在中间加一个空格，意思是空格也算匹配字符如果输入中有空格符也会被正常读取; 空格的位置不一定要放在中间，可以放在最前面，也可以放在最后面 不匹配某些字符 不匹配某些字符只需要在[ ]内的最前面加一个^就可以了 例1，遇到数字就停止（不包含数字） 1scanf(&quot;%[^0-9]&quot;, ss); 例2，遇到换行符就停止，不包含换行符 1scanf(&quot;%[^\\n]&quot;, ss); 例3，遇到指定字符’a’, ‘c’, 'f’就停止 1scanf(&quot;%[^acf]&quot;, ss); 丢弃读取到的字符 scanf() 允许把读取到的数据直接丢弃，不往变量中存放，具体方法就是在 % 后面加一个*， 例如：将读取到的小写字母丢弃 1scanf(&quot;%*[a-z]&quot;); //因为丢弃了，所以不用放到一个变量中 123int a, b;scanf(&quot;%d%*[a-z]%d&quot;, &amp;a, &amp;b);// 输入 123ajfjfdfm654，则a为123，b为654，中间的小写字母被忽略了","categories":[{"name":"编程基础","slug":"编程基础","permalink":"https://blog.ajream.top/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://blog.ajream.top/tags/C-C/"}]},{"title":"明月寄相思","slug":"中秋","date":"2022-09-10T07:20:53.000Z","updated":"2022-09-10T09:22:43.000Z","comments":true,"path":"posts/e66575b7/","link":"","permalink":"https://blog.ajream.top/posts/e66575b7/","excerpt":"","text":"完整代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;中秋快乐&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; .wrap &#123; background: #000000; width: 100vw; height: 100vh; position: relative; &#125; .moon &#123; width: 15vw; height: 15vw; border-radius: 50%; background-image: linear-gradient(40deg, #f9fabe, #fffd3b); position: absolute; top: 10%; right: 20%; box-shadow: 0 0 30px 0px #fffd3b, 0 0 80px 0 #ffffff; animation: moonflashing 3s linear infinite; &#125; @keyframes moonflashing &#123; 0% &#123; filter: brightness(0.8); &#125; 50% &#123; filter: brightness(1.3); &#125; 100% &#123; filter: brightness(0.8); &#125; &#125; @keyframes starflashing &#123; 0% &#123; filter: brightness(0.3); &#125; 50% &#123; filter: brightness(1); &#125; 100% &#123; filter: brightness(0.3); &#125; &#125; .star &#123; width: 2px; height: 2px; border-radius: 50%; background: #ffffff; position: absolute; animation: starflashing 2s infinite; &#125; .star1 &#123; top: 50%; right: 20%; &#125; .star2 &#123; top: 70%; right: 30%; &#125; .star3 &#123; top: 40%; left: 20%; &#125; .star4 &#123; top: 60%; right: 10%; &#125; .star5 &#123; top: 55%; right: 44%; &#125; .star6 &#123; top: 10%; left: 30%; &#125; .star7 &#123; top: 15%; left: 20%; &#125; .meteor &#123; position: absolute; width: 4px; height: 4px; opacity: 0; background: #ffffff; border-radius: 50%; box-shadow: 0 0 5px 5px #636262; &#125; .meteor:after &#123; content: &quot;&quot;; display: block; border: 0px solid #fff; border-width: 2px 100px; border-color: transparent transparent transparent rgba(255, 255, 255, 0.3); transform: rotate(-45deg) translate3d(1px, 1px, 0); transform-origin: 0% 0%; &#125; .meteor1 &#123; top: 2vh; left: 30vw; animation: meteorflashing 2s infinite linear 1s; &#125; .meteor2 &#123; top: 22vh; left: 80vw; background: rgb(234, 0, 255); animation: meteorflashing 2s infinite linear 1s; &#125; .meteor3 &#123; top: 30vh; left: 40vw; animation: meteorflashing 3s infinite linear 2s; &#125; .meteor4 &#123; top: 10vh; left: 50vw; animation: meteorflashing 3s infinite linear 1s; &#125; .meteor5 &#123; top: 50vh; right: 2vw; animation: meteorflashing 3s infinite linear 3s; &#125; @keyframes meteorflashing &#123; 0% &#123; opacity: 0; transform: scale(0) translate3d(0, 0, 0); &#125; 50% &#123; opacity: 1; transform: scale(1) translate3d(-200px, 200px, 0); &#125; 100% &#123; opacity: 0; transform: scale(1) translate3d(-500px, 500px, 0); &#125; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;wrap&quot;&gt; &lt;div class=&quot;moon&quot;&gt;&lt;/div&gt; &lt;div class=&quot;star star1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;star star2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;star star3&quot;&gt;&lt;/div&gt; &lt;div class=&quot;star star4&quot;&gt;&lt;/div&gt; &lt;div class=&quot;star star5&quot;&gt;&lt;/div&gt; &lt;div class=&quot;star star6&quot;&gt;&lt;/div&gt; &lt;div class=&quot;star star7&quot;&gt;&lt;/div&gt; &lt;div class=&quot;meteor meteor1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;meteor meteor2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;meteor meteor3&quot;&gt;&lt;/div&gt; &lt;div class=&quot;meteor meteor4&quot;&gt;&lt;/div&gt; &lt;div class=&quot;meteor meteor5&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"娱乐","slug":"娱乐","permalink":"https://blog.ajream.top/categories/%E5%A8%B1%E4%B9%90/"}],"tags":[{"name":"节日","slug":"节日","permalink":"https://blog.ajream.top/tags/%E8%8A%82%E6%97%A5/"}]},{"title":"C++基础回顾","slug":"BasicC++","date":"2022-09-07T03:30:34.000Z","updated":"2022-09-07T04:30:03.000Z","comments":true,"path":"posts/e923dc73/","link":"","permalink":"https://blog.ajream.top/posts/e923dc73/","excerpt":"","text":"C++概述 由C发展而来，兼容C 组成： C语言 面向对象设计 泛型编程 标准模板库（STL） 数据类型 整型、浮点型、字符型、布尔型、空类型（void）、指针(*)、引用(&amp;) 结构体（struct）、共用体（union）、枚举（enum）、类（class） 整型字节长度： 一般short int（2B） &lt;= int（4B） &lt;= long int （4B、8B） 类型转换： 隐式类型转换：存储空间提升原则（short -&gt; int-&gt; long, signed-&gt;unsigned…） 显式类型转换，用法：自右向左(type)expr、自左向右type(expr) 变量 可以指定变量的存储空间 12345678auto int a; //自动存储，默认使用（auto可以不写）register int a; //使用cpu的寄存器来存放局部变量，变量不能用寄存器存储时，会转为auto存储static int a; //静态存储，声明周期与程序运行周期相同，函数未调用时已经分配好空间，但作用域为块作用域 函数 无返回值函数：返回语句用 return; 或不使用返回语句 有返回值函数：返回语句只能用 return 表达式; main函数由操作系统调用，返回0表示正常退出，否则表示异常退出 形式参数：函数在未调用前不占用内存 参数入栈：最右边的参数先进栈 const参数：用于限制对一个对象的修改操作，函数体内不能对该对象修改。 对于基本类型，不必使用const限定参数，但对于数组、指针这种传进来的是地址的参数，就有必要了 可变参数，用法： 123返回类型 func(type a,...)&#123;&#125; //用三个点来表示可变参数，三个点只能位于最后，前面至少有一个普通的参数 //获取可变参数方式：需要 #include&lt;cstdarg&gt;，具体可以百度 函数原型（或函数声明），如:(注意区别于函数定义) 1int add(int a, int b); //参数名可以省略 默认参数：只能设置一次（函数声明中设置了默认参数，函数定义就不能再设置，反之也一样） 一般在声明时设置函数参数 默认参数要自右向左设置 默认值可以是常数或全局变量，甚至是一个函数的调用（但调用的函数的实参必须是常量或全局变量，如下） 1void func1(int a, int b=func2(666)); //调用的函数func2传入的参数是常数666 内联函数 编译时直接将函数代码嵌入主调函数中，取消调用环节 内联函数的函数原型： 1inline 返回类型 funcName(形参列表); 内联函数定义 123inline 返回类型 funcName(形参列表)&#123;&#125; 注意内联函数不能是递归函数内联函数内部不能用 【循环语句】和【switch】语句编译器无法将内联函数嵌入时，会忽略 inline声明，按照普通函数处理 函数重载 针对的是一组同名函数 特征： 函数名相同，参数列表（参数类型或个数）不同 返回类型不一定相同 函数体没有要求 调用时，编译器根据传入的实参判断该使用哪个函数 函数模板 目的：设计通用型函数，与类型无关 定义： 12345template&lt;typename T1, typename T2&gt; 返回类型 funcName(参数列表)&#123; &#125;// &lt;typename T1, typename T2&gt;表示模板参数列表// typename 也可以换成class，但不建议换 如： 123template&lt;typename T&gt; T add(T a, T b)&#123; return a+b;&#125; 模板参数列表不必都表示类型，也可以是非类型形参(调用时要传入值)，如 123456template&lt;typename T1, int N&gt; void func(T a)&#123; cout&lt;&lt;N&lt;&lt;&quot; &quot;&lt;&lt;a;&#125;//调用：func&lt;int, 100&gt;(20); 内联模板函数 123template&lt;typename T1, typename T2&gt; inline 返回类型 funcName(参数列表)&#123; &#125; 内存结构 代码段(text) 存放程序执行的机器指令 已初始化数据段(data) 全局变量、静态变量，包括字符串、数组等常量 基本类型的常量一般被编译成指令存放在【代码区】 未初始化数据段(bss) 程序没有运行的时候bss段是不存在的，在运行时（main函数运行前）由操作系统根据变量类型分配内存空间 main函数运行前会把变量初始化为0，保证【全局、静态】变量在main函数运行前就已经分配好内存空间。 栈 存放所有局部、非静态变量；临时变量，包含函数形参、返回值 函数调用时，才分配存储空间，调用结束，释放相应内存空间 堆 存放动态分配的存储空间，其存储空间由程序员分配和释放，即执行到相应的代码块才会分配或释放存储空间 文件包含 123456#include &lt;xxx&gt; //只搜索系统路径的头文件#include &quot;xxx&quot; //先搜索源文件所处文件夹，再搜索系统路径的头文件// 头文件路径不是C++语法，因此不能理解为字符串，例如#include &quot;D:\\a\\b\\c.h&quot; //正确#include &quot;D:\\\\a\\\\b\\\\c.h&quot; //错误 使用 #ifdef、#ifndef等避免重复包含头文件（或 #pragma once 特殊预处理命令） 引用类型 主意啊，这里的&quot;引用&quot;要理解为名词，而不是动词 简单说来就是变量的别名，声明方式： 1类型 &amp;引用名=被引用的对象名 如： 12int x;int &amp;r=x; 引用的本质本质是位于某个内存地址上的指定类型的对象。上例中 r与x占用内存中【同一个存储单元】 其它需要注意的点： 引用在声明时必须指定引用的对象是谁 引用在声明后，不能再修改作为其它对象的引用 注意：函数参数是引用时，通常用const修饰，表示引用的对象不能通过引用修改，而不是说引用不能被修改（因为引用本身就不能被修改） 编译器不会专门开辟内存单元存储引用 引用的类型与被引用的类型要相同 函数返回类型是引用？ 首先说明：函数返回值时会产生一个【临时变量】作为函数返回值的副本（因为函数调用后局部变量会被销毁），而返回引用时不会产生临时变量。因此 千万不要引用函数中的局部变量（因为如果函数销毁了，引用变量指向谁？）如 如果函数参数是引用，可以返回引用，如下 123456789101112131415int&amp; func(int &amp;a, int&amp;b)&#123; return a; &#125;int main()&#123; int x=1, y=2, z=9; func(x, y) = z; //因为函数内return a; a引用的是x，所以这相当于x=z; cout &lt;&lt; &quot;x=&quot; &lt;&lt; x &lt;&lt;endl; cout &lt;&lt; &quot;y=&quot; &lt;&lt; y &lt;&lt;endl;&#125;//运行结果：//x=9//y=2 常引用 如果是常引用，表示不能通过引用来修改对象的值 1234int a=66;const int &amp;r = a;a = 55; //正确r = 10; //错误，不能通过引用来修改对象的值 C++对象创建2种方式 1234567891011121314151617181920212223242526#include&lt;stdio.h&gt;using namespace std;class ObjectClass&#123;public: void fun()&#123; printf(&quot;Hello, Im c++ objectClass\\n&quot;); &#125;&#125;;int main()&#123; ObjectClass obj1;//栈中分配 ，由操作系统进行内存的分配和管理 ObjectClass obj2 = obj1; //栈中分配 ，由操作系统进行内存的分配和管理 obj1.fun();//&quot;.&quot; 是结构体成员引用 obj2.fun();//&quot;.&quot; 是结构体成员引用 ObjectClass *obj3 = new ObjectClass(); //【堆】中分配 ，由管理者进行内存的分配和管理，用完必须delete()，否则可能造成内存泄漏 obj3-&gt;fun();//-&gt;是指针引用 delete(obj3); return 0;&#125; //运行root@A920:/system/bin # ./ObjectClassHello, Im c++ objectClassHello, Im c++ objectClassHello, Im c++ objectClass 上面就是具体的演示代码，下面分析一下几种创建方式： (1)第一种和第二种：这两种没什么区别，一个隐式调用，一个显式调用，两者都是在进程虚拟地址空间中的栈中分配内存。用这种方法创建的对象，内存分配到栈里（Stack）。使用 “.” 而不是 “-&gt;” 调用对象的方法。当程序离开对象的使用范围（如方法结束，一个程度块的最后{}），范围内的栈中的对象会自动删除，内存自动回收。这是创建对象最简单的方式栈是系统数据结构，对于线程/进程是唯一的，它的分配和释放由操作系统决定，不需要由开发者来管理。在执行函数时，函数内局部变量的存储单元可以在栈上创建，函数执行完毕，系统会自动释放这些存储单元。 (2)第三种：使用了new，在堆中分配了内存，堆上的内存分配，亦称动态内存分配。程序在运行的期间用malloc申请的内存，这部分内存由程序员自己负责管理，其生存期由开发者决定：在何时分配，分配多少，并在何时用free来释放该内存。这是唯一可以由开发者参与管理的内存。使用的好坏直接决定系统的性能和稳定。 注意：栈中内存的分配和管理由操作系统决定，而堆中内存的分配和管理由管理者决定。在堆中的对象不会自动删除，内存不会自动回收，所以new一个对象使用完毕，必须调用delete，释放内存空间。也就是说，new和delete必须成对出现 C++大、小根堆 默认创建大根堆（会自动对元素排序，然后从大到小插入素），遵循FIFO原则（即大的先进，也先出） 创建小根堆要加入 greater 参数 123456priority_queue&lt;int&gt; s;priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt; s;//以上两句代码等价。less表示按照递减(从大到小)的顺序插入元素priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; s;//greater表示创建小根堆，即按照递增（从小到大）的顺序插入元素 常用操作 12345s.push(1); //插入队尾s.pop(); //弹出队头top(); //查询顶部元素empty();size();","categories":[{"name":"编程基础","slug":"编程基础","permalink":"https://blog.ajream.top/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://blog.ajream.top/tags/C-C/"}]},{"title":"双指针","slug":"ltcode/快慢指针","date":"2022-09-04T03:45:08.000Z","updated":"2024-03-31T14:49:40.667Z","comments":true,"path":"posts/547a6cfd/","link":"","permalink":"https://blog.ajream.top/posts/547a6cfd/","excerpt":"","text":"🍬刷题前必看 前往原文查看 🍹开始刷题 - 力扣（LeetCode） 26. 删除有序数组中的重复项 给你一个 升序排列 的数组 nums ，请你** 原地** 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。 【示例 1】 12输入：nums = [1,1,2]输出：2, nums = [1,2,_] 解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。 【示例 2】 12输入：nums = [0,0,1,1,1,2,2,3,3,4]输出：5, nums = [0,1,2,3,4] 解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。 C++完整代码如下： 12345678910111213class Solution &#123;public: int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; if(nums.size()==1) return 1; int slow = 0, fast=1; // 快慢指针法 for(; fast&lt;nums.size(); fast++)&#123; if(nums[slow]!=nums[fast]) nums[++slow]=nums[fast]; &#125; return slow+1; &#125;&#125;; 283.移动零 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 请注意 ，必须在不复制数组的情况下原地对数组进行操作。 示例 1: 12输入: nums = [0,1,0,3,12]输出: [1,3,12,0,0] 示例 2: 12输入: nums = [0]输出: [0] 分析： 使用快慢指针，从前往后遍历 初始时慢指针slow最开始指向最左边第一个0的位置，快指针fast处于slow+1位置 当快指针fast遇到非0值时，交换slow和fast两个位置的值，并让slow++ 由于fast是从前往后遍历的，fast指向非0元素时才交换，而且slow每次都指向0，且每次交换值后均+1，所以不会导致原本非0元素相对顺序发生改变。（但0之间的相对位置发生改变，只不过都是0，改不改变都一样） C++完整代码： 123456789101112class Solution &#123;public: void moveZeroes(vector&lt;int&gt;&amp; nums) &#123; if(nums.size()==1) return; int slow = 0, fast = 1; while(slow&lt;nums.size() &amp;&amp; nums[slow]!=0) slow++;// 初始时让slow指向第一个0 fast = slow+1; for(; fast&lt;nums.size(); fast++)&#123; if(nums[fast]!=0) swap(nums[slow], nums[fast]), slow++; &#125; &#125;&#125;; 注意：另外一种遍历方法是从后往前遍历，slow指向最右边第一个【非0元素】，fast从右往左遍历，只要遇到0就与slow位置的值交换，这样会导致非0元素之间的相对顺序发生改变，而0元素之间的相对位置没变 844. 比较含退格的字符串 给定 s 和 t 两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回 true 。# 代表退格字符。 注意：如果对空文本输入退格字符，文本继续为空。 示例 1： 123输入：s = &quot;ab#c&quot;, t = &quot;ad#c&quot;输出：true解释：s 和 t 都会变成 &quot;ac&quot;。 示例 2： 123输入：s = &quot;ab##&quot;, t = &quot;c#d#&quot;输出：true解释：s 和 t 都会变成 &quot;&quot;。 示例 3： 123输入：s = &quot;a#c&quot;, t = &quot;b&quot;输出：false解释：s 会变成 &quot;c&quot;，但 t 仍然是 &quot;b&quot;。 提示： 1 &lt;= s.length, t.length &lt;= 200 s 和 t 只含有小写字母以及字符 '#' 分析：原文查看@demigodliu 准备两个指针 i, j 分别指向 S，T 的末位字符，再准备两个变量 skipS，skipT 来分别存放 S，T 字符串中的 # 数量。 从后往前遍历 S，所遇情况有三，如下所示： 若当前字符是 #，则 skipS++； 若当前字符不是 #，且 skipS 不为 0，则 skipS–； 若当前字符不是 #，且 skipS 为 0，则代表当前字符不会被消除，我们可以用来和 T 中的当前字符作比较： 若对比过程出现 S, T 当前字符不匹配，则遍历结束，返回 false 若 S，T 都遍历结束，且都能一一匹配，则返回 true。 C++完整代码 123456789101112131415161718192021222324252627class Solution &#123;public: bool backspaceCompare(string s, string t) &#123; int i=s.size()-1, j=t.size()-1; int skipS = 0, skipT = 0; // skip表示待删除字符数量 while(i&gt;=0 || j&gt;=0)&#123; while(i&gt;=0)&#123; if(s[i]==&#x27;#&#x27;) i--, skipS++; //当前字符是 # else if(skipS&gt;0) i--, skipS--; else break; &#125; while(j&gt;=0)&#123; if(t[j]==&#x27;#&#x27;) j--, skipT++; else if(skipT&gt;0) j--, skipT--; else break; &#125; if(i&gt;=0 &amp;&amp; j&gt;=0 &amp;&amp; s[i]!=&#x27;#&#x27; &amp;&amp; t[j] != &#x27;#&#x27;)&#123; if(s[i]!=t[j]) return false; else i--, j--; &#125; else &#123; return i==j; // 如果i，j某一个&lt;0，则判断它们是否相等，如果同时都是-1，那就是说之前的比较都正确，如果一个指向0，一个指向-1，那就是某个串还没完，另一个已经比较完了 &#125; &#125; return true; &#125;&#125;;","categories":[{"name":"算法题","slug":"算法题","permalink":"https://blog.ajream.top/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://blog.ajream.top/tags/leetcode/"}]},{"title":"stellar博客改进方案","slug":"Hexo/stellar博客修改","date":"2022-09-03T07:56:51.000Z","updated":"2024-03-31T14:49:40.667Z","comments":true,"path":"posts/94c1e505/","link":"","permalink":"https://blog.ajream.top/posts/94c1e505/","excerpt":"注意现在是2023-09-14，本文章写于2022年，使用stellar作为博客主题的时候，该博客记录了我使用stellar主题时所做出的一些修改。 因为stellar默认不支持代码复制、返回顶部按钮等以及教程存在的一些小问题没弄清楚，于是记录一下修改的过程 注：一些教程看不明白的可以直接参考作者仓库XAOXUU的config文件进行修改","text":"注意现在是2023-09-14，本文章写于2022年，使用stellar作为博客主题的时候，该博客记录了我使用stellar主题时所做出的一些修改。 因为stellar默认不支持代码复制、返回顶部按钮等以及教程存在的一些小问题没弄清楚，于是记录一下修改的过程 注：一些教程看不明白的可以直接参考作者仓库XAOXUU的config文件进行修改 代码复制按钮 第一步，首先新建一个custom文件夹(用于存放自己的css代码)在 themes/stellar/source/css/下，然后新建一个css文件 themes/stellar/source/css/custom/code_copy.css，粘贴下面的代码： 123456789101112131415161718192021222324252627282930313233343536373839/* 代码块复制按钮 */.highlight &#123; /* 方便copy代码按钮（btn-copy）的定位 */ position: relative;&#125;.btn-copy &#123; display: inline-block; cursor: pointer; background-color: #eee; background-image: linear-gradient(#fcfcfc, #eee); border: 1px solid #d5d5d5; border-radius: 3px; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; -webkit-appearance: none; font-size: 13px; font-weight: 700; line-height: 20px; color: #333; -webkit-transition: opacity .3s ease-in-out; -o-transition: opacity .3s ease-in-out; transition: opacity .3s ease-in-out; padding: 2px 6px; position: absolute; right: 5px; top: 5px; opacity: 0;&#125;.btn-copy span &#123; margin-left: 5px;&#125;.highlight:hover .btn-copy &#123; opacity: 1;&#125; 第二步，新建一个custom文件夹(用于存放自己的js代码)在 themes/stellar/source/js/下，然后新建一个js文件 themes/stellar/source/css/custom/custom.js，粘贴下面的js代码： 1234567891011121314151617181920212223242526272829303132333435363738// 代码复制按钮$(function () &#123; $(&quot;.highlight&quot;).wrap(&quot;&lt;div class=&#x27;code-wrapper&#x27; style=&#x27;position:relative&#x27;&gt;&lt;/div&gt;&quot;); /*页面载入完成后，创建复制按钮*/ !function (e, t, a) &#123; /* code */ var initCopyCode = function () &#123; var copyHtml = &#x27;&#x27;; copyHtml += &#x27;&lt;button class=&quot;btn-copy&quot; data-clipboard-snippet=&quot;&quot;&gt;&#x27;; copyHtml += &#x27; &lt;i class=&quot;fa fa-clipboard&quot;&gt;&lt;/i&gt;&lt;span&gt;复制&lt;/span&gt;&#x27;; copyHtml += &#x27;&lt;/button&gt;&#x27;; $(&quot;.highlight .code&quot;).before(copyHtml); var clipboard = new ClipboardJS(&#x27;.btn-copy&#x27;, &#123; target: function (trigger) &#123; return trigger.nextElementSibling; &#125; &#125;); clipboard.on(&#x27;success&#x27;, function (e) &#123; e.trigger.innerHTML = &quot;&lt;i class=&#x27;fa fa-clipboard&#x27;&gt;&lt;/i&gt;&lt;span&gt;复制成功&lt;/span&gt;&quot; setTimeout(function () &#123; e.trigger.innerHTML = &quot;&lt;i class=&#x27;fa fa-clipboard&#x27;&gt;&lt;/i&gt;&lt;span&gt;复制&lt;/span&gt;&quot; &#125;, 1000) e.clearSelection(); &#125;); clipboard.on(&#x27;error&#x27;, function (e) &#123; e.trigger.innerHTML = &quot;&lt;i class=&#x27;fa fa-clipboard&#x27;&gt;&lt;/i&gt;&lt;span&gt;复制失败&lt;/span&gt;&quot; setTimeout(function () &#123; e.trigger.innerHTML = &quot;&lt;i class=&#x27;fa fa-clipboard&#x27;&gt;&lt;/i&gt;&lt;span&gt;复制&lt;/span&gt;&quot; &#125;, 1000) e.clearSelection(); &#125;); &#125; initCopyCode(); &#125;(window, document);&#125;) 第三步，引入文件 在 blog/_config.yml下，引入上面的 css、js 和一个外部的js文件，如下 12345678inject: head: - &lt;script defer src=&quot;https://fastly.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js&quot;&gt;&lt;/script&gt; - &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/css/custom/code_copy.css&quot; /&gt; script: - &lt;script defer src=&quot;/js/custom/custom.js&quot;&gt;&lt;/script&gt; # 代码复制按钮 - &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.js&quot;&gt;&lt;/script&gt; # 这个也是实现代码复制功能的，也要引入 效果如下： 返回顶部按钮 参照B站的设计 第一步，添加css 创建 themes/stellar/source/css/custom/return_top_bilibili.css 代码去这个网站复制，全部复制下来。 其中用到一张图片，如下，把它保存下来，方便自己引用： 修改如下代码中 background-image为上面这张图片的地址 123456.back-to-top &#123; background-image: url(https://xxx/xx/x/space-to-top.png); width: 120px; height: 130px;...... &#125; 第二步，添加js（直接在之前创建的themes/stellar/source/css/custom/custom.js）文件的最后添加如下代码即可。 123456789101112131415161718192021222324252627282930313233// 哔哩哔哩返回顶部按钮$(function () &#123; document.body.insertAdjacentHTML(&quot;beforeend&quot;, `&lt;div class=&quot;back-to-top&quot;&gt;&lt;/div&gt;`); $(&#x27;.back-to-top&#x27;).css(&#x27;display&#x27;, &#x27;none&#x27;); //scroll 事件适用于所有可滚动的元素和 window 对象（浏览器窗口）。 $(window).scroll(function () &#123; var scroHei = $(window).scrollTop();//滚动的高度 if (scroHei &gt; 200) &#123; // $(&#x27;.back-to-top&#x27;).css(&#x27;top&#x27;, &#x27;300px&#x27;); $(&#x27;.back-to-top&#x27;).fadeIn(); &#125; else &#123; // $(&#x27;.back-to-top&#x27;).css(&#x27;top&#x27;, &#x27;-999px&#x27;); $(&#x27;.back-to-top&#x27;).fadeOut(); if ($(window).scrollTop() === 0) &#123; $(&#x27;.back-to-top&#x27;).css(&#x27;animation&#x27;, &#x27;&#x27;); &#125; &#125; &#125;) /*点击返回顶部*/ $(&#x27;.back-to-top&#x27;).click(function () &#123; this.style = &#x27;animation: to-top-fly 0.5s steps(1) infinite;&#x27; $(&#x27;body,html&#x27;).animate(&#123; scrollTop: 0, &#125;, 600); &#125;)&#125;) 第三步，在blog/_config.yml中引入 1234567inject: head: - &lt;script defer src=&quot;https://fastly.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js&quot;&gt;&lt;/script&gt; # jquery需要在&lt;head&gt;&lt;/head&gt;引入 - &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/css/custom/return_top_bilibili.css&quot; /&gt; script: - &lt;script defer src=&quot;/js/custom/custom.js&quot;&gt;&lt;/script&gt; # 返回顶部按钮、代码复制按钮 最终效果如下： 页脚添加运行时间和网站访问量 修改 ejs 文件： themes\\stellar\\layout\\_partial\\main\\footer.ejs 添加如下： 1234567891011121314151617181920el += &#x27;&lt;/div&gt;&#x27;;// 站点运行时间el += &#x27;&lt;div class=&quot;site-statistics&quot;&gt;&#x27;;if(theme.footer.runtime.show) &#123;var start = theme.footer.runtime.starttime;el += &#x27;&lt;span class=&quot;site-runtime&quot;&gt;&#x27;; el+=&#x27;&lt;/span&gt;&#x27;;&#125;// 网站统计el += &#x27;&lt;span id=&quot;busuanzi_container_site_pv&quot;&gt;&#x27;;el += &#x27; 访问量: &lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;&#x27;;el += &#x27; 访客数: &lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;&#x27;;el += &#x27;&lt;/span&gt;&#x27;; el += &#x27;&lt;/div&gt;&#x27;;// 结束el += &#x27;&lt;/footer&gt;&#x27;;return el; 添加js：themes\\stellar\\source\\js\\custom\\custom.js 12345678910111213141516171819202122232425262728293031323334// 站点运行时间计算，传入参数为站点部署时间function showRuntime(startTime) &#123; var startDate = new Date(startTime); var now = new Date(); var diffms = now - startDate; // 相差毫秒数 var diffDays = Math.floor(diffms / (24 * 3600 * 1000));//计算出相差天数 var leftms1 = diffms % (24*3600*1000); // 剩余ms数 var hours = Math.floor(leftms1 / (3600 * 1000)); var leftms2 = leftms1 % (3600 * 1000); var minutes = Math.floor(leftms2 / (60 * 1000)); var leftms3 = leftms2 % (60 * 1000); var seconds = Math.floor(leftms3 / (1000)); var ans = [diffDays, hours, minutes, seconds]; for (var i = 0; i &lt; ans.length; i++) &#123; if(i==0)&#123; ans[i] = &#x27;&#x27;+ans[i]; &#125; else &#123; if(ans[i]&lt;10) ans[i] = &#x27;0&#x27; + ans[i]; else ans[i] = &#x27;&#x27;+ans[i] &#125; &#125; text = &#x27;&#x27;; text += &#x27;&lt;span&gt;&#x27;; text += &#x27;本站已运行 &#x27; + ans[0] + &#x27; 天&#x27; + ans[1] + &#x27; 小时 &#x27; + ans[2] + &#x27; 分 &#x27; + ans[3] + &#x27; 秒&#x27;; text += &#x27;&lt;/span&gt;&#x27;; $(&#x27;.site-runtime&#x27;).empty().append(text); &#125; $(setInterval(&#x27;showRuntime(&quot;2021-08-20 11:03:45&quot;)&#x27;, 250)); // 设置站点第一次部署的时间 在_config.yml引入不蒜子js，用于统计网站访问量 123inject: script: - &lt;script async src=&quot;https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; # 站点统计 添加css：themes\\stellar\\source\\css\\custom\\custom.css 1234567891011121314151617181920212223242526/* 页脚运行时间 */.site-statistics &#123; margin-top: 10px; width: fit-content; border: 1px solid #6982798f; padding: 4px 1px; /*上下 左右*/ color: rgb(150, 194, 166);&#125; .site-runtime &#123; margin: 0px 30px 0 0px; /*上右下左*/&#125; /* 页脚访问量 */#busuanzi_container_site_pv &#123; color: rgba(196, 137, 200, 0.71);&#125; #busuanzi_value_site_pv &#123; margin-right: 30px;&#125; #busuanzi_value_site_uv &#123; margin-right: 10px;&#125; 最后记得在_config.yml引入自己的js和css，然后就大功告成了！ 小问题 在wiki项目的文章点击&lt;-所有项目会返回主页，而不是wiki所在项目页，需要在_config.yml添加下面这行代码：1wiki_dir: wiki 文章链接不想显示后面的 index.html，修改 _config.yml如下配置，同时每篇md文章都要分开放在一个文件夹内，然后md文件名为 index.md123pretty_urls: trailing_index: false # Set to false to remove trailing &#x27;index.html&#x27; from permalinks trailing_html: true # Set to false to remove trailing &#x27;.html&#x27; from permalinks","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://blog.ajream.top/categories/Hexo/"}],"tags":[{"name":"stellar","slug":"stellar","permalink":"https://blog.ajream.top/tags/stellar/"}]},{"title":"网页版个人简历部署（下）","slug":"简历部署(下)","date":"2022-08-13T07:24:40.000Z","updated":"2022-08-13T07:38:33.000Z","comments":true,"path":"posts/f8eba496/","link":"","permalink":"https://blog.ajream.top/posts/f8eba496/","excerpt":"","text":"部署后效果 密码校验 在上一篇文章中已经部署好了简历，但如果不想让别人访问自己的简历咋办，很容易想到用密码，但有几个问题需要解决： 密码不能写在前端代码里，否则别人一个F12就把你代码里外看得清清楚楚的了。 前端写不了，但这是静态网站，没有后端怎么办？ 鉴于以上情况，我选择使用vercel云函数api来实现这个应该由后端实现的功能。 思路大体上是： 用户通过前端输入密码 前端代码使用post方式将密码发送给vercel的api api接收到数据后，判断前端输入的密码与提前设置好的密码是否一致，并返回 true/false 给前端 前端收到true则密码正确，放行；否则不放行。 前端代码 前端完整项目 登录页面 首先要写一个简单的登录页面 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;登录&lt;/title&gt; &lt;script src=&quot;https://upcdn.b0.upaiyun.com/libs/jquery/jquery-2.0.2.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;style&gt; .container &#123; width: 400px; height: 200px; background-color: aliceblue; position: relative; margin: 150px auto; display: flex; justify-content: center; align-items: center; border: 2px solid #55557f; &#125; .myForm &#123; width: 300px; height: 100px; &#125; .myForm .submit-btn &#123; margin-top: 20px; &#125; .btn&#123; border: #55557f 1px solid; margin-top: 10px; width: fit-content; padding: 5px; &#125; .btn:hover&#123; cursor: pointer; &#125; .btn:active&#123; color: blue; &#125; &lt;/style&gt; &lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;content&quot;&gt; &lt;p&gt;密码输入：&lt;/p&gt; &lt;input type=&quot;password&quot; class=&quot;pwd_input&quot;&gt; &lt;div class=&quot;btn submit&quot;&gt;提交&lt;/div&gt; &lt;!-- &lt;div class=&quot;btn exit&quot;&gt;清除密码&lt;/div&gt; --&gt; &lt;/div&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; var pwd = &#x27;&#x27;; var flag = false; $(&#x27;.submit&#x27;).click(function() &#123; pwd = $(&#x27;.pwd_input&#x27;).val(); $.post(&#x27;https://vercel-ver-api.vercel.app/api/ver_js&#x27;, &#123;&#x27;pwd&#x27;: pwd&#125;, (data_res, textStatus, jqxhr)=&gt;&#123; flag = data_res[&#x27;verify_result&#x27;]; console.log(&quot;flag: &quot; + flag); if (flag == true) &#123; localStorage.setItem(&#x27;ver&#x27;, true); window.location.href = &#x27;pages/resume1.html&#x27;; &#125; else &#123; localStorage.setItem(&#x27;ver&#x27;, false); alert(&#x27;密码错误&#x27;); &#125; &#125;) &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 代码中的下面这部分就是以post方式请求接口https://vercel-ver-api.vercel.app/api/ver_js，将用户输入的密码 pwd传过去，得到响应后就根据返回结果true/false执行不同的逻辑。 而且，如果密码正确的话，会往本地存储里写入一个键值对 &#123;'ver': true/false&#125; ，重复刷新简历页面时，先判断有无这个键值对，如果有则表明已经验证过密码了，可以直接访问，如果没有就要重定向到密码页面进行输入密码。 12345678910$.post(&#x27;https://vercel-ver-api.vercel.app/api/ver_js&#x27;, &#123;&#x27;pwd&#x27;: pwd&#125;, (data_res, textStatus, jqxhr)=&gt;&#123; flag = data_res[&#x27;verify_result&#x27;]; if (flag == true) &#123; localStorage.setItem(&#x27;ver&#x27;, true); window.location.href = &#x27;pages/resume1.html&#x27;; &#125; else &#123; localStorage.setItem(&#x27;ver&#x27;, false); alert(&#x27;密码错误&#x27;); &#125;&#125;) 简历页面 为了避免直接输入链接的方式访问页面，在简历的 head 标签里添加下面的代码逻辑 12345678910&lt;script src=&quot;https://upcdn.b0.upaiyun.com/libs/jquery/jquery-2.0.2.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; loginVerify(); function loginVerify() &#123; var ver = localStorage.getItem(&quot;ver&quot;); if (ver == null || ver == &#x27;false&#x27;) &#123; window.location.href = &#x27;../index.html&#x27;;// 这个即登录页面 &#125; &#125;&lt;/script&gt; body标签里添加下面的代码 123456&lt;script type=&quot;text/javascript&quot;&gt; $(&#x27;#exit-btn&#x27;).click(function()&#123; localStorage.clear(); window.location.href = &#x27;../index.html&#x27;; &#125;)&lt;/script&gt; vercel部署云函数api 前往Gitcode下载完整项目 新建一个项目(注意一定要有 /api 这个目录) 可以用python或者nodejs进行编程，下面以nodejs为例（也就是把下面的代码复制到 ver_js.js 文件里，其它不用管了） 12345678910111213export default function handler(req, res) &#123; var verify_result = false; if(req.method === &#x27;POST&#x27;)&#123; //使用post方式 const pwd_req = req.body[&#x27;pwd&#x27;]; // 接收前端发来的密码 if(pwd_req === &#x27;abc987zyx&#x27;) verify_result = true; // 判断密码是否正确 else verify_result = false; &#125; var res_data = &#123;&#x27;verify_result&#x27;: verify_result&#125;; res.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;); // 消除跨域访问报错 res.status(200).send(res_data); //返回数据到前端&#125; 然后把上面的代码push到github中，然后在vercel新建工程并导入这个仓库，部署成功后即可通过post方式请求该接口了。","categories":[{"name":"简历","slug":"简历","permalink":"https://blog.ajream.top/categories/%E7%AE%80%E5%8E%86/"}],"tags":[{"name":"简历","slug":"简历","permalink":"https://blog.ajream.top/tags/%E7%AE%80%E5%8E%86/"},{"name":"vercel","slug":"vercel","permalink":"https://blog.ajream.top/tags/vercel/"},{"name":"pages","slug":"pages","permalink":"https://blog.ajream.top/tags/pages/"}]},{"title":"网页版个人简历部署（上）","slug":"简历部署(上)","date":"2022-08-13T03:04:49.000Z","updated":"2022-08-13T03:35:27.000Z","comments":true,"path":"posts/4057c3f3/","link":"","permalink":"https://blog.ajream.top/posts/4057c3f3/","excerpt":"","text":"写在前面的话： 需要明白的两个核心问题： 简历制作： 想要做一个网页版的个人简历，要求不高的话，其实只需要一个静态的html文件即可（或者再加个css样式文件） 简历部署： 采用github或者gitee提供的pages服务，可以很快部署完成，并能够访问（本文讲解使用gitee pages） 本篇文章主要解决这两个问题。 另外，除了进行简历制作和部署外，我还添加了密码检验这个功能，即需要正确输入密码后才能查看简历。 这个放到下一篇文章讲。 简历制作 对于想要快速制作一份简历的同学来说，如果没有特殊或者很高的要求，可以去网上找一份模板，改改就成自己的了 可以参考这位博主的文章，可以前往下面的链接进行下载简历： 简历链接：http://labfile.oss.aliyuncs.com/courses/624/cv-template.zip 下载后进入文件夹内，用浏览器打开 index.html 文件，即可查看并编辑简历内容 说明： 点击图片可以更换图片（比如头像） 选中文字后使用快捷键 Ctrl+b 可以对文字进行加粗处理 微信二维码模块不想要可以删除掉（点击X号，其它模块也一样） 【下面是重点】 编辑完成后，需要保存，如何保存呢？ 首先 F12 打开浏览器（我这里用的是edge，Chrome、火狐均可以）开发者工具 右键 html 这一标签，选择“编辑为HTML”，然后就能ctrl+a全选和复制了 复制全部后，用记事本或其它文本编辑工具重新打开 index.html 文件，删除全部内容，然后粘贴刚复制的东西，再ctrl+s保存就行了 重新用浏览器打开 index.html 就能看到修改完成后的简历了 到达这里就算是制作好一份简历了，如果想导出pdf可以选择浏览器的“打印”，然后就能导出了 制作完成的简历如果想让它不再能够编辑的话，可以把 index.html 里引用的js文件都注释掉。 简历部署 接下来就可以将简历部署到gitee pages(或者gitee pages)了 首先你需要懂一些git相关的基本知识，另外本地安装了git工具，至少会使用如下几条命令： 12345678git init # 将一个普通文件夹初始化为一个git仓库git add . # 添加到本地暂存库git commit -m &quot;提交信息xxxxxx&quot; # 提交文件到仓库git push -u gitee master # 推送到远程仓库的master分支git remote add [远程仓库名，自定义，如origin] [仓库链接(SSH版)]git remote -v # 查看已经关联的远程仓库 接下来就可以进行部署了 首先登录gitee创建一个仓库 初始化本地仓库（使用 git init 命令），关联远程仓库 git remote add [仓库名] [仓库链接] 然后一顿操作 git add ., git commit -m &quot;xxx&quot;, git push -u xxx master 就可以提交到远程仓库了 然后开启gitee pages（第一次使用这个功能可能需要向客服申请，需要大概一天时间，GitHub的就不用） 配置如下即可 开启后上面会给出一个链接，点击即可访问自己的简历了。 到这里就完成一份简单的网页版个人简历部署了😀","categories":[{"name":"简历","slug":"简历","permalink":"https://blog.ajream.top/categories/%E7%AE%80%E5%8E%86/"}],"tags":[{"name":"简历","slug":"简历","permalink":"https://blog.ajream.top/tags/%E7%AE%80%E5%8E%86/"},{"name":"Gitee","slug":"Gitee","permalink":"https://blog.ajream.top/tags/Gitee/"}]},{"title":"GitCode+Picgo图床","slug":"GitCode图床","date":"2022-08-10T15:32:49.000Z","updated":"2022-08-11T05:20:23.000Z","comments":true,"path":"posts/1daa047d/","link":"","permalink":"https://blog.ajream.top/posts/1daa047d/","excerpt":"","text":"GitCode实际上是使用Gitlab服务搭建的一个代码托管平台，因此我们可以使用【Gitlab】图床插件来将图片上传到Gitcode。而从npm官网上正好可以找到这样的插件： 注意：推荐使用第一个插件 picgo-plugin-gitlab-files，这个插件上传的图片存放在自己的仓库里，另一个好像不是存放在自己的仓库。 另外，听说又拍云作为图床也很不错，不过由于又要注册又要实名认证的，以后再弄吧。（Gitcode与CSDN账号关联，不用重新注册） 插件下载 下载图床工具 切换到picgo安装目录，下载 picgo-plugin-gitlab-files 插件 1C:\\Users\\用户名\\AppData\\Roaming\\Typora\\picgo\\win64&gt;picgo install picgo install gitlab-files PicGo-Core官网 插件配置 输入下面的命令，然后根据提示选择上传插件，然后进行插件配置即可，插件配置参数可以看下面的表格，也可以去插件官方文档查看 1picgo set uploader # 选择上传插件 (&quot;可选&quot;参数一般不选，默认即可) 名称 介绍 配置示例 gitlab服务器地址 服务器地址,建议末尾不带/ https://gitcode.net 项目id 在项目设置页面查看,后文介绍 1254 默认分支 注意可能为main，也可以为其他分支 master gitlab的token 获取方式见后文(PicGo会明文保存) fw45d1z7sa6rz69KOsxq 自托管的Gitlab版本是否低于13.0 可选,对于Gitlab版本低于13.0的情况,使用 raw ,否则使用 -/raw Gitcode的版本大于13，所以选择false 文件名及其路径 可选,文件名和路径,占位符见后文,是否以/开头均可 /pictures/&#123;year&#125;/&#123;month&#125;/&#123;day&#125;_&#123;hour&#125;_&#123;minute&#125;_&#123;second&#125;_&#123;fileName&#125; 上传文件的Message 可选 Upload &#123;fileName&#125; By PicGo gitlab files uploader at &#123;year&#125;-&#123;month&#125;-&#123;day&#125; 是否同步删除远程对象 可选,本地删除文件后是否在Gitlab删除 false 删除文件的Message 可选 Delete &#123;fileName&#125; By PicGo gitlab files uploader at &#123;year&#125;-&#123;month&#125;-&#123;day&#125; 删除远程图片后是否通知 可选,如果开启会有两个通知 false 上传者的邮箱 可选,建议不填写,可以不存在,可以不属于自己 test@example.com 上传者的用户名 可选,建议不填写,可以不存在,可以不属于自己 example 配置完成后可以在 C:\\Users\\用户名\\.picgo\\config.json 查看刚才的配置（方便以后随时修改），如下： 注意看 uploader和current 参数是否是 gitlab-files-uploader 1234567891011121314151617181920212223242526&#123; &quot;picBed&quot;: &#123; &quot;uploader&quot;: &quot;gitlab-files-uploader&quot;, &quot;current&quot;: &quot;gitlab-files-uploader&quot;, // 与uploader一致 &quot;transformer&quot;: &quot;path&quot;, &quot;gitlab-files-uploader&quot;: &#123; &quot;gitUrl&quot;: &quot;https://gitcode.net&quot;, // 服务器地址 &quot;projectId&quot;: &quot;自己项目的ID&quot;, &quot;branch&quot;: &quot;master&quot;, &quot;gitToken&quot;: &quot;自己的token&quot;, &quot;gitVersionUnderThirteen&quot;: false, &quot;fileName&quot;: &quot;/pictures/&#123;year&#125;/&#123;month&#125;/&#123;day&#125;_&#123;hour&#125;_&#123;minute&#125;_&#123;second&#125;_&#123;fileName&#125;&quot;, // 保存路径 &quot;commitMessage&quot;: &quot;Upload &#123;fileName&#125; By PicGo gitlab files uploader at &#123;year&#125;-&#123;month&#125;-&#123;day&#125;&quot;, &quot;deleteRemote&quot;: false, &quot;deleteMessage&quot;: &quot;Delete &#123;fileName&#125; By PicGo gitlab files uploader at &#123;year&#125;-&#123;month&#125;-&#123;day&#125;&quot;, &quot;deleteInform&quot;: false, &quot;authorMail&quot;: &quot;&quot;, &quot;authorName&quot;: &quot;&quot; &#125; &#125;, &quot;picgoPlugins&quot;: &#123; &quot;picgo-plugin-gitlab-files&quot;: true &#125;,&#125; 项目ID获取： Token获取，前往页面 （注意退出页面后token不可再查看，如果忘记了只能新建一个）token到期时间设置久一点就行了。 上传测试 打开typora，拖入一张图片，上传成功即可，如果失败，请检查【项目id】、【token】是否有错","categories":[{"name":"瞎折腾","slug":"瞎折腾","permalink":"https://blog.ajream.top/categories/%E7%9E%8E%E6%8A%98%E8%85%BE/"}],"tags":[{"name":"图床","slug":"图床","permalink":"https://blog.ajream.top/tags/%E5%9B%BE%E5%BA%8A/"}]},{"title":"通信原理期末复习","slug":"通信原理","date":"2022-06-23T14:00:00.000Z","updated":"2022-06-25T12:15:34.000Z","comments":true,"path":"posts/6b3e2032/","link":"","permalink":"https://blog.ajream.top/posts/6b3e2032/","excerpt":"","text":"checked:true color:green 第一章 checked:true color:green 第二章 checked:true color:green 第三章 checked:true color:green 第四章 checked:true color:green 第五章 checked:true color:green 第六章 checked:false color:red symbol:times 第七章 checked:true color:green 第八章 checked:true color:green 第九章 checked:true color:green 第十章 checked:false color:red symbol:times 第十一章 【注：公式显示错误可前往我的博客园查看】 第一章 绪论 通信性能指标： 信息量：消息x所含的信息量I是x发生的概率的函数 I(x)=−log⁡2(P(x))I(x)=-\\log_2(P(x))I(x)=−log2​(P(x)) 单位 bit 信息传输速率： 传码率RBR_BRB​：单位时间内传输码元（可以是二进制、多进制）的个数，单位 Baud/s 传信率RbR_bRb​：单位时间内传输的比特总数，单位 bit/s或bps 关系：Rb=RBlog⁡2MR_b =R_B \\log_2MRb​=RB​log2​M 其中 M 为进制数 频带利用率（2种表示方式，B为信号传输占用的带宽）： η=RBB (Baud/Hz)\\eta=\\frac{R_B}{B} ~~(Baud/Hz)η=BRB​​ (Baud/Hz) ηb=RbB (bit/s/Hz)\\eta_b=\\frac{R_b}{B} ~~(bit/s/Hz)ηb​=BRb​​ (bit/s/Hz) 误码率： 码元差错率：Pe=错误码元数传输的总码元数P_e=\\frac{错误码元数}{传输的总码元数}Pe​=传输的总码元数错误码元数​ 信息差错率：Pe=错误比特数传输的总比特数P_e=\\frac{错误比特数}{传输的总比特数}Pe​=传输的总比特数错误比特数​ 第二章 随机信号与噪声分析 随机过程X(t)的数字特征 数学期望：E[X(t)]=∫−∞+∞xf(x,t)dxE[X(t)]=\\int_{-\\infty}^{+\\infty}x f(x, t)dxE[X(t)]=∫−∞+∞​xf(x,t)dx 方差：D[X(t)]=E{[X(t)−a(t)]2}D[X(t)] = E\\{[X(t)-a(t)]^2\\}D[X(t)]=E{[X(t)−a(t)]2} 其中a(t)为数学期望 自相关函数（重要）：R(t1,t2)=E[X(t1)X(t2)]R(t_1, t_2)=E[X(t_1)X(t_2)]R(t1​,t2​)=E[X(t1​)X(t2​)] 协方差函数：B(t1,t2)=E{[X(t1)−a(t1)][X(t2)−a(t2)]}B(t_1, t_2)=E\\{[X(t_1)-a(t_1)][X(t_2)-a(t_2)]\\}B(t1​,t2​)=E{[X(t1​)−a(t1​)][X(t2​)−a(t2​)]}， 且 B(t1,t2)=R(t1,t2)−a(t1)a(t2)B(t_1, t_2)=R(t_1, t_2)-a(t_1)a(t_2)B(t1​,t2​)=R(t1​,t2​)−a(t1​)a(t2​) (重要) 平稳随机过程 广义平稳： 均值与时间t无关，为常数aaa 自相关函数只与时间间隔有关，为R(τ)R(\\tau)R(τ) 狭义平稳： 一维情况：的概率密度函数与时间t无关 判断 X(t)=Acos⁡(ωt+φ)X(t)=A\\cos(\\omega t+φ)X(t)=Acos(ωt+φ) 的平稳性，其中A和ω为常数，φ服从【均匀分布】，则 E[X(t)]=0E[X(t)]=0E[X(t)]=0 RX(t1,t2)=A22cos⁡ωτR_X(t_1,t_2)=\\frac{A^2}{2}\\cos\\omega \\tauRX​(t1​,t2​)=2A2​cosωτ，其中 τ=t2−t1\\tau=t_2-t_1τ=t2​−t1​ 综上：X(t)是广义平稳的 【平稳随机过程的各态历经性】： 假设 x(t) 是平稳随机过程 X(t)X(t)X(t) 的任意一次实现，则其时间均值、时间相关函数分别为： 时间均值：a‾=lim⁡T→∞1T∫−T/2T/2x(t)dt\\overline{a}=\\lim_{T\\to\\infty}\\frac{1}{T}\\int_{-T/2}^{T/2} x(t)dta=limT→∞​T1​∫−T/2T/2​x(t)dt 时间相关函数：R(τ)‾=lim⁡T→∞1T∫−T/2T/2x(t)x(t+τ)dt\\overline{R(\\tau)}= \\lim_{T \\to \\infty} \\frac{1}{T} \\int_{-T/2}^{T/2} x(t)x(t+\\tau)dtR(τ)​=limT→∞​T1​∫−T/2T/2​x(t)x(t+τ)dt 如果平稳过程使得下式成立： a=E[X(t)]=a‾a=E[X(t)]=\\overline{a}a=E[X(t)]=a R(τ)=R(τ)‾R(\\tau)=\\overline{R(\\tau)}R(τ)=R(τ)​ 则该平稳随机过程具有各态历经性 【自相关函数的性质】： 记住这幅图就可以记住 R(τ)R(\\tau)R(τ) 的性质(拿随机信号处理的PPT的图来顶一下😅) R(τ)R(\\tau)R(τ) 为偶函数 R(0)=E[X2(t)]=σ2+E2(∞)R(0)=E[X^2(t)]=\\sigma^2 + E^2(\\infty)R(0)=E[X2(t)]=σ2+E2(∞) 图中的 σX2\\sigma_X^2σX2​ 即方差， mX2m_X^2mX2​ 即 E2(∞)E^2(\\infty)E2(∞) R(0)R(0)R(0)为平均功率， σ2\\sigma^2σ2为交流功率， E2(∞)E^2(\\infty)E2(∞) 为直流功率 【功率谱密度函数PX(ω)P_X(\\omega)PX​(ω)】 确定信号：Px(ω)=lim⁡T→∞∣XT(ω)∣2TP_x(\\omega)=\\lim_{T\\to \\infty} \\frac{|X_T(\\omega)|^2}{T}Px​(ω)=limT→∞​T∣XT​(ω)∣2​ 随机信号：PX(ω)=E[Px(ω)]=lim⁡T→∞E[∣XT(ω)∣2]TP_X(\\omega)= E[P_x(\\omega)] = \\lim_{T\\to \\infty} \\frac{E[|X_T(\\omega)|^2]}{T}PX​(ω)=E[Px​(ω)]=limT→∞​TE[∣XT​(ω)∣2]​ 性质：自相关函数的傅里叶变换等于 PX(ω)P_X(\\omega)PX​(ω)，即 R(τ)⇔PX(ω)R(\\tau)\\Leftrightarrow P_X(\\omega)R(τ)⇔PX​(ω) PX(ω)P_X(\\omega)PX​(ω) 是确定函数，偶函数，非负函数 随机过程的平均功率=R(0)=12π∫−∞+∞PX(ω)dωR(0)=\\frac{1}{2\\pi}\\int_{-\\infty}^{+\\infty} P_X(\\omega) d\\omegaR(0)=2π1​∫−∞+∞​PX​(ω)dω 第三章 信道与噪声 香农公式： 信道容量：C=Blog⁡2(1+S/N)C=B\\log_2(1+S/N)C=Blog2​(1+S/N) (bit/s) 第四章 模拟调制系统 幅度调制 普通调幅AM sAM(t)=[A0+m(t)]cos⁡ωcts_{AM}(t)=[A_0+m(t)]\\cos \\omega_ctsAM​(t)=[A0​+m(t)]cosωc​t 其中m(t)为输入的调制信号，输出sAM(t)s_{AM}(t)sAM​(t) 为【调幅信号】，所以经过调制的信号都可称为 【已调信号】 调幅度：max⁡(m(t))A0\\frac{\\max(m(t))}{A_0}A0​max(m(t))​ 调幅度小于等于 1 时可以采用包络检波 双边带调幅DSB sDSB=m(t)⋅cos⁡(ωct)s_{DSB}=m(t)\\cdot \\cos(\\omega_ct)sDSB​=m(t)⋅cos(ωc​t) 单边带调制（调制结果分为上边带、下边带两种） 上边带：sUSB=12m(t)cos⁡(ωct)−12m^(t)sin⁡(ωct)s_{USB}=\\frac{1}{2}m(t)\\cos(\\omega_ct)-\\frac{1}{2}\\hat{m}(t)\\sin(\\omega_ct)sUSB​=21​m(t)cos(ωc​t)−21​m^(t)sin(ωc​t) 下边带：sLSB=12m(t)cos⁡(ωct)+12m^(t)sin⁡(ωct)s_{LSB}=\\frac{1}{2}m(t)\\cos(\\omega_ct)+\\frac{1}{2}\\hat{m}(t)\\sin(\\omega_ct)sLSB​=21​m(t)cos(ωc​t)+21​m^(t)sin(ωc​t) 注：m^(t)\\hat{m}(t)m^(t) 是 m(t)m(t)m(t) 的希尔伯特变换，即 m(t) 的正频率部分相位减去 π2\\frac{\\pi}{2}2π​ 带宽：BAM=BDSB=2BSSB=2BVSBB_{AM}=B_{DSB}=2B_{SSB}=2B_{VSB}BAM​=BDSB​=2BSSB​=2BVSB​ 功率：设 PmP_mPm​为调制信号 m(t)m(t)m(t) 的平均功率E(m2(t))E(m^2(t))E(m2(t))，则 PAM=载波功率+边带功率=Pc+Ps=A022+Pm2P_{AM}=载波功率+边带功率=P_c+P_s=\\frac{A_0^2}{2}+\\frac{P_m}{2}PAM​=载波功率+边带功率=Pc​+Ps​=2A02​​+2Pm​​ PDSB=Ps=Pm2P_{DSB}=P_s=\\frac{P_m}{2}PDSB​=Ps​=2Pm​​ PSSB=12Ps=14PmP_{SSB}=\\frac{1}{2}P_s=\\frac{1}{4}P_mPSSB​=21​Ps​=41​Pm​ 调制效率：ηAM=PsPAM{\\Large \\eta_{AM}=\\frac{P_s}{P_{AM}}}ηAM​=PAM​Ps​​ 解调： AM解调： 相干解调：mo(t)≈12[m(t)+A0]→隔直12m(t)m_o(t)\\approx \\frac{1}{2}[m(t)+A_0]\\overset{隔直}{\\rightarrow} \\frac{1}{2}m(t)mo​(t)≈21​[m(t)+A0​]→隔直21​m(t) 包络检波：mo(t)≈m(t)+A0→隔直m(t)m_o(t)\\approx m(t)+A_0\\overset{隔直}{\\rightarrow} m(t)mo​(t)≈m(t)+A0​→隔直m(t) DSB解调： 相干：mo(t)=12m(t)m_o(t)=\\frac{1}{2}m(t)mo​(t)=21​m(t) 输出功率：Po=14m2(t)‾=14PmP_o=\\frac{1}{4}\\overline{m^2(t)}=\\frac{1}{4}P_mPo​=41​m2(t)​=41​Pm​ SSB解调： 相干：mo(t)=14m(t)m_o(t)=\\frac{1}{4}m(t)mo​(t)=41​m(t)， Po=116m2(t)‾=116PmP_o=\\frac{1}{16}\\overline{m^2(t)}=\\frac{1}{16}P_mPo​=161​m2(t)​=161​Pm​ 解调器的信噪比增益： GAM≤1G_{AM}\\le 1GAM​≤1 (包络检波、且为大信噪比时)，单音调制，且调制度=100%时，GAM=2/3G_{AM}=2/3GAM​=2/3 GDSB=2G_{DSB}=2GDSB​=2 GSSB=1G_{SSB}=1GSSB​=1 平稳高斯白噪声 ni(t)n_i(t)ni​(t) 通过解调器后，输出 no(t)=ni(t)/2n_o(t)=n_i(t)/2no​(t)=ni​(t)/2，因此输出噪声功率 No=Ni/4N_o=N_i/4No​=Ni​/4 通常高斯白噪声的[双边]功率谱 n02\\frac{n_0}{2}2n0​​ W/Hz，[单边]功率谱为 n0n_0n0​ W/Hz 角度调制 调角信号：sm(t)=A0cos⁡(ωct+φ(t))s_{m}(t)=A_0\\cos(\\omega_ct+\\varphi(t))sm​(t)=A0​cos(ωc​t+φ(t)) 调相：φ(t)=KPm(t)\\varphi(t)=K_P m(t)φ(t)=KP​m(t) 调频：dφ(t)dt=KFm(t)\\frac{d\\varphi(t)}{dt}=K_F m(t)dtdφ(t)​=KF​m(t) 调频带宽：BFM=2(D+1)fmB_{FM}=2(D+1)f_mBFM​=2(D+1)fm​ ，其中 fmf_mfm​ 为调制信号m(t)的最高频率 窄带调频时，D&lt;&lt;1,BNBFM=2fmD&lt;&lt;1, B_{NBFM}=2f_mD&lt;&lt;1,BNBFM​=2fm​ 宽带调频时，BFM=2(D+1)fmB_{FM}=2(D+1)f_mBFM​=2(D+1)fm​ D为调频指数，D=Δfm/fmD=\\Delta f_m/f_mD=Δfm​/fm​， Δfm=KF∣m(t)∣max⁡\\Delta f_m=K_F|m(t)|_{\\max}Δfm​=KF​∣m(t)∣max​ 为最大频偏，单音调制时用 mfm_fmf​代替 D 功率：窄带、宽带均为 PFM=载波功率=A02/2P_{FM}=载波功率=A_0^2/2PFM​=载波功率=A02​/2 调频信号的解调： 非相干解调 mo(t)=KdKFm(t)m_o(t)=K_dK_Fm(t)mo​(t)=Kd​KF​m(t) 相干解调：mo(t)=12A0KFm(t)m_o(t)=\\frac{1}{2}A_0K_Fm(t)mo​(t)=21​A0​KF​m(t) 信噪比增益：GFM=3mf2(mf+1)≈3mf3G_{FM}=3m_f^2(m_f+1)\\approx 3m_f^3GFM​=3mf2​(mf​+1)≈3mf3​ 第五章 数字基带传输系统 各种编码 单极性不归零码 双极性不归零码 单极性归零码 双极性归零码 AMI码（传号反转码，1码交替用正、负电平表示，0码用低电平表示） HDB3码（解决AMI码中连0长串问题） 1原码-&gt;AMI码-&gt;加V（交替正负）-&gt;加B（与后一个V正负相同）-&gt;±V、±B改为±1 数字基带传输 数字基带信号功率谱： \\begin{align} &amp;P_s(f)\\\\ &amp;=P_u(f)+P_v(f)\\\\ &amp;=f_bP(1-P)|G_1(f)-G_2(f)|^2+\\\\&amp;\\sum_{m=-\\infty}^{+\\infty}[ f_b^2|PG_1(mf_b)+(1-P)G_2(mf_b)|^2\\delta(f-mf_b)] \\end{align} 单极性NRZ(含直流分量) 双极性NRZ(0,1等概发送) 单极性RZ(含离散分量) 双极性RZ(0,1等概发送) 无码间干扰 无码间干扰最大速率：RB=21+αfchR_B=\\frac{2}{1+\\alpha}f_{ch}RB​=1+α2​fch​ ，fchf_{ch}fch​为系统最高截止频率 最大码速时的频带利用率：η=21+α\\eta=\\frac{2}{1+\\alpha}η=1+α2​ (Baud/Hz) 无码间干扰的误码率： 双极性、等概率发送0，1：Pe=12erfc(A2σn)P_e=\\frac{1}{2}erfc(\\frac{A}{\\sqrt{2}\\sigma_n})Pe​=21​erfc(2​σn​A​) 单极性、等概率发送0，1：Pe=12erfc(A22σn)P_e=\\frac{1}{2}erfc(\\frac{A}{2\\sqrt{2}\\sigma_n})Pe​=21​erfc(22​σn​A​) 部分响应系统 特点：频带利用率可以达到 2 Baud/Hz 实现方式： 预编码：bk=ak⊕bk−1b_k=a_k\\oplus b_{k-1}bk​=ak​⊕bk−1​ 相关编码（消除误码传播）：ck=bk+bk−1c_k=b_k+b_{k-1}ck​=bk​+bk−1​ 译码：ak=bk⊕bk−1=[ck]mod 2a_k=b_k\\oplus b_{k-1}=[c_k]_{\\mod{2}}ak​=bk​⊕bk−1​=[ck​]mod2​ 均衡器 输出： yk=∑i=−NNCixk−iy_k=\\sum_{i=-N}^N C_ix_{k-i} yk​=i=−N∑N​Ci​xk−i​ 第六章 数字信号频带传输 主要介绍如何将数字信号调制到高频范围进行传输 带宽 B2ASK=2RBB_{2ASK}=2R_BB2ASK​=2RB​ B2FSK=∣f1−f2∣+2RBB_{2FSK}=|f_1-f_2|+2R_BB2FSK​=∣f1​−f2​∣+2RB​ B2DPSK=B2PSK=2RBB_{2DPSK}=B_{2PSK}=2R_BB2DPSK​=B2PSK​=2RB​ 误码率 相干解调 2ASK: 12erfc(r4)\\frac{1}{2}erfc(\\sqrt{\\frac{r}{4}})21​erfc(4r​​), r&gt;&gt;1时，1πre−r/4\\frac{1}{\\sqrt{\\pi r}} e^{-r/4}πr​1​e−r/4 2FSK: 12erfc(r2)\\frac{1}{2} erfc(\\sqrt{\\frac{r}{2}})21​erfc(2r​​), r&gt;&gt;1时，12πre−r/2\\frac{1}{\\sqrt{2\\pi r}} e^{-r/2}2πr​1​e−r/2 2PSK: 12erfc(r)\\frac{1}{2}erfc(\\sqrt{r})21​erfc(r​), r&gt;&gt;1时，12πre−r\\frac{1}{2\\sqrt{\\pi r}} e^{-r}2πr​1​e−r 2DPSK: erfc(r)erfc(\\sqrt{r})erfc(r​), r&gt;&gt;1时，1πre−r\\frac{1}{\\sqrt{\\pi r}} e^{-r}πr​1​e−r 4PSK: erfc(rsin⁡π4)erfc(\\sqrt{r}\\sin\\frac{\\pi}{4})erfc(r​sin4π​) 4DPSK: erfc(2rsin⁡π8)erfc(\\sqrt{2r}\\sin\\frac{\\pi}{8})erfc(2r​sin8π​) 非相干解调 2DPSK（差分相干解调）: 12e−r\\frac{1}{2}e^{-r}21​e−r 2FSK（包络检波）: 12e−r/2\\frac{1}{2}e^{-r/2}21​e−r/2 2ASK（包络检波）: 12e−r/4\\frac{1}{2}e^{-r/4}21​e−r/4 解调框图 … 第七章 现代数字调制技术 主要看书，了解基本目的和原理 QAM：带宽、频率利用率记一下即可 第八章 模拟信号的数字传输 主要介绍模拟信号如何转换为数字信号：采样、量化、编码 采样定理 fs=2fmf_s=2f_mfs​=2fm​ 了解一下理想采样、自然采样、平顶采样 带通抽样定理 采样角频率： ωs=2W(1+MN)\\omega_s=2W(1+\\frac{M}{N}) ωs​=2W(1+NM​) 其中 N=floor(ωH/W)N= floor(\\omega_H/W)N=floor(ωH​/W)，也就是 ωH/W\\omega_H/WωH​/W的整数部分 M=ωHW−NM=\\frac{\\omega_H}{W}-NM=WωH​​−N, 且 0≤M&lt;10\\le M &lt; 10≤M&lt;1 最终 2W&lt;ωs&lt;4W2W&lt;\\omega_s&lt;4W2W&lt;ωs​&lt;4W 量化 均匀量化： 最小量化间隔：ΔA=b−aM\\Delta A=\\frac{b-a}{M}ΔA=Mb−a​，最大值b，最小值a，M个量化区间 最大量化误差：(Δq)max⁡=ΔA/2(\\Delta q)_{\\max}=\\Delta A/2(Δq)max​=ΔA/2 量化信噪比：SoNo=M2\\frac{S_o}{N_o}=M^2No​So​​=M2 非均匀量化： A律压缩曲线： y={Ax1+ln⁡A0&lt;x≤1A1+Ax1+ln⁡A1A&lt;x≤1y=\\begin{cases} \\frac{Ax}{1+\\ln A} &amp; 0&lt;x\\le \\frac{1}{A} \\\\ \\frac{1+Ax}{1+\\ln A} &amp; \\frac{1}{A} &lt; x\\le 1 \\end{cases} y={1+lnAAx​1+lnA1+Ax​​0&lt;x≤A1​A1​&lt;x≤1​ 采用13折线编码：A=87.6 量化信噪比： 大信噪比时：SoNo=22Nb,Nb≥log⁡2M\\frac{S_o}{N_o}=2^{2N_b},N_b\\ge \\log_2MNo​So​​=22Nb​,Nb​≥log2​M 小信噪比时：SoNo=14Pe\\frac{S_o}{N_o}=\\frac{1}{4P_e}No​So​​=4Pe​1​, Pe为误码率 PCM编码 十三折线编码基本步骤 例题：对抽样值1268进行量化编码 编码结果是一个8位码 b7b6b5b4b3b2b1b0b_7b_6b_5b_4b_3b_2b_1b_0b7​b6​b5​b4​b3​b2​b1​b0​ 符号位 b7b_7b7​：1-正，0-负；1268为正数，则b7=1b_7=1b7​=1 段落码 b6b5b4b_6b_5b_4b6​b5​b4​：根据下表判断该取哪个值，比如，抽样值为567，则512≤567&lt;1024512\\le567&lt;1024512≤567&lt;1024，则b6b5b4=110b_6b_5b_4=110b6​b5​b4​=110。抽样值为1268&gt;1024，则b6b5b4=111b_6b_5b_4=111b6​b5​b4​=111 抽样值 b6b5b4b_6b_5b_4b6​b5​b4​ 1024 111 512 110 256 101 128 100 64 011 32 010 16 001 0 000 段内码 b3b2b1b0b_3b_2b_1b_0b3​b2​b1​b0​：将对应区间分成均匀分为16份，比如抽样值为567，所在区间为[512, 1024)，分成16份，每份大小为(1024-512)/16=32；题中给的抽样值 1268&gt;1024，因此1268所在的区间为[1024, 2048)，每份大小ΔA=(2048-1024)/16=64，则 0000对应1024 0001对应1024+64*1 0010对应1024+64*2， … 1111对应1024+64*15 因为 1024+64*3=1216 &lt; 1268 &lt; 1024+64*4=1280，因此1268对应的 b3b2b1b0=0011b_3b_2b_1b_0=0011b3​b2​b1​b0​=0011 综上，得到最终编码为 11110011 误差计算 采用起始电平为译码电平时，则实际上11110011对应1216，因此 误差=1268-1216=52 通常采用中间电平为译码电平，即在原来的基础上加 ΔA/2，则1110011对应译码后应该为 1216+64/2=1248，因此最终【误差】=1268-1248=20 时分复用TDM fs=2fmf_s=2f_mfs​=2fm​, Ts=12fmT_s=\\frac{1}{2f_m}Ts​=2fm​1​ 每个0、1信号占用时间：Tb=TsNbnT_b=\\frac{T_s}{N_b n}Tb​=Nb​nTs​​, n代表几路信号进行复用 RB=1/TbR_B=1/T_bRB​=1/Tb​ 无码间干扰带宽：B=RB/2B=R_B/2B=RB​/2 主瓣带宽：B=1/τB=1/\\tauB=1/τ，τ表示码元宽度 不采用时分复用时：RB=NbfsR_B=N_bf_sRB​=Nb​fs​ 第九章 差错控制编码 基本概念 码重：一个码中1的个数，如0011码重为2 对2个码求异或的结果中1的个数，即码距d0d_0d0​，如 0011+1000=1011，码距为3 检错与纠错的条件 d0≥e+1d_0\\ge e+1d0​≥e+1，可以检错e个码 d0≥2t+1d_0\\ge 2t+1d0​≥2t+1，可以纠错t个码 d0≥t+e+1且e≥td_0\\ge t+e+1且e\\ge td0​≥t+e+1且e≥t，可以检查出e个错，同时纠正其中t个错 线性分组码 对于一个(n, k)码，即n个码中有k个是信息码，r=n-k个监督码 其编码效率为 k/nk/nk/n 监督矩阵 H0=[P Ir]H_0=[P~~~I_r]H0​=[P Ir​]，其中 IrI_rIr​代表单位矩阵，阶数为r，H0共n列，r行。（注：H0是典型化的矩阵，不是典型化需要进行【矩阵初等变化】，才能得到典型化的矩阵） 生成矩阵 G0=[Ik PT]G_0=[I_k~~~P^T]G0​=[Ik​ PT]，其中 IkI_kIk​代表单位矩阵，阶数为k，G0共n列，k行。（注：G0是典型化的矩阵，不是典型化需要进行【矩阵初等变化】，才能得到典型化的矩阵） 发送时使用的码组（系统码）：A=[an−1an−2⋯an−k]×G0A=[a_{n-1}a_{n-2}\\cdots a_{n-k}]\\times G_0A=[an−1​an−2​⋯an−k​]×G0​ 【译码方式】 计算校正子 ST=HRTS^T=HR^TST=HRT，RTR^TRT为接收码组的列向量 ∣ST∣−1=j|S^T|-1=j∣ST∣−1=j，则 R 中从又往左数（0开始）第j个码发生错误，记得在回答时纠正过来 循环码 生成多项式 g(x) 的确定 g(x)最高次项为 xn−kx^{n-k}xn−k，常数项为1 一般题目会给出许用码组，在许用的码组中找出一个码字，其中 an−ka_{n-k}an−k​左边的码均为0，第n-k个码an−ka_{n-k}an−k​为1，最右边的码a0a_0a0​为1，然后根据这个码的a1,a2,⋯ ,an−k−1a_1,a_2,\\cdots,a_{n-k-1}a1​,a2​,⋯,an−k−1​来判断g1,g2,⋯ ,gn−k−1g_1,g_2,\\cdots,g_{n-k-1}g1​,g2​,⋯,gn−k−1​是多少。 证明g(x)是循环码(n,k)的生成多项式 即证 xn−1x^n-1xn−1 能被 g(x)g(x)g(x) 整除 求码多项式A(x) 先求监督多项式 r(x)≡xn−km(x)，模g(x)r(x)\\equiv x^{n-k}m(x)，模g(x)r(x)≡xn−km(x)，模g(x) 则 A(x)=m(x)xn−k+r(x)A(x)=m(x)x^{n-k} + r(x)A(x)=m(x)xn−k+r(x) m(x)为信息码多项式 判断接收到的码多项式 R(x)R(x)R(x) 是不是码多项式 利用所有码多项式均能被 g(x) 整除的性质 译码：ST=HRTS^T=HR^TST=HRT 或 S=RHTS=RH^TS=RHT 第十章 数字信号的最佳接收 最大信噪比准则与匹配滤波器 输出噪声功率谱 Pno(ω)=no2∣H(ω)∣2P_{no}(\\omega)=\\frac{n_o}{2}|H(\\omega)|^2Pno​(ω)=2no​​∣H(ω)∣2, n0/2n_0/2n0​/2是输入高斯白噪声的功率谱密度函数PniP_{ni}Pni​ 输出噪声总功率 No=12π∫−∞+∞Pno(ω)dωN_o=\\frac{1}{2\\pi}\\int_{-\\infty}^{+\\infty}P_{no}(\\omega)d\\omegaNo​=2π1​∫−∞+∞​Pno​(ω)dω 输入信号功率 Ei=12π∫−∞+∞∣Si(ω)∣2dωE_i=\\frac{1}{2\\pi}\\int_{-\\infty}^{+\\infty}|S_i(\\omega)|^2d\\omegaEi​=2π1​∫−∞+∞​∣Si​(ω)∣2dω 最大输出信噪比 romax=Ein0/2r_{omax}=\\frac{E_i}{n_0/2}romax​=n0​/2Ei​​ 根据 si(t)s_i(t)si​(t) 计算匹配滤波器系统函数和冲击响应函数 h(t)=Ksi(t0−t)h(t)=Ks_i(t_0-t)h(t)=Ksi​(t0​−t)，通常取 K=1,t0=TbK=1, t_0=T_bK=1,t0​=Tb​ H(ω)=KSi∗(ω)e−jωt0H(\\omega)=KS_i^*(\\omega)e^{-j\\omega t_0}H(ω)=KSi∗​(ω)e−jωt0​ 输出信号计算： so(t)=KRsi(t0−t)s_o(t)=KR_{s_i}(t_0-t)so​(t)=KRsi​​(t0​−t) 匹配滤波器结构 最小误码率准则与相关接收机 判决准则 P(s1)P(x∣s1)&gt;P(s2)P(x∣s2)P(s_1)P(x|s_1)&gt;P(s_2)P(x|s_2)P(s1​)P(x∣s1​)&gt;P(s2​)P(x∣s2​) 则判断为s1, 否则为s2，相等时无法判断，误码率最大 相关接收机结构 最佳接收机误码率 Pe=12erfc(Eb(1−ρ)2n0)P_e=\\frac{1}{2}erfc(\\sqrt{\\frac{E_b(1-\\rho)}{2n_0}})Pe​=21​erfc(2n0​Eb​(1−ρ)​​) 其中，两个信号平均能量Eb=12∫0T(s12(t)+s22(t))dtE_b=\\frac{1}{2}\\int_{0}^{T}(s_1^2(t)+s_2^2(t))dtEb​=21​∫0T​(s12​(t)+s22​(t))dt 相关系数 ρ=∫0Ts1(t)s2(t)dtEb\\rho=\\frac{\\int_0^Ts_1(t)s_2(t)dt}{E_b}ρ=Eb​∫0T​s1​(t)s2​(t)dt​ 当使用 双极性码，PSK发送时，ρ=-1 当使用 单极性码，ASK或FSK发送时，ρ=0 ρ=1时，Pe=0.5，误码率最大 第十一章 同步原理 载波同步 插入导频法 直接提取法 平方变换法（平方环法） 同相正交环法 位同步 外同步法 NRZ码：在ωb\\omega_bωb​处插入导频 RZ码，在 ωb/2\\omega_b/2ωb​/2 处插入导频，然后2倍频即可得到 ωb\\omega_bωb​ 自同步法 模拟锁相环法 带限整流法 数字锁相环 帧同步 巴克码作帧同步码","categories":[{"name":"课程考试","slug":"课程考试","permalink":"https://blog.ajream.top/categories/%E8%AF%BE%E7%A8%8B%E8%80%83%E8%AF%95/"}],"tags":[{"name":"通信原理","slug":"通信原理","permalink":"https://blog.ajream.top/tags/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/"}]},{"title":"补码 and [127+1]","slug":"127+1问题","date":"2022-06-14T14:15:15.000Z","updated":"2024-03-31T14:49:40.667Z","comments":true,"path":"posts/2bf21981/","link":"","permalink":"https://blog.ajream.top/posts/2bf21981/","excerpt":"","text":"一个字节能存下多大的整数 【无符号数】 一个字节有8位，如果全部用来表示数值，一共可以表示 2^8=256 个数 0,1,2,3,...,255 【有符号数】 如果用最高位表示符号(0表示正，1表示负)，那么只剩下7位表示数值: 用 &quot;0000 0001&quot; ~ &quot;0111 1111&quot; 表示127个正数 用 &quot;1000 0001&quot; ~ &quot;1111 1111&quot; 表示127个负数 但是，现在还剩下 &quot;0000 0000&quot; 和 &quot;1000 0000&quot;未表示任何数，由于平时+0等于0，于是规定 用&quot;0000 0000&quot; 表示 0 还剩下 &quot;1000 0000&quot; 可以表示一个数（肯定不能是-0吧），显然应该是一个负数，而 -1 ~ -127 都已经表示了，所以用&quot;1000 0000&quot; 表示 -128 因此，有符号数的表示范围是：-128~127 共256个数 注：以上二进制不是反码也不是补码，均为原码 原码、反码、补码互相转换 首先注意几点： 在计算机中，数字的存储、运算都用补码进行。 并且在运算时，补码的符号位也参与运算，因为在计算机看来，这些都是数字&quot;0&quot;或&quot;1&quot;, 都能参与运算。 而人要想认出这个计算结果到底是多少，就需要转化为原码才可以。 正数以及0的原码、反码、补码相同，就不多说了 负数补码与原码相互转换 将负数的【原码转为补码】，需要经历几个步骤： 假设一个8位类型的数字 -1： 写出原码：符号位用1表示，如-1的原码：1000 0001 写出反码：【符号位不变】，其余各位取反，如-1的反码：1111 1110 计算补码：在反码的基础上 +1 ，如-1的补码：1111 1111 将负数的【补码转为原码】，只需要记住：“补码的补码==&gt;原码”，也就是通过计算补码的补码即可还原出原码。 如：-1的补码 1111 1111 —[符号位不变，其余取反]—&gt; 1000 0000 —[+1]—&gt; 1000 0001 下图来源于维基百科，是几个特殊的数字的补码 运算步骤 前面说过，在计算机内部，数字的存储、运算都是以补码形式进行 那么 &quot;127+1&quot;的运算过程如下 127 的补码是： 0111 1111 1的补码是： 0000 0001 相加后的补码： 1000 0000 （补码运算时，符号位也参与运算） 然后，要把补码转换为人方便阅读的原码： 根据最前面说到的结论可知，1000 0000(原码) 不表示 -0 而表示 -128 同理，&quot;127+2&quot;的运算步骤： 127 的补码是： 0111 1111 2的补码是： 0000 0010 相加后的补码： 1000 0001 （补码运算时，符号位也参与运算） 相加结果转为原码： 1000 0001(补码) —&gt; 1111 1110(反码)—&gt; 1111 1111(原码)=-127 C程序验证 12345678910#include &lt;stdio.h&gt;int main()&#123; char a=127, b=127; a+=1; b+=2; printf(&quot;计算结果：%d ，%d\\n&quot;, a, b); // 输出: 计算结果：-128 ，-127 return 0;&#125; 去菜鸟工具验证 要点总结 正数以及0的原码、反码、补码相同 计算机存储和运算时使用【补码】，补码运算时，符号位也参与 负数的原码、反码、补码转换过程中，符号位不变；转换过程中，即使有进位，符号位也不参与运算","categories":[{"name":"编程基础","slug":"编程基础","permalink":"https://blog.ajream.top/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"补码","slug":"补码","permalink":"https://blog.ajream.top/tags/%E8%A1%A5%E7%A0%81/"}]},{"title":"概率论与数理统计","slug":"概率论与数理统计","date":"2022-01-14T03:31:13.000Z","updated":"2022-01-16T06:10:05.000Z","comments":true,"path":"posts/28d5cef4/","link":"","permalink":"https://blog.ajream.top/posts/28d5cef4/","excerpt":"","text":"第一章 随机事件及其概率 样本点：对于随机试验，把每一个可能的结果称为样本点 随机事件：某些样本点的集合 基本事件：单个样本点构成的集合 样本空间(或必然事件)：所有样本点构成的集合，记作 Ω 不可能事件：不含任何样本点，记作 ⊘\\oslash⊘ 事件关系运算 交换律：A∪B=B∪A, A∩B=B∩AA\\cup B=B \\cup A, ~~A\\cap B=B \\cap AA∪B=B∪A, A∩B=B∩A 结合律：A∪(B∪C)=(A∪B)∪C, A(BC)=(AB)CA\\cup (B\\cup C)=(A\\cup B)\\cup C, ~A(BC)=(AB)CA∪(B∪C)=(A∪B)∪C, A(BC)=(AB)C 分配律：A(B∪C)=(AB)∪(AC)A(B\\cup C)=(AB)\\cup (AC)A(B∪C)=(AB)∪(AC), (AB)∪C=(A∪C)(B∪C)(AB)\\cup C=(A\\cup C)(B\\cup C)(AB)∪C=(A∪C)(B∪C), A(B−C)=AB−ACA(B-C)=AB-ACA(B−C)=AB−AC 对偶率：A∪B‾=A‾∩B‾\\overline{A\\cup B}=\\overline{A}\\cap \\overline{B}A∪B=A∩B, A∩B‾=A‾∪B‾\\overline{A\\cap B}=\\overline{A}\\cup \\overline{B}A∩B=A∪B 事件的积：A∩B=ABA\\cap B=ABA∩B=AB 事件的和：A∪B→直和AB互不相容A+BA\\cup B\\xrightarrow[直和]{AB互不相容}A+BA∪BAB互不相容直和​A+B 事件的差：A−B=AΩ−AB=AB‾A-B=A\\Omega-AB=A\\overline{B}A−B=AΩ−AB=AB 概率性质 对于任意事件A，0≤P(A)≤10 \\le P(A)\\le 10≤P(A)≤1 P(Ω)=1，P(⊘)=0P(Ω)=1， P(\\oslash)=0P(Ω)=1，P(⊘)=0 对于两两互斥的有限多个事件A1 ,A2 ,...,Am A_1~, A_2~, ..., A_m~A1​ ,A2​ ,...,Am​ P(A1 +A2 +...+Am )=P(A1 )+P(A2 )+...+P(Am )P(A_1~+A_2~+...+A_m~) = P(A_1~) + P(A_2~) + ... + P(A_m~)P(A1​ +A2​ +...+Am​ )=P(A1​ )+P(A2​ )+...+P(Am​ ) 推论 P(A‾)=1−P(A)P(\\overline A)=1-P(A)P(A)=1−P(A) 任意时候：P(A−B)=P(A)−P(AB)P(A-B)=P(A)-P(AB)P(A−B)=P(A)−P(AB) 若 A⊃BA\\supset BA⊃B , 则 P(A−B)=P(A)−P(B)P(A-B)=P(A)-P(B)P(A−B)=P(A)−P(B) P(A∪B)=P(A)+P(B)−P(AB)P(A\\cup B)=P(A)+P(B)-P(AB)P(A∪B)=P(A)+P(B)−P(AB) 因此，P(AB)=P(A)+P(B)−P(A∪B)P(AB)=P(A)+P(B)-P(A\\cup B)P(AB)=P(A)+P(B)−P(A∪B) 条件概率 全概率公式 Bayes公式 条件概率 P(A∣B)=P(AB)P(B)P(A|B)=\\frac{P(AB)}{P(B)}P(A∣B)=P(B)P(AB)​ 乘法定理 P(AB)=P(B)P(A∣B)=P(A)P(B∣A)P(AB)=P(B)P(A|B)=P(A)P(B|A)P(AB)=P(B)P(A∣B)=P(A)P(B∣A) 全概率公式 P(B)=∑i=1nP(AiB)=∑i=1nP(Ai)P(B∣Ai)P(B)=\\sum_{i=1}^{n}P(A_i B)=\\sum_{i=1}^{n}P(A_i)P(B|A_i) P(B)=i=1∑n​P(Ai​B)=i=1∑n​P(Ai​)P(B∣Ai​) Bayes公式 P(Ai∣B)=P(AiB)P(B)=P(Ai)P(B∣Ai)∑i=1nP(Ai)P(B∣Ai)P(A_i|B)=\\frac{P(A_iB)}{P(B)}=\\frac{P(A_i)P(B|Ai)}{\\sum_{i=1}^{n}P(A_i)P(B|A_i)} P(Ai​∣B)=P(B)P(Ai​B)​=∑i=1n​P(Ai​)P(B∣Ai​)P(Ai​)P(B∣Ai)​ 事件的独立性 定义：若 P(AB)=P(A)P(B)P(AB)=P(A)P(B)P(AB)=P(A)P(B), 则A与B是相互独立的 性质： 必然事件 Ω， 不可能事件 ⊘\\oslash⊘ 与任何事件独立 若A与BA与BA与B独立，则 AAA与B‾\\overline BB , A‾与B\\overline{A}与BA与B， A‾与B‾\\overline{A}与\\overline{B}A与B也独立 第二章 随机变量及其分布 随机变量定义 随机变量： ​ (Ω,F,P)(\\Omega,\\mathcal{F},P)(Ω,F,P)是一个概率空间， ξ(ω)\\xi(\\omega)ξ(ω) 是定义在 Ω\\OmegaΩ 内的一个单值函数，如果对任意实数x，有{ω:ξ(ω)≤x}∈F\\{\\omega:\\xi(\\omega)\\le x\\}\\in \\mathcal{F}{ω:ξ(ω)≤x}∈F , 则称 ξ(ω)\\xi(\\omega)ξ(ω) 为随机变量，记作 ξ\\xiξ. 可以看到，ξ(ω)\\xi(\\omega)ξ(ω)是一个函数，ω为自变量，定义域为 Ω 。 分布函数： ​ 称F(x)=P{ξ(ω)≤x},−∞&lt;x&lt;+∞F(x)=P{\\{\\xi(\\omega)\\le x\\}}, -\\infty&lt;x&lt;+\\inftyF(x)=P{ξ(ω)≤x},−∞&lt;x&lt;+∞ 为随机变量 ξ(ω)\\xi(\\omega)ξ(ω) 的分布函数 分布函数性质： 0≤F(x)≤10\\le F(x) \\le 10≤F(x)≤1 F(x)F(x)F(x)单调不减 F(−∞)=lim⁡x→−∞F(x)=0F(-\\infty)=\\lim_{x \\to -\\infty} F(x)=0F(−∞)=limx→−∞​F(x)=0,F(+∞)=lim⁡x→+∞F(x)=1F(+\\infty)=\\lim_{x\\to +\\infty} F(x)=1F(+∞)=limx→+∞​F(x)=1 F(x)F(x)F(x)是右连续的 几个公式： P{a&lt;ξ(ω)≤b}=F(b)−F(a)P\\{a&lt;\\xi(\\omega)\\le b\\}=F(b)-F(a)P{a&lt;ξ(ω)≤b}=F(b)−F(a) P{ξ(ω)&lt;b}=F(b−)P\\{\\xi(\\omega)&lt; b\\}=F(b^-)P{ξ(ω)&lt;b}=F(b−) P{ξ(ω)=b}=F(b)−F(b−)P\\{\\xi(\\omega)= b\\}=F(b)-F(b^-)P{ξ(ω)=b}=F(b)−F(b−) P{a≤ξ(ω)&lt;b}=F(b−)−F(a−)P\\{a\\le\\xi(\\omega)&lt; b\\}=F(b^-)-F(a^-)P{a≤ξ(ω)&lt;b}=F(b−)−F(a−) 对于连续型随机变量：F(b)=F(b−)F(b) = F(b^-)F(b)=F(b−) 离散型随机变量 分布函数：F(x)=∑xk≤xP{X=xk}F(x)=\\sum_{x_k\\le x} P\\{X=x_k\\}F(x)=∑xk​≤x​P{X=xk​} 分布律：P{X=xi}=pi, (i=1,2,3,...,n,...)P\\{X=x_i\\}=p_i,~~~(i=1,2,3,...,n,...)P{X=xi​}=pi​, (i=1,2,3,...,n,...) XXX x1x_1x1​ x2x_2x2​ x3x_3x3​ … pip_ipi​ p1p_1p1​ p2p_2p2​ p3p_3p3​ … 常用离散分布 退化分布 P{X=c}=1P\\{X=c\\}=1P{X=c}=1 两点分布 P{X=k}=pk(1−p)1−k (k=0,1)P\\{X=k\\}=p^{k}(1-p)^{1-k}~~~(k=0,1)P{X=k}=pk(1−p)1−k (k=0,1) 均匀分布 P{X=xk}=1n (k=1,2,3,...,n)P\\{X=x_k\\}= \\frac{1}{n}~~~~~~(k=1,2,3,...,n)P{X=xk​}=n1​ (k=1,2,3,...,n) 二项分布 若 X∼B(n,p)X\\sim B(n, p)X∼B(n,p), 则 P{X=k}=Cnkpk(1−p)n−kP\\{X=k\\}=C_n^k p^k(1-p)^{n-k}P{X=k}=Cnk​pk(1−p)n−k 泊松分布 若 X∼P(λ)X\\sim P(λ)X∼P(λ)， 则 P{X=k}=λkk!e−λP\\{X=k\\}=\\frac{\\lambda ^k}{k!}e^{-\\lambda}P{X=k}=k!λk​e−λ 【泊松定理】：当n很大，pnp_npn​很小时且λ&gt;0λ&gt;0λ&gt;0时，可以用泊松分布近似为 二项分布，其中 λ=limn→∞ npn\\lambda =lim_{n \\to \\infty} ~np_nλ=limn→∞​ npn​ 连续型随机变量 分布函数与概率密度关系 F(x)=∫−∞xp(x)dxF(x)=\\int_{-\\infty}^{x}p(x)dxF(x)=∫−∞x​p(x)dx, 其中 p(x)p(x)p(x)为概率密度函数 常用连续分布 均匀分布 p(x)={1b−aa≤x≤b0其它p(x)=\\begin{cases}\\frac{1}{b-a} &amp; a\\le x\\le b \\\\0&amp; 其它 \\end{cases}p(x)={b−a1​0​a≤x≤b其它​ 正态分布 p(x)=12πσe−(x−μ)22σ2,−∞&lt;x&lt;+∞p(x)=\\frac{1}{\\sqrt{2\\pi}\\sigma}e^{-\\frac{(x-\\mu)^2}{2\\sigma^2}}, -\\infty&lt;x&lt;+\\infty p(x)=2π​σ1​e−2σ2(x−μ)2​,−∞&lt;x&lt;+∞ 正态分布标准化：Y=X−μσY=\\frac{X-\\mu}{\\sigma}Y=σX−μ​ 指数分布 p(x)={λe−λxx≥00其它p(x)=\\begin{cases}\\lambda e^{-\\lambda x} &amp; x\\ge0 \\\\0&amp; 其它 \\end{cases}p(x)={λe−λx0​x≥0其它​，服从指数分布记作 X∼Exp(λ)X\\sim Exp(λ)X∼Exp(λ) 特点：具有无记忆性 正态分布积分常用的公式： ∫−∞+∞e−t22dt=2π\\int_{-\\infty}^{+\\infty} e^{-\\frac{t^2}{2}} dt=\\sqrt{2\\pi} ∫−∞+∞​e−2t2​dt=2π​ 多维随机变量及其分布 由n个随机变量 X1,X2 ,...,Xn X_1, X_2~, ..., X_n~X1​,X2​ ,...,Xn​ 构成的向量 X=(X1 ,X2 ,...,Xn )X=(X_1~, X_2~, ..., X_n~)X=(X1​ ,X2​ ,...,Xn​ )称为nnn维随机变量 分布函数： F(x1,x2,...,xn)=P{X1≤x1;X2≤x2;...;Xn≤xn}F(x_1, x_2,...,x_n)=P\\{X_1\\le x_1;X_2\\le x_2;...;X_n\\le x_n\\} F(x1​,x2​,...,xn​)=P{X1​≤x1​;X2​≤x2​;...;Xn​≤xn​} 二维随机变量 对于n=2时，有下面性质 0≤F(x,y)≤10\\le F(x,y)\\le 10≤F(x,y)≤1 F(x,y)F(x,y)F(x,y)关于x和关于y分别是单调非降函数 记住下面公式 lim⁡x→−∞F(x,y)=F(−∞,y)=0lim⁡y→∞F(x,y)=F(x,−∞)=0F(+∞,+∞)=1\\lim_{x \\to -\\infty}F(x,y)=F(-\\infty,y)=0\\\\ \\lim_{y \\to \\infty} F(x,y)=F(x, -\\infty)=0\\\\ F(+\\infty,+\\infty)=1 x→−∞lim​F(x,y)=F(−∞,y)=0y→∞lim​F(x,y)=F(x,−∞)=0F(+∞,+∞)=1 F(x,y)F(x,y)F(x,y)关于每个变元是右连续的 二维离散型随机变量(X,Y)的分布律： P{X=xi;Y=yi}=pij (i,j=1,2,3,...,n)P\\{X=x_i;Y=y_i\\}=p_{ij}~~~~~~(i,j=1,2,3,...,n) P{X=xi​;Y=yi​}=pij​ (i,j=1,2,3,...,n) 二维连续型随机变量(X, Y)的二元分布函数F(x,y)如下： F(x,y)=∫−∞x∫−∞yp(x,y)dxdyF(x,y)=\\int_{-\\infty}^x\\int_{-\\infty}^yp(x,y)dxdy F(x,y)=∫−∞x​∫−∞y​p(x,y)dxdy 其中p(x,y)p(x,y)p(x,y)为联合密度函数 p(x,y)p(x,y)p(x,y)性质： 非负性：p(x,y)≥0p(x,y)\\ge0p(x,y)≥0 ∫−∞+∞∫−∞+∞p(x,y)dxdy=1\\int_{-\\infty}^{+\\infty}\\int_{-\\infty}^{+\\infty}p(x,y)dxdy=1∫−∞+∞​∫−∞+∞​p(x,y)dxdy=1 若p(x,y)p(x,y)p(x,y)在(x,y)(x,y)(x,y)处连续： ∂2F∂x∂y=p(x,y)\\frac{\\partial ^2F}{\\partial x \\partial y}=p(x,y) ∂x∂y∂2F​=p(x,y) 若D为xOyxOyxOy平面的任一区域，则 P{(X,Y)∈D}=∬Dp(u,v)dudvP\\{(X,Y)\\in D\\}=\\iint\\limits_{D} p(u,v)dudv P{(X,Y)∈D}=D∬​p(u,v)dudv 边缘分布 分布函数 FX(x)=P{X≤x}=P{X≤x;Y&lt;+∞}=F(x,+∞)F_X(x)=P\\{X\\le x\\}=P\\{X\\le x;Y&lt;+\\infty\\}=F(x,+\\infty)FX​(x)=P{X≤x}=P{X≤x;Y&lt;+∞}=F(x,+∞) FY(y)=P{Y≤y}=P{X&lt;+∞; Y≤y}=F(+∞,y)F_Y(y)=P\\{Y\\le y\\}=P\\{X&lt;+\\infty;~Y\\le y\\}=F(+\\infty,y)FY​(y)=P{Y≤y}=P{X&lt;+∞; Y≤y}=F(+∞,y) 分布律 若为离散型，则 pi⋅=∑jpijp⋅j=∑ipijp_{i\\cdot } = \\sum_{j}p_{ij} \\\\ p_{\\cdot j} = \\sum_{i} p_{ij} pi⋅​=j∑​pij​p⋅j​=i∑​pij​ 若为连续型，则 pX(x)=∫−∞+∞p(x,y)dypY(y)=∫−∞+∞p(x,y)dxp_X(x)=\\int_{-\\infty}^{+\\infty}p(x,y)dy\\\\ p_Y(y)=\\int_{-\\infty}^{+\\infty}p(x,y)dx pX​(x)=∫−∞+∞​p(x,y)dypY​(y)=∫−∞+∞​p(x,y)dx 随机变量独立性 连续型：p(x,y)=pX(x)pY(y)⟺X,Y独立p(x,y)=p_X(x)p_Y(y)\\Longleftrightarrow X,Y独立p(x,y)=pX​(x)pY​(y)⟺X,Y独立 离散型：pij=pi⋅×p⋅j⟺X,Y独立p_{ij}=p_{i\\cdot}\\times p_{\\cdot j}\\Longleftrightarrow X,Y独立pij​=pi⋅​×p⋅j​⟺X,Y独立 条件分布 离散型： P{X=xi∣Y=yj}=pijp⋅jP{Y=yj∣X=xi}=pijpi⋅P\\{X=x_i| Y=y_j\\}=\\frac{p_{ij}}{p_{\\cdot j}}\\\\P\\{Y=y_j|X=x_i\\}=\\frac{p_{ij}}{p_{i\\cdot}}P{X=xi​∣Y=yj​}=p⋅j​pij​​P{Y=yj​∣X=xi​}=pi⋅​pij​​ 连续型： p(x∣y)=p(x,y)pY(y)p(x|y)=\\frac{p(x,y)}{p_Y(y)}p(x∣y)=pY​(y)p(x,y)​ 随机变量的函数及其分布 问题: 若Y=f(X)Y=f(X)Y=f(X)，如何根据X的分布推导Y的分布？ 单个随机变量 设Y=f(X)Y=f(X)Y=f(X), 已知映射关系fff (如Y=X2)Y=X^2)Y=X2) 以及 随机变量 X 的分布律，求Y的分布？ 解：先求 FY(y)=P{Y≤y}F_Y(y)=P\\{Y\\le y\\}FY​(y)=P{Y≤y} 再求导得 pY(y)=dFY(y)dyp_Y(y)=\\frac{dF_Y(y)}{dy}pY​(y)=dydFY​(y)​ 两个随机变量 若 Z=f(X,Y)Z=f(X,Y)Z=f(X,Y) ，则 P{Z=zk}=∑f(xi,yi)=zkP{X=xi;Y=yi}P\\{Z=z_k\\}=\\sum_{f(x_i,y_i)=z_k}P\\{X=x_i;Y=y_i\\}P{Z=zk​}=∑f(xi​,yi​)=zk​​P{X=xi​;Y=yi​} 一般法： 先求FZ(z)=P{Z≤z}=P{f(X,Y)≤z}=∬f(x,y)≤zp(x,y)dxdyF_Z(z)=P\\{Z\\le z\\}=P\\{f(X,Y)\\le z\\}=\\iint\\limits_{f(x,y)\\le z}p(x,y)dxdyFZ​(z)=P{Z≤z}=P{f(X,Y)≤z}=f(x,y)≤z∬​p(x,y)dxdy 对 FZ(z)F_Z(z)FZ​(z)求导得 fZ(z)=dFZdzf_Z(z)=\\frac{dF_Z}{dz}fZ​(z)=dzdFZ​​ 特殊法： ​ 对于 Z=X+Y,Z=XY,Z=X/YZ=X+Y, Z=XY, Z=X/YZ=X+Y,Z=XY,Z=X/Y几种情况，其概率密度函数可以用下面方式计算： ​ 写出 Z=g(X,Y)Z=g(X, Y)Z=g(X,Y)的形式（如Z=X+YZ=X+YZ=X+Y）, 则解出Y=h(X,Z)Y=h(X, Z)Y=h(X,Z) （如Y=Z−XY=Z-XY=Z−X），于是fz(z)=∫−∞+∞f[x,h(x,z)]×∣∂h∂z∣dxf_z(z)=\\int_{-\\infty}^{+\\infty}f[x,h(x,z)]\\times|\\frac{\\partial h}{\\partial z}|dxfz​(z)=∫−∞+∞​f[x,h(x,z)]×∣∂z∂h​∣dx 第三章 随机变量数字特征 数学期望 离散随机变量： E(X)=∑n=1∞xnpnE(X)=\\sum_{n=1}^{\\infty}x_np_nE(X)=∑n=1∞​xn​pn​ 连续随机变量： E(X)=∫−∞+∞xp(x)dxE(X)=\\int_{-\\infty}^{+\\infty}xp(x)dxE(X)=∫−∞+∞​xp(x)dx 注意：有时为了方便，E(X)E(X)E(X)也写作EXEXEX 随机变量函数Y=f(X)的数学期望E(Y)： 离散：E(Y)=E[f(X)]=∑i=1∞f(xi)piE(Y)=E[f(X)]=\\sum_{i=1}^{\\infty}f(x_i)p_iE(Y)=E[f(X)]=∑i=1∞​f(xi​)pi​ 连续：E(Y)=E[f(X)]=∫−∞+∞f(x)p(x)dxE(Y)=E[f(X)]=\\int_{-\\infty}^{+\\infty}f(x)p(x)dxE(Y)=E[f(X)]=∫−∞+∞​f(x)p(x)dx 二维随机变量Z=f(X,Y)Z=f(X,Y)Z=f(X,Y)，若E(Z)E(Z)E(Z)存在，求E(Z)E(Z)E(Z) 离散：E(Z)=∑i=1∞∑j=1∞f(xi,yj)pijE(Z)=\\sum_{i=1}^{\\infty}\\sum_{j=1}^{\\infty}f(x_i,y_j)p_{ij}E(Z)=∑i=1∞​∑j=1∞​f(xi​,yj​)pij​ 连续：E(Z)=∫−∞+∞∫−∞+∞f(x,y)p(x,y)dxdyE(Z)=\\int_{-\\infty}^{+\\infty}\\int_{-\\infty}^{+\\infty}f(x,y)p(x,y)dxdyE(Z)=∫−∞+∞​∫−∞+∞​f(x,y)p(x,y)dxdy 数学期望性质 E(C)=CE(C)=CE(C)=C, (CCC为常数) E(kX)=kE(X),E(X+Y)=E(X)+E(Y)E(kX)=kE(X), E(X+Y)=E(X)+E(Y)E(kX)=kE(X),E(X+Y)=E(X)+E(Y) （不需要X、Y独立） 若X、Y独立，E(XY)=E(X)E(Y)若X、Y独立，E(XY)=E(X)E(Y)若X、Y独立，E(XY)=E(X)E(Y) （注意，不能用该方法证明X、Y是独立的） 方差和矩 方差定义：D(X)=E[X−E(X)]2D(X)=E[X-E(X)]^2D(X)=E[X−E(X)]2，标准差 σX=D(X)\\sigma_X=\\sqrt{D(X)}σX​=D(X)​ 计算公式 方法一（定义法） 离散场合：D(X)=E[X−E(X)]2=∑i=1∞(xi−E(X))2pi{\\color{black} D(X)=E[X-E(X)]^2=\\sum_{i=1}^{\\infty}(x_i-E(X))^2p_i}D(X)=E[X−E(X)]2=∑i=1∞​(xi​−E(X))2pi​ 连续场合：D(X)=E[X−E(X)]2=∫−∞+∞(x−E(X))2p(x)dx{\\color{black}D(X)=E[X-E(X)]^2=\\int_{-\\infty}^{+\\infty}(x-E(X))^2p(x)dx}D(X)=E[X−E(X)]2=∫−∞+∞​(x−E(X))2p(x)dx 方法二 D(X)=E(X2)−[E(X)]2D(X)=E(X^2)-[E(X)]^2D(X)=E(X2)−[E(X)]2 方差性质 D(C)=0D(C)=0D(C)=0, CCC为常数 D(kX)=k2D(X)D(kX)=k^2D(X)D(kX)=k2D(X) 若X，Y独立，D(X±Y)=D(X)+D(Y)D(X±Y) = D(X) + D(Y)D(X±Y)=D(X)+D(Y) 常用分布的期望和方差 分布 期望E(X) 方差D(X) 二项分布（离散） npnpnp np(1−p)np(1-p)np(1−p) 泊松分布（离散） λλλ λλλ 几何分布（离散） 1/p1/p1/p (1−p)/p2(1-p)/p^2(1−p)/p2 指数分布（连续） 1/λ1/λ1/λ 1/λ21/λ^21/λ2 均匀分布（连续） (a+b)/2(a+b)/2(a+b)/2 (a−b)2/12(a-b)^2/12(a−b)2/12 正态分布（连续） μ\\muμ σ2\\sigma^2σ2 对于[正态分布]，有 E(X2)=μ2+σ2E(X^2)=\\mu^2+\\sigma^2E(X2)=μ2+σ2 其它分布 E(X2)=D(X)+[E(X)]2E(X^2)=D(X)+[E(X)]^2E(X2)=D(X)+[E(X)]2 矩 原点矩：k阶原点矩 αk=E(Xk)\\alpha_k=E(X^k)αk​=E(Xk), k=1k=1k=1时即为数学期望E(X) 中心距：k阶中心距 μk=E[X−E(X)]k\\mu_k=E[X-E(X)]^kμk​=E[X−E(X)]k , k=2k=2k=2时即为方差D(X) 协方差与相关系数 协方差 随机变量X与Y的协方差记为 cov(X,Y)cov(X,Y)cov(X,Y)，即 cov(X,Y)=E[(X−EX)(Y−EY)]cov(X,Y)=E[(X-EX)(Y-EY)] cov(X,Y)=E[(X−EX)(Y−EY)] 协方差性质： cov(X,Y)=cov(Y,X)cov(X,Y)=cov(Y,X)cov(X,Y)=cov(Y,X) cov(X,Y)=E(XY)−E(X)E(Y)cov(X,Y)=E(XY)-E(X)E(Y)cov(X,Y)=E(XY)−E(X)E(Y) cov(aX,bY)=ab×cov(X,Y)cov(aX, bY)=ab\\times cov(X,Y)cov(aX,bY)=ab×cov(X,Y) cov(X1+X2,Y)=cov(X1,Y)+cov(X2,Y)cov(X_1+X_2,Y)=cov(X_1,Y)+cov(X_2,Y)cov(X1​+X2​,Y)=cov(X1​,Y)+cov(X2​,Y) 若X，YX，YX，Y独立，则 cov(X,Y)=0cov(X,Y)=0cov(X,Y)=0 D(X±Y)=D(X)+D(Y)±2cov(X,Y)D(X\\pm Y)=D(X)+D(Y)\\pm 2cov(X,Y)D(X±Y)=D(X)+D(Y)±2cov(X,Y) 相关系数 ρXY=cov(X,Y)σXσY\\rho_{XY}=\\frac{cov(X,Y)}{\\sigma_X\\sigma_Y} ρXY​=σX​σY​cov(X,Y)​ 其中σX,σY\\sigma_X,\\sigma_YσX​,σY​ 分别为 X，Y的标准差；当 ρXY=0\\rho_{XY}=0ρXY​=0时，则称 X，Y 不相关 性质： 对于任意随机变量X和Y，均有 ∣ρXY∣≤1|\\rho_{XY}|\\le1∣ρXY​∣≤1 ρXY=1⟺P{Y=aX+b}=1\\rho_{XY}=1\\Longleftrightarrow P\\{Y=aX+b\\}=1ρXY​=1⟺P{Y=aX+b}=1，其中a和b均为常数且a≠0a\\ne0a=0 X和Y相互独立→\\rightarrow→ X和Y不相关 （反之不成立，除非X、Y均服从正态分布） 第四章 极限定理 大数定律 大数定律：设{Xn}\\{X_n\\}{Xn​}是一个随机变量序列，{an}\\{a_n\\}{an​}是一个常数序列，若对任意实数ε&gt;0, 都有 lim⁡n→+∞P{∣1n∑i=1nXi−an∣&lt;ε}=1 即1n∑i=1nXi−an→P0\\lim_{n\\to+\\infty}P\\{\\mid\\frac{1}{n}\\sum_{i=1}^{n}X_i - a_n\\mid&lt;\\varepsilon \\}=1~~即 \\frac{1}{n}\\sum_{i=1}^{n}X_i-a_n\\overset{P}{\\rightarrow}0 n→+∞lim​P{∣n1​i=1∑n​Xi​−an​∣&lt;ε}=1 即n1​i=1∑n​Xi​−an​→P0 则称{Xn}\\{X_n\\}{Xn​}服从大数定律。 切比雪夫大数定律： lim⁡n→∞P{∣1n∑i=1nXi−1n∑i=1nE(Xi)∣&lt;ε}=1即 1n∑i=1n(Xi−E(Xi))→P0\\lim_{n \\to \\infty} P\\{|\\frac{1}{n}\\sum _{i=1}^{n}X_i-\\frac{1}{n}\\sum_{i=1}^{n}E(X_i)|&lt;\\varepsilon \\}=1\\\\ 即~~~~~ \\frac{1}{n}\\sum _{i=1}^{n} (X_i-E(X_i))\\overset{P}{\\rightarrow}0 n→∞lim​P{∣n1​i=1∑n​Xi​−n1​i=1∑n​E(Xi​)∣&lt;ε}=1即 n1​i=1∑n​(Xi​−E(Xi​))→P0 切比雪夫不等式： P{∣X−E(X)∣≥ε}≤D(X)ε2P\\{|X-E(X)|\\ge \\varepsilon \\}\\le\\frac{D(X)}{\\varepsilon ^2} P{∣X−E(X)∣≥ε}≤ε2D(X)​ 伯努利大数定律：设nAn_AnA​为n重伯努律试验中A出现的次数，p为每次试验中A出现的概率，则对任意实数ε&gt;0ε&gt;0ε&gt;0，都有 lim⁡n→∞P{∣nAn−p∣&lt;ε}=1\\lim_{n \\to \\infty} P\\{|\\frac{n_A}{n}-p |&lt;\\varepsilon \\}=1 n→∞lim​P{∣nnA​​−p∣&lt;ε}=1 可以理解为，当试验次数n足够大时，A事件发生的频率 nAn\\frac{n_A}{n}nnA​​ 近似等于A事件发生的概率 辛钦大数定律：设随机变量序列{Xn}\\{X_n\\}{Xn​}独立同分布，且E(Xi)=μE(X_i)=μE(Xi​)=μ，则对任意实数ε&gt;0ε&gt;0ε&gt;0，都有 lim⁡n→∞P{∣1n∑i=1nXi−μ∣&lt;ε}=1\\lim_{n \\to \\infty} P\\{|\\frac{1}{n}\\sum_{i=1}^{n}X_i-\\mu |&lt;\\varepsilon \\}=1 n→∞lim​P{∣n1​i=1∑n​Xi​−μ∣&lt;ε}=1 中心极限定理 林德贝格-列维中心极限定理（独立同分布中心极限定理）： ​ 设随机变量序列{Xn}\\{X_n\\}{Xn​}独立同分布，且存在数学期望E(Xi)=μE(X_i)=\\muE(Xi​)=μ和方差D(Xi)=σ2&gt;0D(X_i)=\\sigma^2&gt;0D(Xi​)=σ2&gt;0,则对于任意xxx，有 lim⁡n→∞P{∑i=1nXi−nμnσ≤x}=Φ(x)\\lim_{n \\to \\infty} P\\{\\frac{\\sum_{i=1}^{n} X_i-n\\mu}{\\sqrt{n}\\sigma } \\le x \\}=\\Phi(x) n→∞lim​P{n​σ∑i=1n​Xi​−nμ​≤x}=Φ(x) 其中 Φ(x)=∫−∞+∞12πex22dx\\Phi (x)=\\int_{-\\infty }^{+\\infty } \\frac{1}{\\sqrt{2\\pi} }e^{\\frac{x^2}{2}}dxΦ(x)=∫−∞+∞​2π​1​e2x2​dx 为标准正态分布函数 注意观察，可以发现 nμn\\munμ就是 ∑i=1nXi\\sum_{i=1}^{n}X_i∑i=1n​Xi​的数学期望，分母 nσ\\sqrt{n}\\sigman​σ就是∑i=1nXi\\sum_{i=1}^{n}X_i∑i=1n​Xi​的标准差（可以与下一个定理进行比较，方便记住公式） 该定理表明，独立同分布序列，只要方差存在且不为0，当n足够大，就有 ∑i=1nXi−nμnσ∼AN(0,1)\\frac{\\sum_{i=1}^{n} X_i-n\\mu}{\\sqrt{n}\\sigma } \\sim AN(0,1) n​σ∑i=1n​Xi​−nμ​∼AN(0,1) AN(0,1)AN(0,1)AN(0,1)表示近似(almost)标准正态分布, 从而 ∑ni=1Xi∼AN(nμ,nσ2)\\sum_{n}^{i=1}X_i\\sim AN(n\\mu, n\\sigma^2) n∑i=1​Xi​∼AN(nμ,nσ2) 棣莫弗-拉普拉斯定理：设随机变量 YnY_nYn​ ~ B(n,p)（n=1,2,...）B(n, p)（n=1,2,...）B(n,p)（n=1,2,...），对任意xxx，有 lim⁡n→∞P{Yn−npnp(1−p)≤x}=Φ(x)\\lim_{n \\to \\infty} P\\{\\frac{Y_n-np}{\\sqrt{np(1-p)} }\\le x \\}=\\Phi(x) n→∞lim​P{np(1−p)​Yn​−np​≤x}=Φ(x) （注意与上一个定理——独立同分布中心极限定理，进行对比，方便记忆） 第五章 数理统计基本概念与抽样分布 基本概念 总体：在数理统计中，一个随机变量X或分布函数F(x)F(x)F(x)称为一个总体 样本：在一个总体XXX中，随机抽取n个个体X1,...,XnX_1,...,X_nX1​,...,Xn​，称为来自总体X的容量为n的样本，通常记为(X1,...,Xn)(X_1,...,X_n)(X1​,...,Xn​) 样本值：在一次抽样观察后，得到的一组数值(X1,...,Xn)(X_1,...,X_n)(X1​,...,Xn​)，称之为样本(X1,...,Xn)(X_1,...,X_n)(X1​,...,Xn​)的观测值，简称为样本值 样本空间：样本(X1,...,Xn)(X_1,...,X_n)(X1​,...,Xn​)所有可能取值的全体称为样本空间，记作 ΩΩΩ 随机抽取的样本应该满足以下两个条件，满足这2个条件的称之为简单随机样本 代表性 独立性 样本的分布 设(X1,...,Xn)(X_1,...,X_n)(X1​,...,Xn​)是来自总体X的一个样本 （X是连续情况）若总体X的分布密度函数为p(x)p(x)p(x)，则样本的联合分布密度函数为 ∏i=1np(xi)\\prod_{i=1}^{n}p(x_i)∏i=1n​p(xi​) （X是离散情况）总体X的分布律为 P{X=xi∗}=p(xi∗)P\\{X=x_i^*\\}=p(x_i^*)P{X=xi∗​}=p(xi∗​)，则样本的联合分布律为 ∏i=1np(xi)\\prod_{i=1}^{n}p(x_i)∏i=1n​p(xi​) 总体X的分布函数为F(x)，则样本的联合分布函数为 ∏i=1nF(xi)\\prod_{i=1}^{n}F(x_i)∏i=1n​F(xi​) 统计量 定义： 设(X1,...,Xn)(X_1,...,X_n)(X1​,...,Xn​)是来自总体X的一个样本，若样本的函数f(X1,X2,...,Xn)f(X_1,X_2,...,X_n)f(X1​,X2​,...,Xn​)不含任何未知参数，则称f(X1,X2,...,Xn)f(X_1,X_2,...,X_n)f(X1​,X2​,...,Xn​)是一个统计量； 若(x1,x2,...,xn)(x_1,x_2,...,x_n)(x1​,x2​,...,xn​)是一个样本值，则称f(x1,x2,...,xn)f(x_1,x_2,...,x_n)f(x1​,x2​,...,xn​)为统计量f(X1,X2,...,Xn)f(X_1,X_2,...,X_n)f(X1​,X2​,...,Xn​) 的一个观测值 可以看到，统计量来自总体（是总体的一个样本），不含任何未知参数，完全由样本来确定，也就是说，根据样本可以求出我们需要的任何一个统计量的值。 例如：设样本(X1,...,Xn)(X_1,...,X_n)(X1​,...,Xn​)来自正态总体XXX~N(μ,σ2)N(μ,σ^2)N(μ,σ2)，其中μμμ已知而σσσ未知，则 ∑i=1nXi\\sum_{i=1}^n X_i∑i=1n​Xi​ 和 1n∑i=1n(Xi−μ)2\\frac{1}{n}\\sum_{i=1}^{n}(X_i-\\mu)^2n1​∑i=1n​(Xi​−μ)2 是统计量 1σ2∑i=1n(Xi−μ)2\\frac{1}{\\sigma^2}\\sum_{i=1}^{n}(X_i-\\mu)^2σ21​∑i=1n​(Xi​−μ)2 不是统计量 常用统计量——样本矩 样本均值 X‾=1n∑i=1nXi\\overline{X}=\\frac{1}{n} \\sum_{i=1}^{n}X_iX=n1​∑i=1n​Xi​ 样本方差 Sn2=1n∑i=1n(Xi−X‾)2=1n∑i=1nXi2−X‾2S_n^2=\\frac{1}{n}\\sum_{i=1}^{n}(X_i-\\overline{X})^2=\\frac{1}{n}\\sum_{i=1}^{n}X_i^2-\\overline{X}^2Sn2​=n1​∑i=1n​(Xi​−X)2=n1​∑i=1n​Xi2​−X2 样本标准差 Sn=Sn2S_n=\\sqrt{S_n^2}Sn​=Sn2​​ 修正样本方差 Sn∗2=1n−1∑i=1n(Xi−X‾)2=nn−1Sn2S_n^{*^2}=\\frac{1}{n-1}\\sum_{i=1}^{n}(X_i-\\overline{X})^2=\\frac{n}{n-1}S_n^2Sn∗2​=n−11​∑i=1n​(Xi​−X)2=n−1n​Sn2​ 修正样本标准差 Sn∗=Sn∗2S_n^{*}=\\sqrt{S_n^{*^2}}Sn∗​=Sn∗2​​ 样本k阶原点矩 Ak=1n∑i=1nXikA_k=\\frac{1}{n} \\sum_{i=1}^{n}X_i^kAk​=n1​∑i=1n​Xik​ 样本k阶中心矩 Bk=1n∑i=1n(Xi−X‾)kB_k=\\frac{1}{n} \\sum_{i=1}^{n}(X_i-\\overline{X} )^kBk​=n1​∑i=1n​(Xi​−X)k 性质(重要) E(X‾)=E(X)E(\\overline{X})=E(X)E(X)=E(X) D(X‾)=1nD(X)D(\\overline{X})=\\frac{1}{n}D(X)D(X)=n1​D(X) E(Sn2)=n−1nD(X)E(S_n^2)=\\frac{n-1}{n}D(X)E(Sn2​)=nn−1​D(X) E(Sn∗2)=D(X)E(S_n^{*2})=D(X)E(Sn∗2​)=D(X) 次序统计量（不重要，跳过） 常用统计分布 χ\\chiχ 分布 定义：设随机变量X1,X2,...,XnX_1,X_2,...,X_nX1​,X2​,...,Xn​ 独立同分布，且每个 Xi∼N(0,1), i=1,2,...,nX_i \\sim N(0,1),~~i=1,2,...,nXi​∼N(0,1), i=1,2,...,n,则称随机变量： χn2=∑i=1nXi2\\chi^2_{n}=\\sum_{i=1}^{n}X_i^2 χn2​=i=1∑n​Xi2​ 服从自由度为n的卡方(χ2\\chi^2χ2)分布, 记为 χn2∼χ2(n)\\chi^2_n \\sim \\chi^2(n)χn2​∼χ2(n),随机变量 χn2\\chi_n^2χn2​亦被称为 χ2\\chi^2χ2变量 伽马函数(不需要记) Γ(α)=∫0+∞xα−1e−xdx,(α&gt;0)\\Gamma(\\alpha)=\\int_0^{+\\infty}x^{\\alpha-1}e^{-x}dx , (\\alpha&gt;0) Γ(α)=∫0+∞​xα−1e−xdx,(α&gt;0) 根据定义得出以下结论 若总体X∼N(0,1), (X1,X2,...,X3)X\\sim N(0,1),~~(X_1,X_2,...,X_3)X∼N(0,1), (X1​,X2​,...,X3​)是其中一个样本，则统计量 ∑i=1nXi2∼χ2(n)\\sum_{i=1}^nX_i^2\\sim \\chi^2(n)∑i=1n​Xi2​∼χ2(n) 若总体X∼N(μ,σ2), (X1,X2,...,X3)X\\sim N(\\mu,\\sigma^2),~~(X_1,X_2,...,X_3)X∼N(μ,σ2), (X1​,X2​,...,X3​)是其中一个样本，则统计量 1σ2∑i=1n(Xi−μ)2∼χ2(n)\\frac{1}{\\sigma^2}\\sum_{i=1}^n(X_i-\\mu)^2 \\sim \\chi^2(n)σ21​∑i=1n​(Xi​−μ)2∼χ2(n) 性质一 E(χn2)=nD(χn2)=2nE(\\chi^2_n)=n \\\\ D(\\chi^2_n)=2n E(χn2​)=nD(χn2​)=2n 性质二（可加性） 若X1∼χ2(n1),X2∼χ2(n2)X_1\\sim \\chi^2(n_1), X_2\\sim \\chi^2(n_2)X1​∼χ2(n1​),X2​∼χ2(n2​), 且 X1,X2X_1, X_2X1​,X2​相互独立，则 X1+X2∼χ2(n1+n2)X_1+X_2 \\sim \\chi^2(n_1+n_2) X1​+X2​∼χ2(n1​+n2​) 性质三 χn2∼AN(n,2n)\\chi^2_n\\sim AN(n,2n) χn2​∼AN(n,2n) t 分布 定义：设X∼N(0,1),Y∼χ2(n)X\\sim N(0,1), Y\\sim \\chi^2(n)X∼N(0,1),Y∼χ2(n), 且X,YX,YX,Y相互独立，则称随机变量 T=XY/nT=\\frac{X}{\\sqrt{Y/n}} T=Y/n​X​ 服从自由度为n的t分布，记为T∼t(n)T\\sim t(n)T∼t(n),随机变量T也称为t变量 t分布是关于y轴对称的 当n=1时，p(x)=1π11+x2p(x)=\\frac{1}{\\pi}\\frac{1}{1+x^2}p(x)=π1​1+x21​, 为柯西分布 当n充分大时，t分布趋于标准正态分布 性质一 E(T)=0D(T)=nn−2E(T)=0\\\\ D(T)=\\frac{n}{n-2} E(T)=0D(T)=n−2n​ 性质二 lim⁡n→∞p(x)=12πe−x22\\lim_{n\\to \\infty}p(x)=\\frac{1}{\\sqrt{2\\pi}}e^{-\\frac{x^2}{2}} n→∞lim​p(x)=2π​1​e−2x2​ 即n足够大(n&gt;30即可)时，近似看作服从标准正态分布，记作T∼AN(0,1)T\\sim AN(0,1)T∼AN(0,1) 但在n较小时，就与标准正态分布有较大差距，在t分布的尾部比标准正态分布的尾部有更大的概率，即 P{∣T∣≥t0}≥P{∣X∣≥t0}P\\{|T|\\ge t_0\\} \\ge P\\{|X|\\ge t_0\\} P{∣T∣≥t0​}≥P{∣X∣≥t0​} F 分布 定义：设 X∼χ2(n1),Y∼χ2(n2)X\\sim \\chi^2(n_1),Y\\sim \\chi^2(n_2)X∼χ2(n1​),Y∼χ2(n2​), 且X与Y相互独立，则称随机变量 F=X/n1Y/n2F=\\frac{X/n_1}{Y/n_2}F=Y/n2​X/n1​​服从自由度为(n1,n2)(n_1,n_2)(n1​,n2​)的F分布，记为F∼F(n1,n2)F\\sim F(n_1,n_2)F∼F(n1​,n2​)，其中n1n_1n1​称为第一自由度，n2n_2n2​称为第二自由度。 性质一，设 F∼F(n1,n2)F\\sim F(n_1,n_2)F∼F(n1​,n2​), 则 1F∼F(n2,n1)\\frac{1}{F} \\sim F(n_2,n_1) F1​∼F(n2​,n1​) 性质二，设 T∼t(n)T\\sim t(n)T∼t(n), 则 T2∼F(1,n)T^2\\sim F(1,n) T2∼F(1,n) 概率分布的分位数 定义：设总体X和给定的 α(0&lt;α&lt;1)\\alpha(0&lt;\\alpha&lt;1)α(0&lt;α&lt;1),若存在 xαx_{\\alpha}xα​，使得 P{X&gt;xα}=αP\\{X&gt;x_{\\alpha}\\}=\\alpha P{X&gt;xα​}=α 则称xαx_{\\alpha}xα​为此概率分布的上α分位点(或称临界值)，称x12x_{\\frac{1}{2}}x21​​为此概率分布的中位数。 标准正态分布的α分位点 Φ(uα)=1−α\\Phi(u_\\alpha)=1-\\alphaΦ(uα​)=1−α 根据标准正态分布的y轴对称性：uα=−u1−αu_\\alpha=-u_{1-\\alpha}uα​=−u1−α​ χ2\\chi^2χ2分布的α分位点 定义：P{χn2&gt;χα2(n)}=αP\\{\\chi^2_n&gt;\\chi_\\alpha^2(n)\\}=\\alphaP{χn2​&gt;χα2​(n)}=α t分布的α分位点 定义：P{T&gt;tα(n)}=αP\\{T&gt;t_\\alpha(n)\\}=\\alphaP{T&gt;tα​(n)}=α 根据t分布的y轴对称性，有 tα(n)=−t1−α(n)t_\\alpha(n)=-t_{1-\\alpha}(n)tα​(n)=−t1−α​(n) 当n较大时，有 tα=uαt_\\alpha=u_\\alphatα​=uα​ F分布的α分位点 定义：P{F&gt;Fα(n1,n2)}=αP\\{F&gt;F_\\alpha(n_1,n_2)\\}=\\alphaP{F&gt;Fα​(n1​,n2​)}=α 性质: Fα(n1,n2)=1F1−α(n2,n1)F_\\alpha(n_1,n_2)= \\frac{1}{F_{1-\\alpha}(n_2,n_1)} Fα​(n1​,n2​)=F1−α​(n2​,n1​)1​ 抽样分布(重要) 定理5.3 设总体X∼N(μ,σ2),(X1,X2,...,Xn)X\\sim N(\\mu,\\sigma^2),(X_1,X_2,...,X_n)X∼N(μ,σ2),(X1​,X2​,...,Xn​)是来自总体X的一个样本，则有： X‾∼N(μ,σ2n)\\overline{X}\\sim N(\\mu, \\frac{\\sigma^2}{n})X∼N(μ,nσ2​)或 X‾−μσ/n∼N(0,1)\\frac{\\overline{X}-\\mu}{\\sigma /\\sqrt{n}}\\sim N(0,1)σ/n​X−μ​∼N(0,1) X‾\\overline{X}X与Sn∗2、Sn2S_n^{*2}、S_n^2Sn∗2​、Sn2​相互独立 (n−1)Sn∗2σ2∼χ2(n−1)\\frac{(n-1)S_n^{*2}}{\\sigma^2}\\sim \\chi^2(n-1)σ2(n−1)Sn∗2​​∼χ2(n−1)或nSn2σ2∼χ2(n−1)\\frac{nS_n^{2}}{\\sigma^2}\\sim \\chi^2(n-1)σ2nSn2​​∼χ2(n−1) X‾−μSn∗/n∼t(n−1)\\frac{\\overline{X}-\\mu}{S_n^*/\\sqrt{n}}\\sim t(n-1)Sn∗​/n​X−μ​∼t(n−1)或 X‾−μSn/n−1∼t(n−1)\\frac{\\overline{X}-\\mu}{S_n/\\sqrt{n-1}}\\sim t(n-1)Sn​/n−1​X−μ​∼t(n−1) 定理5.4 设 X1,X2,…,Xn1X_1,X_2,\\dots,X_{n_{1}}X1​,X2​,…,Xn1​​和Y1,Y2,…,Yn2Y_1,Y_2,\\dots,Y_{n_2}Y1​,Y2​,…,Yn2​​分别是来自正态总体 N(μ1,σ12)N(\\mu_1, \\sigma^2_1)N(μ1​,σ12​)和N(μ2,σ22)N(\\mu_2, \\sigma_2^2)N(μ2​,σ22​)的样本，且这两个样本相互独立，设 X‾,Y‾\\overline{X},\\overline{Y}X,Y分别是两个样本的均值，且 Sn1∗2,Sn2∗2S_{n_1}^{*^2}, S_{n_2}^{*^2}Sn1​∗2​,Sn2​∗2​分别是这两个样本的修正样本方差，则有： Sn1∗2/Sn2∗2σ12/σ22∼F(n1−1,n2−1)\\frac{S_{n_1}^{*2}/S_{n_2}^{*2}}{\\sigma_1^2/\\sigma_2^2}\\sim F(n_1-1,n_2-1)σ12​/σ22​Sn1​∗2​/Sn2​∗2​​∼F(n1​−1,n2​−1) 当σ12=σ22=σ2\\sigma_1^2=\\sigma_2^2=\\sigma^2σ12​=σ22​=σ2时，有 (X‾−Y‾)−(μ1−μ2)Sw1n1+1n2∼t(n1+n2−2) \\frac{(\\overline{X}-\\overline{Y})-(\\mu_1-\\mu_2)}{S_w\\sqrt{\\frac{1}{n_1}+\\frac{1}{n_2}}} \\sim t(n_1+n_2-2) Sw​n1​1​+n2​1​​(X−Y)−(μ1​−μ2​)​∼t(n1​+n2​−2) 其中 Sw=(n1−1)Sn1∗2+(n2−1)Sn2∗2n1+n2−2 S_w=\\frac{(n_1-1)S_{n_1}^{*^2}+(n_2-1)S_{n_2}^{*^2}}{n_1+n_2-2} Sw​=n1​+n2​−2(n1​−1)Sn1​∗2​+(n2​−1)Sn2​∗2​​ 第六章 参数估计 参数的点估计 矩估计法 由样本矩的性质知， 样本矩依概率收敛于相应的样本总体，即 Ak=1n∑i=1nXik→PE(Xk)A_k=\\frac{1}{n}\\sum_{i=1}^{n}X_i^k\\xrightarrow{P}E(X^k) Ak​=n1​i=1∑n​Xik​P​E(Xk) Bk=1n∑i=1n(Xi−X‾)k→PE(X−EX)kB_k=\\frac{1}{n}\\sum_{i=1}^{n}(X_i-\\overline{X})^k\\xrightarrow{P}E(X-EX)^k Bk​=n1​i=1∑n​(Xi​−X)kP​E(X−EX)k 矩估计的基本思想是利用样本矩来估计总体矩获得参数的估计量（因为样本足够大时，样本矩与总体矩之间的差距可任意小），基本步骤如下： 计算【总体X】从1阶矩到m阶矩（m为未知参数的个数）：E(X),E(X2),…,E(Xm)E(X), E(X^2),\\dots,E(X^m)E(X),E(X2),…,E(Xm) 计算【样本】的矩：A1,A2,…,AmA_1, A_2,\\dots,A_mA1​,A2​,…,Am​ 解方程组 {A1=E(X)A2=E(X2)⋯Am=E(Xm) \\begin{cases} A_1=E(X)\\\\ A_2=E(X^2)\\\\ \\cdots \\\\ A_m=E(X^m) \\end{cases} ⎩⎪⎪⎪⎪⎨⎪⎪⎪⎪⎧​A1​=E(X)A2​=E(X2)⋯Am​=E(Xm)​ 得到未知参数 θi ~{\\theta}_i~ θi​ 的估计值 {θ^1=θ^1(X1,X2,…,Xn)θ^2=θ^2(X1,X2,…,Xn)⋯θ^m=θ^m(X1,X2,…,Xn) \\begin{cases} \\hat{\\theta}_1=\\hat{\\theta}_1(X_1,X_2,\\dots,X_n) \\\\ \\hat{\\theta}_2=\\hat{\\theta}_2(X_1,X_2,\\dots,X_n) \\\\ \\cdots \\\\ \\hat{\\theta}_m=\\hat{\\theta}_m(X_1,X_2,\\dots,X_n) \\end{cases} ⎩⎪⎪⎪⎪⎨⎪⎪⎪⎪⎧​θ^1​=θ^1​(X1​,X2​,…,Xn​)θ^2​=θ^2​(X1​,X2​,…,Xn​)⋯θ^m​=θ^m​(X1​,X2​,…,Xn​)​ 注意：对于样本来说，样本的所有参量认为是已知的，而总体的参量是我们需要估计的，因此，根据样本依概率矩收敛于总体矩的特性知：可以通过样本来估计总体的参量。 例如：样本的均值X‾\\overline{X}X和方差Sn2S_n^2Sn2​总是总体的数学期望E(X)E(X)E(X)和方差D(X)D(X)D(X)的矩估计量。 最大似然估计法 前提：总体的分布形式已知，如已知p(x;θ),θp(x;\\theta),\\thetap(x;θ),θ为未知参数 似然函数：样本的联合分布律 L(θ)=∏i=1np(xi;θ)L(\\theta)=\\prod_{i=1}^{n}p(x_i;\\theta)L(θ)=∏i=1n​p(xi​;θ) 基本思想：在试验中概率最大(即L(θ)最大L(\\theta)最大L(θ)最大)的事件最有可能出现，我们就是要找到这样一个参数 θ 使得其发生的概率最大。 求解步骤： 求似然函数：L(θ)=∏i=1np(xi;θ)L(\\theta)=\\prod_{i=1}^{n}p(x_i;\\theta)L(θ)=∏i=1n​p(xi​;θ) 求L(θ)L(\\theta)L(θ)最大值，一般通过求导使得 ∂ln⁡L(θ)∂θ∣θ=θ^=0\\frac{\\partial \\ln L(\\theta)}{\\partial \\theta}\\mid_{\\theta={\\hat{\\theta}}}=0∂θ∂lnL(θ)​∣θ=θ^​=0(该方程称为似然方程), 有多个参数就分别对该参数求偏导 求解第二步的方程，得到参数的估计值θi=θi^\\theta_i=\\hat{\\theta_i}θi​=θi​^​ 注意：若无法通过求导方式求解似然函数L(θ)L(θ)L(θ)最大值，可以通过分析L(θ)L(θ)L(θ)单调特性，以及θ\\thetaθ可能取值范围，从 θ取值范围中选择一个值使得L(θ)L(θ)L(θ)取得最大值，最后用该值作为该参数的估计值 估计量的优良性评判 既然是估计量，那与真实值之间就存在误差，因此需要判断估计量是否满足我们的要求，可以通过下面的几个准则来进行评判。 无偏性 定义：设(X1,X2,…,Xn)(X_1,X_2,\\dots,X_n)(X1​,X2​,…,Xn​)是来自总体XXX的一个样本，θ∈Θ\\theta \\in \\Thetaθ∈Θ 为总体分布中的未知参数，θ^=θ^(X1,X2,…,Xn)\\hat{\\theta}=\\hat{\\theta}(X_1,X_2,\\dots,X_n)θ^=θ^(X1​,X2​,…,Xn​) 是 θθθ 的一个估计量，若对任意 θ∈Θ\\theta \\in \\Thetaθ∈Θ，有 E(θ^)=θE(\\hat{\\theta})=\\theta E(θ^)=θ 则 θ^\\hat{\\theta}θ^ 为 θθθ 的无偏估计(量). 估计量的偏差：bn=E[θ^(X1,X2,…,Xn)]−θb_n=E[\\hat{\\theta}(X_1,X_2,\\dots,X_n)]-\\thetabn​=E[θ^(X1​,X2​,…,Xn​)]−θ 有偏估计量：当 bn≠0b_n \\ne0bn​=0 时，称 θ^\\hat{\\theta}θ^ 为 θθθ 的有偏估计(量) 渐进无偏估计量：若lim⁡n→∞bn=0\\lim_{n\\to \\infty}b_n=0limn→∞​bn​=0, 则称 θ^\\hat{\\theta}θ^ 为 θθθ 的渐进无偏估计(量) 有效性 定义：设 θ^1=θ^1(X1,X2,…,Xn)\\hat{\\theta}_1=\\hat{\\theta}_1(X_1,X_2,\\dots,X_n)θ^1​=θ^1​(X1​,X2​,…,Xn​) 和 θ^2=θ^2(X1,X2,…,Xn)\\hat{\\theta}_2=\\hat{\\theta}_2(X_1,X_2,\\dots,X_n)θ^2​=θ^2​(X1​,X2​,…,Xn​) 均为参数 θ\\thetaθ 的无偏估计量，若 D(θ^1)&lt;D(θ^2)D(\\hat{\\theta}_1) &lt; D(\\hat{\\theta}_2) D(θ^1​)&lt;D(θ^2​) 则称 θ^1\\hat{\\theta}_1θ^1​ 比 θ^2\\hat{\\theta}_2θ^2​ 有效 在多个无偏估计量中，方差最小(最有效)那个被称为最小方差无偏估计量 相合性(一致性) 一个优良的估计量，不仅是无偏的，且具有较小的方差，还希望当样本容量n增大时，估计量能在某种意义下收敛于被估计的参数，这就是 相合性（或一致性） 定义：设 θ^n=θ^n(X1,X2,…,Xn)\\hat{\\theta}_n=\\hat{\\theta}_n(X_1,X_2,\\dots,X_n)θ^n​=θ^n​(X1​,X2​,…,Xn​)是参数 θ\\thetaθ 的估计量，如果当 nnn 增大时，θ^n\\hat{\\theta}_nθ^n​ 依概率收敛于 θ\\thetaθ ，即对任意 ε&gt;0\\varepsilon&gt;0ε&gt;0 ，有 lim⁡n→∞P{∣θ^n−θ∣&lt;ε}=1或lim⁡n→∞P{∣θ^n−θ∣≥ε}=0\\lim_{n\\to \\infty} P\\{|\\hat{\\theta}_n-\\theta|&lt;\\varepsilon\\}=1或 \\lim_{n\\to \\infty} P\\{|\\hat{\\theta}_n-\\theta|\\ge \\varepsilon\\}=0 n→∞lim​P{∣θ^n​−θ∣&lt;ε}=1或n→∞lim​P{∣θ^n​−θ∣≥ε}=0 则称 θ^n\\hat{\\theta}_nθ^n​ 是 θ\\thetaθ 的相合估计（量），或一致估计（量） 定理：设 θ^n=θ^n(X1,X2,…,Xn)\\hat{\\theta}_n=\\hat{\\theta}_n(X_1,X_2,\\dots,X_n)θ^n​=θ^n​(X1​,X2​,…,Xn​)是参数 θ\\thetaθ 的一个估计量，若 lim⁡n→∞E(θ^n)=θ且lim⁡n→∞D(θ^n)=0\\lim_{n\\to \\infty} E(\\hat{\\theta}_n)=\\theta 且 \\lim_{n\\to \\infty} D(\\hat{\\theta}_n)=0 n→∞lim​E(θ^n​)=θ且n→∞lim​D(θ^n​)=0 则 θ^n\\hat{\\theta}_nθ^n​ 是 θ\\thetaθ 的相合估计（量），或一致估计（量） 参数的区间估计 定义：设总体X的分布函数为 F(x;θ)F(x;\\theta)F(x;θ)，θ是未知参数，(X1,X2,…,Xn)(X_1,X_2,\\dots,X_n)(X1​,X2​,…,Xn​)是来自总体X的一个样本。对于给定的 α(0&lt;α&lt;1)\\alpha (0&lt;\\alpha&lt;1)α(0&lt;α&lt;1)，确定两个统计量 θ^1=θ^1(X1,X2,…,Xn)\\hat{\\theta}_1=\\hat{\\theta}_1(X_1,X_2,\\dots,X_n)θ^1​=θ^1​(X1​,X2​,…,Xn​) 和 θ^2=θ^2(X1,X2,…,Xn)\\hat{\\theta}_2=\\hat{\\theta}_2(X_1,X_2,\\dots,X_n)θ^2​=θ^2​(X1​,X2​,…,Xn​)，使得 P{θ^1&lt;θ&lt;θ^2}=1−αP\\{\\hat{\\theta}_1 &lt; \\theta &lt; \\hat{\\theta}_2\\}=1-\\alpha P{θ^1​&lt;θ&lt;θ^2​}=1−α 则称随机区间 (θ^1,θ^2)(\\hat{\\theta}_1,\\hat{\\theta}_2)(θ^1​,θ^2​) 为参数 θ\\thetaθ 的置信度为 1−α1-\\alpha1−α 的置信区间， 置信下限：θ^1\\hat{\\theta}_1θ^1​ 置信上限：θ^2\\hat{\\theta}_2θ^2​ 置信度(置信水平)：1−α1-\\alpha1−α 如果置信区间只有一边，如： P{θ^1&lt;θ}=1−α 或 P{θ&lt;θ^2}=1−αP\\{\\hat{\\theta}_1 &lt; \\theta\\}=1-\\alpha ~或~ P\\{ \\theta &lt; \\hat{\\theta}_2\\}=1-\\alpha P{θ^1​&lt;θ}=1−α 或 P{θ&lt;θ^2​}=1−α 则称置信区间 (θ^1,+∞)(\\hat{\\theta}_1,+\\infty)(θ^1​,+∞) 或 (−∞,θ^2)(-\\infty, \\hat{\\theta}_2)(−∞,θ^2​) 为单侧置信区间 求置信区间步骤 确定统计量 WWW 给定置信度1−α1-\\alpha1−α，写出下面的式子 P{a&lt;W&lt;b}, 通常取a=x1−α2,b=xα2 P\\{a&lt;W&lt;b\\},~~通常取a=x_{1-\\frac{\\alpha}{2}}, b=x_{\\frac{\\alpha}{2}} P{a&lt;W&lt;b}, 通常取a=x1−2α​​,b=x2α​​ x1−α2x_{1-\\frac{\\alpha}{2}}x1−2α​​ 和 xα2x_{\\frac{\\alpha}{2}}x2α​​ 分别为对应分布上的 1−α21-\\frac{\\alpha}{2}1−2α​ 和 α2\\frac{\\alpha}{2}2α​ 分位点。可以看出，给定置信度1−α1-\\alpha1−α是用来确定 x1−α2x_{1-\\frac{\\alpha}{2}}x1−2α​​ 和 xα2x_{\\frac{\\alpha}{2}}x2α​​的值的 3. 上面已经求出a, b的值，所以只需要解出下面的不等式即可得出参数区间(θ^1,θ2^)(\\hat{\\theta}_1,\\hat{\\theta_2})(θ^1​,θ2​^​) a&lt;W&lt;b a&lt;W&lt;b a&lt;W&lt;b 不同分布在不同情况下应取什么统计量，参考下表 第七章 假设检验 基本原理 假设检验的基本原理：给定一个假设H0H_0H0​，为了检验H0H_0H0​是否正确，首先假定H0H_0H0​是正确的，然后根据抽取到的样本来判断是接收还是拒绝该假设。如果样本中出现了不合理的观测值，应该拒绝H0H_0H0​，否则应该接受假设H0H_0H0​ “不合理”指的是小概率事件发生，常用 α\\alphaα 来表示这个小概率，α\\alphaα也被称为检验的显著性水平 拒绝域与临界值 拒绝域 and 接受域：设Ω\\OmegaΩ 是所有样本观测值 x=(x1,x2,…,xn)x=(x_1,x_2,\\dots, x_n)x=(x1​,x2​,…,xn​) 的集合，令 W={x∣x∈Ω且使H0不成立}W=\\{x|x\\in \\Omega 且使 H_0 不成立\\} W={x∣x∈Ω且使H0​不成立} 此集合为 H0H_0H0​的拒绝域，其余集 W‾\\overline{W}W 称为 H0H_0H0​ 的接受域 从某种意义上说，设计一个检验，本质上就是找到一个恰当的拒绝域W，使得当 H0H_0H0​成立时 P{x∈W∣H0成立}=αP\\{x\\in W|H_0成立\\}=\\alpha P{x∈W∣H0​成立}=α 后面我们常把“小概率事件”视为与拒绝域WWW是等价的 两类错误 第I类错误（弃真错误）：假设H0H_0H0​经过检验后是真的，但根据一次抽样结果拒绝了 H0H_0H0​，叫做犯了第I类错误； 第II类错误（纳伪错误）：假设H0H_0H0​经过检验后是假的，但根据一次抽样结果接受了 H0H_0H0​，叫做犯了第II类错误。 通常只规定 α\\alphaα 的取值，即控制犯第I类错误的概率，而使犯第二类错误的概率尽可能小，要使两者犯错的概率都小，就必须增大样本容量。 假设检验的基本步骤 根据实际问题的要求，提出原假设 H0H_0H0​ 和备选假设 H1H_1H1​，通常 H1H_1H1​ 与 H0H_0H0​ 区间互补（做题时这一步由题目给出） 构造统计量 TTT 给定显著性水平 α\\alphaα （题目给出），确定拒绝域 计算观察值 t0t_0t0​ 作出判断：若 t0∈Wt_0 \\in Wt0​∈W，则拒绝H0H_0H0​,接受 H1H_1H1​；反之接受 H0H_0H0​，拒绝 H1H_1H1​。 根据不同情形选择不同统计量，参考下表：","categories":[{"name":"课程考试","slug":"课程考试","permalink":"https://blog.ajream.top/categories/%E8%AF%BE%E7%A8%8B%E8%80%83%E8%AF%95/"}],"tags":[{"name":"概率论","slug":"概率论","permalink":"https://blog.ajream.top/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/"}]},{"title":"利用傅里叶级数绘图","slug":"傅里叶动画","date":"2022-01-01T01:27:31.000Z","updated":"2024-03-31T14:49:40.667Z","comments":true,"path":"posts/f3a00df2/","link":"","permalink":"https://blog.ajream.top/posts/f3a00df2/","excerpt":"","text":"点击前往查看效果 理论基础 傅里叶级数： 学过傅里叶级数、傅里叶变换等知识的，都知道，满足[狄利赫里条件]的[周期函数]都能用傅里叶级数来拟合。 狄利赫里条件： 在任何周期内，x(t)须绝对可积；在任一有限区间中，x(t)只能取有限个最大值或最小值； 在任何有限区间上，x(t)只能有有限个第一类间断点。 傅里叶级数表达式： f(t)=∑k=−∞+∞akejk2πTtf(t)=\\sum_{k=-∞}^{+∞} a_ke^{jk\\frac{2\\pi}{T}t} f(t)=k=−∞∑+∞​ak​ejkT2π​t 于是，换个思路，是不是也可以用傅里叶级数来绘制各种各样的线条来组合成各种图形呢？答案是肯定的 原理理解 平面点与f(t)的转换 二维图像都是由一些点来构成的，决定点的位置就是(x, y)坐标【以xy平面为例】，因此一个点的坐标可以用一个复数来表示： z=x+jyz=x+jy z=x+jy 而f(t)是可以为复数的，把一系列的点“相加”就可以得到某一时刻的f(t)，因此可以将其用傅里叶级数展开。 复数与圆的关系 学过复变函数的同学都知道，一个复数可以进行如下转换： ejθ=cos(θ)+jsin(θ)e^{j\\theta} = cos(\\theta)+jsin(\\theta) ejθ=cos(θ)+jsin(θ) 因此： rejθ=r[cos(θ)+jsin(θ)]re^{j\\theta} = r[cos(\\theta)+jsin(\\theta)] rejθ=r[cos(θ)+jsin(θ)] 复数既可以表示一个点，也可以表示一个向量，因此r可以表示为向量的长度，θ可以表示为向量的角度，当 θ在$ [0, 2\\pi]$ 范围内变化时，表示向量在绕原点进行旋转，就构成了一个圆。 回归正题 重新看这条等式： f(t)=∑k=−∞+∞akejkωt=∑k=−∞+∞akejk2πTtf(t)=\\sum_{k=-∞}^{+∞} a_ke^{jk\\omega t}=\\sum_{k=-∞}^{+∞} a_ke^{jk\\frac{2\\pi}{T}t} f(t)=k=−∞∑+∞​ak​ejkωt=k=−∞∑+∞​ak​ejkT2π​t f(t)表示我们要绘制的图形在t时刻的一个点，而右边的复指数 akejkωta_ke^{jk\\omega t}ak​ejkωt ，表示在某一时刻t下，向量长度为 aka_kak​ ，角度为 jkωtjk\\omega tjkωt，ω即向量的旋转速度。 所以右边表示无数个向量的相加，随着时间t不断增加，向量不断旋转，就能不断计算出f(t)f(t)f(t)表示的所有点，把这些点连接就构成了我们要的图形。 注意：需保证一个图形是可以一笔画出来的，即单连通图形，如正方形等； 多个图形可以分别用 f1(t)、f2(t)、f3(t)f_1(t)、f_2(t)、f_3(t)f1​(t)、f2​(t)、f3​(t)等来进行表示，分别进行傅里叶变换。 一个图形的(x, y)坐标是由我们事先确定的，也就是说，我们事先得先确定我们要绘制什么图形，然后把它的轮廓的(x, y)坐标提取出来即可，这个后面再介绍如何通过python提取图像轮廓 确定了(x,y)坐标也就是确定了f(t), 因为f(t)可以是个复数 现在主要是解决如何将f(t)f(t)f(t)展开成傅里叶级数，即确定 akejk2πTt,(k=...−2,−1,0,1,2...)a_ke^{jk\\frac{2\\pi}{T}t},(k=...-2,-1,0,1,2...) ak​ejkT2π​t,(k=...−2,−1,0,1,2...) t是一个时间尺度，随着时间变化而变化，不需要我们去求; T为f(t)的周期，由我们绘制的图来决定，即多久绘制完一遍这个图形，通常是这个图（轮廓）的点数。 T的单位应该是秒，为什么会是点数呢？其实是用轮廓的所有点N来表示在一个周期的时间内绘制的点数，这样刚好绘制完一遍这个图; j理解成是为了表示这是一个复数，不用管; aka_kak​ 是我们要求的唯一参数，即每个向量的长度值; 在学傅里叶级数时，我们都知道系数 aka_kak​ 的求法如下： ak=1T∫−T/2T/2f(t)e−jk2πTtdta_k= \\frac{1}{T} \\int_{-T/2}^{T/2} f(t) e^{-jk\\frac{2\\pi}{T}t}dt ak​=T1​∫−T/2T/2​f(t)e−jkT2π​tdt 这是在t为连续条件下的表达式，我们可以将它转为t为离散情况( t 每次变化为Δt\\Delta tΔt)： ak=1T∑t=−T/2T/2[f(t)e−jk2πT(t)Δt]a_k=\\frac{1}{T}\\sum_{t=-T/2}^{T/2}[f(t)e^{-jk\\frac{2\\pi}{T}(t)} \\Delta t] ak​=T1​t=−T/2∑T/2​[f(t)e−jkT2π​(t)Δt] 接下来就是如何通过代码来计算 aka_kak​ 了 注意k的范围 k=...−2,−1,0,1,2...k=...-2,-1,0,1,2...k=...−2,−1,0,1,2... k表示圆的个数，由自己确定，k越大逼近效果越好，但越大会导致计算复杂度增加，对计算机性能有更高要求，建议最大不超过N（即f(t)的所有点数） 学过数字信号处理的，可以看下DFT的公式 X(k)=∑n=0N−1x(n)e−j2πNknx(n)=∑k=0N−1X(k)ej2πNkn{X}(k)=\\sum_{n=0}^{N-1} {x}(n) e^{-j\\frac{2\\pi}{N}kn} \\\\ {x}(n)=\\sum_{k=0}^{N-1} {X}(k)e^{j\\frac{2\\pi}{N}kn} X(k)=n=0∑N−1​x(n)e−jN2π​knx(n)=k=0∑N−1​X(k)ejN2π​kn 其中 X(k)X(k)X(k)实际就是aka_kak​ ，x(n)x(n)x(n)就是f(t)f(t)f(t) 代码实现 求傅里叶级数的系数 编程语言 Javascript 先实现复数的相加、相乘运算、复指数转为一般指数 在代码中用 z=[a, b]的方式来表示一个复数 z=a+jb，其实表示方式无所谓，只要能确定一个复数即可，重要的是要使它能实现复数的一些基本运算 12345678910111213141516//复数乘法//z1 = a1 + jb1，用[a1, b1]表示z1//z2 = a2 + jb2，用[a2, b2]表示z2function complexMul(z1, z2) &#123; return [z1[0] * z2[0] - z1[1] * z2[1], z1[0] * z2[1] + z2[0] * z1[1]];&#125;// 复数加法function complexAdd(z1, z2) &#123; return [z1[0] + z2[0], z1[1] + z2[1]];&#125;// 复指数转复数，z=r*(e^jθ)=r*cos(θ)+r*jsin(θ) 其中θ为复数function r_exp(r, theta) &#123; return [r * Math.cos(theta), r * Math.sin(theta)];&#125; 然后求aka_kak​，(代码里用 ”Cn“来表示)，写的时候要仔细揣摩公式： ak=1T∑t=−T/2T/2[f(t)e−jk2πT(t)Δt]a_k=\\frac{1}{T}\\sum_{t=-T/2}^{T/2}[f(t)e^{-jk\\frac{2\\pi}{T}(t)} \\Delta t] ak​=T1​t=−T/2∑T/2​[f(t)e−jkT2π​(t)Δt] 12345678910111213141516171819202122232425// K=[0, -1,1, -2,2, -3,3 ...]function get_K(circleCounts)&#123; var K = []; //length = circleCount for (var i = 0; i &lt; circleCounts; i++) &#123; K[i] = (1 + i &gt;&gt; 1) * (i &amp; 1 ? -1 : 1); //K = [0, -1,1, -2,2, -3,3, -4,4,...] &#125; return K;&#125;//参数xn，即f(t)的坐标集合，//circleCounts: 即k的大小//L不是求傅里叶级数所需要的，用它来表示将Cn放大的倍数，即向量长度放大的倍数，可以将最后绘制的图形变大function get_Cn(xn, circleCounts, L=1)&#123; xn_len = xn.length; Cn = [] //N为圆的数量 K = get_K(circleCounts); for(var k=0; k&lt;circleCounts; k++)&#123; Cn[k] = [0, 0]; for(var n=0; n&lt;xn_len;n++)&#123; Cn[k] = complexAdd(Cn[k], complexMul(xn[n], r_exp(1, -2*PI*K[k]*n/xn_len))); &#125; Cn[k][0] /= (xn_len/L); Cn[k][1] /= (xn_len/L); &#125; return Cn;&#125; 求傅里叶级数 然后是根据aka_kak​ 求 f(t)f(t)f(t) , 也就是将一个个向量加起来 f(t)=∑k=−∞+∞akejkωt=∑k=−∞+∞akejk2πTtf(t)=\\sum_{k=-∞}^{+∞} a_ke^{jk\\omega t}=\\sum_{k=-∞}^{+∞} a_ke^{jk\\frac{2\\pi}{T}t} f(t)=k=−∞∑+∞​ak​ejkωt=k=−∞∑+∞​ak​ejkT2π​t 12345678910111213141516171819202122232425// cx, cy用于确定在哪里绘制图像，即定位作用// n 即 circleCounts，越大逼近效果越好，但也会导致性能消耗更高// imgIndex 表示绘制第几个图像, 因为后面希望同时绘制几个图如f1(t)、f2(t)、f3(t)...// speed用于表示绘图速度function DrawPath(cx, cy, n = 5, imgIndex=0, speed=1) &#123; let p = [cx, cy]; //将向量求和 for (var k = 0; k &lt; n; k++) &#123; var W = r_exp(1, 2 * PI * (time_n * speed) * K[k] / imgxn[imgIndex].length); // W-因子 p = complexAdd(p, complexMul([imgCn[imgIndex][k][0], imgCn[imgIndex][k][1]], W)); &#125; var x = p[0]; var y = p[1]; valuePointer[imgIndex] = valuePointer[imgIndex]+1; values_x[imgIndex][valuePointer[imgIndex] &amp; pointCount[imgIndex]] = x; values_y[imgIndex][valuePointer[imgIndex] &amp; pointCount[imgIndex]] = y; context.beginPath(); context.lineWidth = 2 context.strokeStyle = &quot;rgba(255,100,200,1)&quot;; context.moveTo(x, y); for (var i = 1; i &lt;= pointCount[imgIndex]; ++i) &#123; context.lineTo(values_x[imgIndex][(valuePointer[imgIndex] - i) &amp; pointCount[imgIndex]], values_y[imgIndex][(valuePointer[imgIndex] - i) &amp; pointCount[imgIndex]]); &#125; context.stroke();&#125; 绘制圆和向量： 123456789101112131415function DrawCircles(cx, cy, n = 5, imgIndex=0, speed=1) &#123; let p = [cx, cy]; //第一个圆的圆心 for (var k = 0; k &lt; n; k++) &#123; context.beginPath(); var r = Math.hypot(imgCn[imgIndex][k][0], imgCn[imgIndex][k][1]); context.arc(p[0], p[1], r, 0, 2 * PI); context.lineWidth = 1; context.strokeStyle = &quot;rgba(100,150,60,1.0)&quot;; if (k != 0) &#123; context.stroke(); //第一个圆不绘制 &#125; var W = r_exp(1, 2 * PI * (time_n * speed) * K[k] / imgxn[imgIndex].length); // W-因子 p = complexAdd(p, complexMul([imgCn[imgIndex][k][0], imgCn[imgIndex][k][1]], W)); &#125;&#125; 123456789101112131415161718function DrawLines(cx, cy, n=5, imgIndex=0, speed=1) &#123; context.beginPath(); let p = [cx, cy]; //第一个圆的圆心，用于定位整个图形 for (var k = 0; k &lt; n; k++) &#123; context.moveTo(p[0], p[1]); //第一个线不画 var W = r_exp(1, 2 * PI * (time_n * speed) * K[k] / imgxn[imgIndex].length); // W-因子 p = complexAdd(p, complexMul(imgCn[imgIndex][k], W)); if(k==0) continue; context.lineTo(p[0], p[1]); &#125; context.lineWidth = 1; context.strokeStyle = &quot;rgba(255,255,255,0.8)&quot;; // context.strokeStyle = &quot;rgba(&quot; + randomx(255) + &quot;,&quot; + randomx(255) + &quot;,&quot; + randomx(255) + &quot;,0.5)&quot;; context.stroke();&#125; 如何通过python提取图像轮廓 上面这些就是绘制图形需要的基本代码，但还有一个重要问题，如何获取图形的轮廓，即获取 f(t)f(t)f(t) 【代码中是xn】，只有先得到 f(t)f(t)f(t) 才能求出 aka_kak​ 【代码中的 Cn】 方法一 通过opencv可以轻松获取图像的轮廓，以python3来调用opencv库来提取图片轮廓的方式： 123456789101112131415161718192021222324252627282930313233343536import cv2img = cv2.imread(&quot;../images/kuaile.png&quot;) #读取图片img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) # 转为灰度图img_gray = cv2.GaussianBlur(img_gray, (1,1), 0, 0) # 高斯模糊#转为二值图，小于阈值的将转为纯黑色ret, img_bin = cv2.threshold(img_gray, 100, 255,cv2.THRESH_BINARY) #提取轮廓img_canny = cv2.Canny(img_bin, 0, 1, 1)cv2.imshow(&quot;bin&quot;, img_bin)cv2.imshow(&quot;canny&quot;, img_canny)_, contours, hierarchy = cv2.findContours(img_canny, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)cv2.drawContours(img, contours, -1, (255, 0, 255), 1) #最右边的参数是线粗细cv2.imshow(&quot;result&quot;, img)# 将轮廓xy坐标写入path.txt中，格式为pathArr[]=[x1, y1, x2, y2, ...]with open(&quot;./path.txt&quot;, &#x27;w&#x27;) as f: f.write(&quot;pathArr[]=[&quot;) for i in contours: for j in i: f.write(str(j[0][0])) f.write(&quot;,&quot;) f.write(str(j[0][1])) f.write(&quot;,&quot;) f.write(&quot;];&quot;)cv2.waitKey(5000)cv2.destroyAllWindows() 这是生成的path.txt中的数据 方法二 如果熟悉svg，可以制作成svg矢量图（将自己需要绘制的图通过photoshop等工具描绘出它的轮廓，然后保存为svg图片即可），也可以提取path 123456789101112131415161718192021222324import numpy as npfrom svg.path import parse_pathpath = &quot;&quot;&quot;M53,368H41V354l1-4,1-4,1-2,1-2,1-1,1-2,1-1,2-2,2-2,1-1,2-1,1-1,2-1,2-1,2-1,3-1,4-1H87l4,1,3,1,2,1,2,1,3,2,2,2,2,2,2,2,2,3,1,2,1,2,1,3,1,4v11l-1,5-1,4-1,2-3,4-2,4-3,2-2,3-4,2-4,4-1,1-2,2-1,1H86v1l-2,2-2,2-2,1-1,1-2,1-1,1-2,1-2,2-2,1-2,1-2,2H96l4-1,1-3,2-2,1-6h9v8l-1,6-1,5-2,6-1,5h-8v-5H40v-8l8-6,6-4,4-3,4-4,3-3,3-3,3-2,3-3,5-4,5-4,3-3,1-3,1-2,1-1,1-2,1-2,1-3,1-4v-7l-1-4-1-2-1-3-3-3-4-3-4-1H67l-3,1-3,3-3,2-1,3-1,1-1,2-2,3v0l2-3,1-2,1-1,1-3,3-2,3-3,3-1H80l4,1,4,3,3,3,1,3,1,2,1,4v7l-1,4-1,3-1,2-1,2-1,1-1,2-1,3-3,3-5,4-5,4-3,3-3,2-3,3-3,3-4,4-4,3-6,4-8,6v8h60v5h8l1-5,2-6,1-5,1-6v-8h28l-3-5-1-6V363l1-4,2-5,1-3,1-3,1-4,2-3,2-3,2-2,3-2,3-2,4-3,4-2,6-1h16l8,3,7,5,5,7,5,9,1,6,2,8v31l-2,8-4,6-2,4-3,4-4,4-6,4-4,2-7,2H168l-9-3-8-7-5-5-4-7-1-6h16l6,10,6,5h13l8-7,3-4,1-5,1-4,1-4,1-12,1-1v-4l-1-9v-4l-2-5-1-3-3-7-3-5-6-4-4-1h-7l-5,2-5,6-3,5-2,4-1,8-1,9-1,2v11l1,1v8l1,4,2,4H113&quot;&quot;&quot;ps = parse_path(path)xy = []for p in ps: if p.length() == 0: continue xy.append([p.start.real, p.start.imag])with open(&quot;./path.txt&quot;, &#x27;w&#x27;) as f: f.write(&quot;pathArr[]=[&quot;) for i in xy: f.write(str(int(i[0]))) f.write(&quot;,&quot;) f.write(str(int(i[1]))) f.write(&quot;,&quot;) f.write(&quot;];&quot;) 两种方式各有优劣，可以根据自己熟悉程度选择 代码用法 完整代码已经放到CSDN托管平台GitCode，码云Gitee平台，需要使用的自行选择前往下载 GitCode Gitee 注：下面获取路径path用的是方法一，方法二跟一差不多 首先准备一张图片（图片轮廓可以一笔画出来，最好是黑白且比较明显的），比如： 修改 imgProcess/get_path.py 图片路径 打开 imgProcess/path.txt，将数据（会比较多）全部复制到 MyFT/js/main.js如下位置 初始化 123456//参数依次为：//第几个pathArr，这里是0//圆的个数（默认400），这里选择500//路径存储容量（默认11，内部计算后为2**11），这里不修改//放大倍数(默认1)，这里不放大initImg(0, 500, 11, 1); 绘图 调用 DrawImg函数，参数依次为 【x坐标(0)、y坐标(50)、第几张图(这里是0)、绘图速度(这里是1)】 注：这里的xy坐标只是大概位置 修改后打开 MyFT/index.html 即可查看效果 参考教程 编码珠玑-手把手教你编写傅里叶动画 (作者写的很好，其公众号编码珠玑含有这一篇文章)","categories":[{"name":"瞎折腾","slug":"瞎折腾","permalink":"https://blog.ajream.top/categories/%E7%9E%8E%E6%8A%98%E8%85%BE/"}],"tags":[{"name":"傅里叶","slug":"傅里叶","permalink":"https://blog.ajream.top/tags/%E5%82%85%E9%87%8C%E5%8F%B6/"}]},{"title":"数字信号处理期末口试","slug":"数字信号处理","date":"2021-12-06T13:11:32.000Z","updated":"2021-12-07T00:30:11.000Z","comments":true,"path":"posts/75756c71/","link":"","permalink":"https://blog.ajream.top/posts/75756c71/","excerpt":"","text":"第2章 模拟信号、离散时间信号和数字信号三者的特点是什么？ 数字信号和离散时间信号相同吗？ 查看答案 模拟信号在时间和幅值上都连续离散信号在时间上离散，幅值上连续（对连续信号采样得）数字信号在时间、幅值上均离散（对连续信号采样、量化得） 离散时间信号x(n)的n下标如何表示时间？ n=nT 由于T是固定的，不同x(nT)通过n即可区分，并且在DSP系统，x(nT)的存放是靠n来放置的，所以将T省略不写 DSP系统中最常见的三种基本运算是哪几种？ 加法、数乘、移位 DSP的延时操作是怎么实现的？ 查看答案 通过右移位操作实现 非时变系统的特点是什么？ 查看答案 系统的输出只取决于输入，不随输入时间不同而发生改变 系统一般因果性的概念是什么？ 查看答案 系统任意时刻的输出只取决于该时刻或该时刻之前的输入，而与该时刻之后的输入无关 判断方法：h(n)=0, n&lt;0 拓展：因果序列: x(n)=0, n&lt;0 系统一般稳定性的概念是什么？ 查看答案 有界输入对应有界输出 判断方式：单位取样响应 h(n) 绝对可和 线性非时变系统（LTI或LSI）输入和输出的时域关系是什么？ 查看答案 输出序列等于输入序列与系统单位取样响应的【卷积】 LTI系统的单位冲激响应h(n)如何表述它的因果性和稳定性？ 查看答案 因果性：h(n)=0, n&lt;0稳定性：h(n)绝对可和 非因果系统能实现吗？为什么？ 查看答案 不能，系统输出与未来的输入有关，在现实中无法实现 LTI系统卷积的物理意义是什么？ 查看答案 LTI系统对输入的一种通用数学处理方法，可以反应系统的结构特性 一个模拟低通带限信号进行采样时，理论上不失真的最低采样频率等于什么？ 采样频率fs &gt;= 2倍信号最高频率fm 模拟信号被采样以后，频域怎样变化？ 查看答案 频谱将以采样频率为周期进行无限周期延拓 实际中采样模拟信号用什么器件实现？它的输出是离散时间信号还是数字信号？ AD转换器，数字信号 一个模拟信号和它采样后序列的频率关系是什么？ 查看答案 呈线性关系，数字频率=模拟频率x采样间隔，即 ω=ΩT DAC能实现数字信号到模拟信号的理想重构吗？为什么？ 查看答案 不能，实际中的DAC是一个非理想的低通滤波器，恢复的模拟信号是近似的 理论上离散时间信号重构模拟信号的最佳内插函数是哪一种函数？ Sa函数，Sa(x)=sinxxSa(x)=\\frac{sinx}{x}Sa(x)=xsinx​ 第3章 LTI系统对正弦序列的响应有什么特点？ 查看答案 是与输入序列同频率的正弦序列（即系统不会改变输入序列的频率），但输出序列的幅度由幅频响应改变，输出序列的相位由相频响应改变 LTI系统幅频响应的物理意义是什么？ 查看答案 幅频响应刻画了系统对输入序列幅度的影响，即对幅度改变的倍数 LTI系统相频响应的物理意义是什么？ 查看答案 刻画了系统对输入序列的相位影响，表示对相位的增加或减少 序列傅里叶变换DTFT的定义式什么？ X(ejω)=∑n=−∞+∞x(n)e−jωnX(e^{j\\omega})=\\sum_{n=-\\infty}^{+\\infty}x(n)e^{-j\\omega n} X(ejω)=n=−∞∑+∞​x(n)e−jωn 序列傅里叶变换DTFT是信号的频谱，频谱的物理概念是什么？ 查看答案 信号的在各频率点上的能量分布情况 序列频谱（DTFT）是周期函数吗？周期等于多少？ 是， 2π2\\pi2π DTFT频谱在一个周期[0,2π][0,2\\pi][0,2π]内的负频率范围是什么？ [π, 2π\\pi, ~ 2\\piπ, 2π] 为什么要对信号进行傅里叶变换？它比时域分析好在哪里？ 查看答案 一是得到信号的频谱，物理意义更清楚，二是简化计算 LTI系统的频域描述关系式是什么？ 查看答案 相乘 LTI系统的频率响应函数和单位冲激响应的关系是什么？ H(ejw)=∑n=−∞+∞h(n)e−jwnH(e^{jw})=\\sum_{n=-\\infty}^{+\\infty}h(n)e^{-jwn} H(ejw)=n=−∞∑+∞​h(n)e−jwn 系统幅频响应的物理意义是什么？ 查看答案 对不同频率正弦信号幅值大小的改变 系统相频响应的物理意义是什么？ 查看答案 对不同频率正弦信号初相位的改变 一个序列的Z变换与DTFT的关系是什么？ 在Z平面单位圆上的Z变换即DTFT 与傅里叶变换相比，Z变换的优点是什么？ 查看答案 Z变换的【存在条件】比傅里叶变换更宽松，分析的区域得到扩大 Z变换收敛域的概念是什么？ 查看答案 对于任意给定的序列，使z变换收敛的【z值的集合】称为收敛域 一个稳定因果系统的系统函数的收敛域有什么特点？ 包含单位圆 一个因果有限长序列的z变换收敛域存在吗？有什么特点？ 查看答案 存在，收敛域不包含零点，但包含无穷远点，即 0 &lt; z &lt;=∞∞∞ 系统函数H(z)和单位取样响应是什么关系？ 查看答案 H(z)是单位取样响应的Z变换，即 H(z)=∑n=−∞∞h(n)e−zH(z)=\\sum_{n=-\\infty}^{\\infty} h(n)e^{-z}H(z)=∑n=−∞∞​h(n)e−z 系统函数H(z)和系统的频率响应函数的关系是什么？ 系统函数 H(z)在单位圆上的情况就是频率响应函数H(ejωe^{j\\omega}ejω) 系统函数的零点和极点对幅频响应的影响是什么？ 查看答案 极点位置影响幅频响应的【峰值位置】及【尖锐程度】，极点不能位于单位圆上；零点位置影响幅频响应【谷点位置】及形状;在原点处的零点和极点不影响系统的幅频特性，只影响【相频特性】 ​ 系统函数的极点是否可以在Z平面的单位圆上？为什么？ 不能，因为会使得系统不稳定 什么是FIR系统？它的系统函数有什么特点？ 查看答案 h(n)为有限长度序列的系统称为有限冲激响应系统，即【FIR系统】系统函数只有零点，也称【全零点系统】 系统的输出只与输入有关，也叫【滑动平均（MA）系统】 什么是IIR系统？它的系统函数有什么特点？ 查看答案 h(n)为无限长序列的系统称为无限冲激响应系统，即【IIR系统】系统函数是一个有理分式，既有零点又有极点，也称作【零极点系统】 系统的输出只与当前的输入及过去的输出有关，也叫【自回归(AR) 系统】 常系数差分方程表示系统的优点是什么？ 查看答案 外特性描述法，描述输入输出之间的关系，而无关系统内部状态的变量 系统的网络结构表示系统的意义是什么？ 查看答案 一种运算结构，反映系统具体的实现方式 第4章 DFS适用于哪一类序列的频谱计算？ 周期性无限长序列 DFT适用于哪一类序列的频谱计算？ 非周期性的有限长序列 DFT和DTFT的表示的频域信息相同吗？它们有什么区别？ 基本相同，DFT相当于DTFT频域频谱的离散化表达，本质并无区别 对一个序列进行DFT计算，序列的频谱DTFT如何变化？ 离散化 工程实际中对序列进行频谱分析采用的是DTFT还是DFT？为什么？ 查看答案 DFT，DFT变换后频域是离散化的，便于计算机计算和存储，并且DFT拥有快速算法FFT 一个N点有限长序列的DTFT、DFT和Z变换都存在吗？它们的关系是什么？ 查看答案 都存在N点DFT是在DTFT的区间[0,2π][0,2\\pi][0,2π]进行N点等间隔采样是在Z变换的单位圆上进行N点等间隔采样 为什么DFT可以用在工程实际中？ 查看答案 DFT变换后频域是离散化的，便于计算机计算和存储，并且DFT拥有快速算法FFT DFT比DTFT好在哪里？ 查看答案 (正反变换的数学运算非常相似，硬件软件上实现都比较便捷；计算简便) 第5章 FFT名称的含义是什么？它是一种新的傅里叶变换吗？ 快速傅里叶变换，是一种更方便快捷，计算次数更少的进行傅里叶变换的算法； 不是新的傅里叶变换 发明FFT算法的目的是什么？它有什么好处？ 查看答案 简化傅里叶变换，提升运算速度，节约设备成本 对一个N点序列，直接计算DFT的复数乘法计算量是多大？FFT的计算量是多大？ 查看答案 DFT: N2N^2N2FFT: N2log2N\\frac{N}{2}log_2 N2N​log2​N 一个N点序列的N点FFT和DFT的结果相等吗？ 相等 FFT算法可以减少计算量的最主要思路是什么？ 查看答案 利用W因子的周期性、对称性和正交性等性质，同时将一个N点DFT的计算划分成 N/2N/2N/2个 2点序列 按时间抽取基2-FFT算法的抽取规律是什么？ 将N点序列按时间下标的奇偶分为两个N/2点序列，每一个N/2点序列按照同样的划分原则，再次划分，以此类推最终将原序列划分为 N/2 个 2 点序列 ​ FFT算法中码位倒置规律和同址运算概念是什么？ 查看答案 码位倒置：序列在进行FFT运算前，需要将序列重新排序，使之符合FFT要求，新序列是原序列二进制码位倒置顺序同址运算：蝶形运算符的两个输入变量在运算后会产生两个输出变量，而在之后的运算中输入变量不再需要，因此可以两个输出变量存储在原输入变量的存储单元 第6章 数字滤波器分为哪两种类型？ 经典滤波器、现代滤波器 数字滤波器的通带指标含义是什么？阻带指标含义是什么？ 通带指标：在通带内要求误差在正负δp\\delta pδp内，系统幅频响应接近1 阻带指标：在阻带内，要求误差不大于δs\\delta sδs，系统幅频响应接近0 3分贝截止频率的概念是什么？ 查看答案 使信号通过滤波器后幅度降低到原来的 22\\frac{\\sqrt{2}}{2}22​​时的频率，即ωc\\omega_cωc​ ，此时αp=3dB\\alpha_p=3dBαp​=3dB，故称ωc\\omega_cωc​为3dB截止频率 理想滤波器能实现吗？为什么？ 查看答案 不能，因为滤波器的单位冲激响应是非因果且无限长的 巴特沃斯滤波器的特点是什么？ 通带最平坦（通带内幅频响应曲线最大限度平坦，没有纹波，而在阻带内逐渐下降为0） 通带最平坦滤波器是哪一种滤波器？ 巴特沃斯滤波器 冲激响应不变设计法的缺点是什么？ 会产生频率混叠现象，适合低通、带通，不适合高通、带阻 双线性变换设计法可以设计高通滤波器吗？为什么？ 查看答案 可以，频域直接映射，频率一一对应，可设计各种功能的滤波器 第7章 FIR滤波器实现第一类线性相位特性的条件是什么？它能实现吗？ 条件：h(n)=h(N−1−n)h(n)=h(N-1-n)h(n)=h(N−1−n) 因为h(n)是因果序列且有限长(绝对可和，即是稳定的)，可以实现 系统具有线性相位特性处理信号的优点是什么？ 查看答案 数字信号的包络不会失真 FIR滤波器窗函数设计法的阻带指标由什么因素决定？ 查看答案 主要是第一旁瓣（由窗函数频谱的主瓣和副瓣之比决定，而它们的相对值主要取决于窗函数的形状） 吉布斯效应是什么？ 查看答案 理想滤波器Hd(ejω)H_d(e^{j\\omega})Hd​(ejω) 变换到时域hd(n)h_d(n)hd​(n)后被截断，导致滤波器通带和阻带内出现波动，使阻带衰减性变差，引入过渡带等，也叫“截断效应”。 窗函数设计法中，增加FIR滤波器长度N可以改进阻带和通带技术指标吗？为什么？ 查看答案 不能，增加截取长度N只能减小过渡带宽度，不能减小主瓣与旁瓣相对值（由窗函数频谱的主瓣与副瓣比值决定） N点长度的线性相位FIR滤波器的处理时延等于多少？ τ=N−12\\tau=\\frac{N-1}{2}τ=2N−1​ FIR滤波器的频率取样设计法的特点是什么？ 查看答案 直接从频率域进行设计，比较直观，适合于设计具有任意幅度特性的滤波器 如何改进频率取样设计法的阻带技术指标？ 查看答案 频域取样时，在通带和阻带交界处人为加若干过度点","categories":[{"name":"课程考试","slug":"课程考试","permalink":"https://blog.ajream.top/categories/%E8%AF%BE%E7%A8%8B%E8%80%83%E8%AF%95/"}],"tags":[{"name":"数字信号处理","slug":"数字信号处理","permalink":"https://blog.ajream.top/tags/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"}]},{"title":"链表及其操作","slug":"链表","date":"2021-11-17T08:05:53.000Z","updated":"2024-03-31T14:49:40.667Z","comments":true,"path":"posts/5ec1b976/","link":"","permalink":"https://blog.ajream.top/posts/5ec1b976/","excerpt":"","text":"链表 一个双向链表（链表都是由一个个节点构成的），包含2个指针（实际就是2个节点的地址）：一个指向前一个节点，一个指向后一个节点 1234567struct rt_list_node &#123; struct rt_list_node *next; /* 指向后一个节点 */ struct rt_list_node *prev; /* 指向前一个节点 */&#125;;typedef struct rt_list_node rt_list_t; 链表操作 初始化 初始化一个链表，首先创建头节点l： 12345rt_inline void rt_list_init(rt_list_t *l)&#123; l-&gt;next = l-&gt;prev = l;&#125; 从代码可以看出，节点l的next和prev指针均指向自己，如下 插入节点 在节点l后插入节点n 12345678rt_inline void rt_list_insert_after(rt_list_t *l, rt_list_t *n)&#123; l-&gt;next-&gt;prev = n; //1 n-&gt;next = l-&gt;next; //2 l-&gt;next = n; //3 n-&gt;prev = l; //4&#125; 分析： 在初始化时 l-&gt;next=l, 所以l-&gt;next-&gt;prev就是l-prev，即l-&gt;prev指向n 初始化时 l-&gt;next=l, 所以n-&gt;next指向l l-&gt;next指向n n-&gt;prev指向l 两个节点可能不是很清晰，所以再插入一个节点n2，结果如下图 当然，节点不仅可以在最后插入，也可以在中间插入，如下 把一个节点n插入到2个节点l和n1之间，就是要把节点n1的prev指针指向n，n的next指针指向节点n1，然后把l的next指针指向n，n的prev指针指向l； 修改时要注意顺序，因为根据链表的特性，查找节点只能从前面往后遍历，因此必须先修改n和n1之间的指针，再修改l和n之间的指针。 整理一下，得 在链表表头前面插入一个节点 12345678rt_inline void rt_list_insert_before(rt_list_t *l, rt_list_t *n)&#123; l-&gt;prev-&gt;next = n; //1 n-&gt;prev = l-&gt;prev; //2 l-&gt;prev = n; //3 n-&gt;next = l; //4&#125; 删除节点 从双向链表删除一个节点 12345678rt_inline void rt_list_remove(rt_list_t *n)&#123; n-&gt;next-&gt;prev = n-&gt;prev; //1 n-&gt;prev-&gt;next = n-&gt;next; //2 n-&gt;next = n-&gt;prev = n; //3&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://blog.ajream.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"链表","slug":"链表","permalink":"https://blog.ajream.top/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"自动启动Gitee Pages服务","slug":"Hexo/自动运行Gitee_Pages服务","date":"2021-10-20T11:44:44.000Z","updated":"2024-03-31T14:49:40.667Z","comments":true,"path":"posts/728bba4e/","link":"","permalink":"https://blog.ajream.top/posts/728bba4e/","excerpt":"","text":"说在前面 注意现在是2023-09-14，本文章写于2021年，使用butterfly作为博客主题的时候，部分书写可能有些错误，请注意结合自己的实际情况，不过该文章介绍的方法与主题无关。 还没有使用过Github Actions的请先看完这篇文章 还没有使用Github Actions自动部署Hexo博客的也请先看完上面说的这篇文章。 如果你已经对Gihtub Actions有足够了解，请继续往下看。 步骤 在自己的需要启动GitHub Actions的仓库中新建一个 autodeploy.yml文件（已有的可以跳过这一步），文件名可以自定义，我的如下： 在该文件添加如下代码，部分地方需要自己修改，具体看Github Actions自动部署 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869name: 自动部署# 当有改动push到master分支时，启动Actionon: push: branches: - master #更改为自己仓库的分支 release: types: - publishedjobs: deploy: runs-on: ubuntu-latest steps: - name: 检查分支 uses: actions/checkout@v2 with: ref: master #2020年10月后github新建仓库默认分支改为main，注意更改 - name: 安装 Node uses: actions/setup-node@v1 with: node-version: &quot;12.x&quot; - name: 安装 Hexo run: | export TZ=&#x27;Asia/Shanghai&#x27; npm install hexo-cli -g - name: 缓存 Hexo uses: actions/cache@v1 id: cache with: path: node_modules key: $&#123;&#123;runner.OS&#125;&#125;-$&#123;&#123;hashFiles(&#x27;**/package-lock.json&#x27;)&#125;&#125; - name: 安装依赖 if: steps.cache.outputs.cache-hit != &#x27;true&#x27; run: | npm install --save - name: 生成静态文件 run: | hexo clean hexo generate - name: 使用gulp压缩html-css-js run: | gulp - name: 部署 run: | git config --global user.name &quot;自己Github的username&quot; git config --global user.email &quot;自己的邮箱&quot; git clone https://github.com/自己的username/username.github.io.git .deploy_git # 此处务必用HTTPS链接。SSH链接可能有权限报错的隐患 # =====注意.deploy_git前面有个空格===== # 这行指令的目的是clone博客静态文件仓库，防止Hexo推送时覆盖整个静态文件仓库，而是只推送有更改的文件 hexo deploy - name: 启动gitee pages uses: yanglbme/gitee-pages-action@main with: # 注意替换为你的 Gitee 用户名 gitee-username: aJream # 注意在 Settings-&gt;Secrets 配置 GITEE_PASSWORD gitee-password: $&#123;&#123; secrets.GITEE_PASSWORD &#125;&#125; # 注意替换为你的 Gitee 仓库，仓库名严格区分大小写，请准确填写，否则会出错 gitee-repo: ajream # 要部署的分支，默认是 master，若是其他分支，则需要指定（指定的分支必须存在） branch: master 其中最后一部分的代码（如下图）就是要启动Gitee Pages服务，其中用到的Actions来自yanglbme，具体请到yanglbme的仓库查看 注意：secrets.GITEE_PASSWORD 是自己在GitHub Settings配置的，值为自己的gitee登录时的密码 完成 到此就完成了，自己push后就可以自动运行Actions脚本，运行完成后如果没有问题会在gitee平台上收到（登录）通知，配置了邮箱的可以在邮箱收到信息，关注了Gitee官方公众号并且绑定了自己的gitee账户也可以收到消息提醒，如下是微信公众号的提醒：","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://blog.ajream.top/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://blog.ajream.top/tags/Hexo/"},{"name":"Gitee","slug":"Gitee","permalink":"https://blog.ajream.top/tags/Gitee/"}]},{"title":"Github搜索技巧","slug":"Github搜索技巧","date":"2021-10-19T12:51:26.000Z","updated":"2021-10-22T05:18:05.000Z","comments":true,"path":"posts/4b9291b6/","link":"","permalink":"https://blog.ajream.top/posts/4b9291b6/","excerpt":"","text":"该文章教你如何利用Github搜索框优雅地搜索到自己需要的、中意的项目！ Github热门项目 GitHub Trend页面总结了每天/每周/每月周期的热门 Repositories 和 Developers，你可以看到在某个周期处于热门状态的开发项目和开发者。 GitHub Topic展示了最新和最流行的讨论主题，在这里你不仅能够看到开发项目，还能看到更多非开发技术的讨论主题，如 3D Model、Android、Algorithm等。 搜索技巧 按主题搜索 12345topic:stm32topics:5 具有5个主题的仓库topics:&gt;5 超过5个主题的仓库 Awesome+关键字 通过Awesome + 关键字的方式进行搜索，可以找到不少的优秀资源。比如以上的搜索： 1Awesome stm32 （可以用小写） 通过关键字的位置进行搜索 （下面如果是大写字母的，可以用小写） 123456789stm32 in:name 表示搜索项目名中含有“stm32”关键字的项目stm32 in:readme 表示搜索readme文件中含有“stm32”关键字的项目stm32 in:description 表示搜索项目描述中含有“stm32”关键字的项目stm32 in:username 搜索用户名含有“stm32”的用户发布的项目stm32 in:ORGNAME 表示在组织或机构名中搜索 “stm32” 关键字 在用户或组织的仓库内搜索可以用下面语句： 123org:github 搜索来自GitHub组织的项目user:jack 搜索来自用户jack的项目 设置搜索条件 12345stars:&gt;500 stm32 查找 stars 数超过500的stm32项目forks:100..500 stm32 查找 forks 数在100~500之间的stm32项目size:&gt;=5000 stm32 查找 项目大小超过5000KB的stm32项目 搜索开发者 12345language:C++ location:china 限定开发者为国内开发者，使用语言为C++followers:&gt;100 关注人数超过100jack in:fullname 匹配用户实名名为jack的开发者 按仓库创建或上次更新时间搜索 用于搜索还在更新和维护的项目 123stm32 created:&lt;2021-01-01 在2021-01-01之前创建的项目pushed:&gt;2021-02-02 在2021-02-02后还在pushed的项目","categories":[{"name":"瞎折腾","slug":"瞎折腾","permalink":"https://blog.ajream.top/categories/%E7%9E%8E%E6%8A%98%E8%85%BE/"}],"tags":[{"name":"Github","slug":"Github","permalink":"https://blog.ajream.top/tags/Github/"},{"name":"技巧","slug":"技巧","permalink":"https://blog.ajream.top/tags/%E6%8A%80%E5%B7%A7/"}]},{"title":"疫情填报自动化","slug":"疫情填报自动化","date":"2021-09-30T04:51:26.000Z","updated":"2022-07-30T06:26:15.000Z","comments":true,"path":"posts/a2b5a2ea/","link":"","permalink":"https://blog.ajream.top/posts/a2b5a2ea/","excerpt":"","text":"问题已解决，可以继续使用了，最新代码已经提交到Gitee，腾讯云函数好像改变收费方式了，本人已转移到GitHub Actions阵地👀 最近已经用不了了，好好每天设定好闹钟吧，想学习的还可以看看。。。😥 本教程仅限于学习使用，希望看到这个教程的同学严格遵守学校要求，认真对待，出现任何问题后果自行承担！ 前言 自从前几天有一次忘记疫情填报后，就想着能不能通过程序自动化来进行填写，网上找了找后终于找到一份详细教程，幸运的是教程作者还是本校学长，这里感谢Pinming学长，代码已经写好了，还好之前也学过一点python，能看懂代码，因此很快就部署成功了。 学长部署时用的是阿里云的，由于我之前已经注册过腾讯云，于是改用腾讯云来进行部署。 将代码下载到本地 点击去下载代码，可以选择clone或者下载压缩包的方式 将代码下载到本地后，用开发工具（推荐vscode，pycharm也行），修改index.py文件中内容： 翱翔门户登录信息： 修改用户名和密码 修改SCKEY 邮箱（可选，如果不想把信息发到自己邮箱就不需要配置，如果想的话根据代码注释来配置） 在本地运行测试 color:green SCKEY获取步骤 进入server酱官网，使用GitHub账号登录。开始绑定微信。就是使用微信扫描之后（会叫你关注一个公众号），然后在这个界面点击&lt;检查结果并确认绑定&gt;绑定成功即可获取SendKey（在发送消息页面）。把这个SendKey填入SCKEY即可 部署到腾讯云 为了能让代码定时运行，我们可以将代码部署到腾讯云，通过云服务来代替我们手动执行，当然你也可以配置为在本地电脑配置定时执行，但这样你的电脑就别想关机了。什么，你用树莓派，那你当我没说 创建云函数 首先登录腾讯云（微信扫码通过即可），进入控制台，选择云产品-&gt;云函数 或者在搜索框输入 “云函数”，在展开的页面选择控制台入口的 “云函数” 新建云函数 依次选择： 上传代码 上传成功后进入 index.py文件，将最后一行代码注释掉，因为云函数执行时是通过调用 入口函数main_handler来运行的 进行测试 先部署，后测试 等待测试结果，在执行日志看到如下结果表示部署成功 设定定时触发 定时触发即定时执行程序 选择左边面板的 触发管理-&gt;创建触发器 触发方式选择定时触发，周期选择自定义触发周期 color:green Cron表达式 如何自定义触发周期，实际是通过配置cron表达式来定义的，其语法可以看官方文档Cron表达式语法Cron 表达式有七个必需字段（从左到右共1-7位），按空格分隔。格式如：1* * * * * * *第一位第二位第三位第四位第五位第六位第七位秒(0-59的整数)分钟(0-59的整数)小时(0-23的整数)日(1-31的整数,需要考虑月的天数)月(1-12的整数或 JAN,FEB,MAR,APR,……)星期( 0-6的整数或SUN,MON,TUE,……其中0指星期日，1指星期一，以此类推)年( 1970-2099的整数)每一位可以添加通配符, - * /：通配符含义,（逗号）代表取用逗号隔开的字符的并集。例如：在第三位“小时”字段中 1,2,3表示1点、2点和3点-（破折号）包含指定范围的所有值。例如：在第四位“日”字段中，1-15包含指定月份的1号到15号* （星号）表示所有值。在第三位“小时”字段中，* 表示每个小时/ （正斜杠）指定增量。在第二位“分钟”字段中，输入1/10以表示从第一分钟开始的每隔十分钟就执行一次；*/10则表示每隔10分钟执行一次（没有指定第一次什么时候开始）例子：表达式相关含义*/5 * * * * * *表示每5秒触发一次0 15 10 1 * * *表示在每月的1日的上午10:15触发0 15 10 * * MON-FRI *表示在周一到周五每天上午10:15触发0 0 10,14,16 * * * *表示在每天上午10点，下午2点，4点触发0 */30 9-17 * * * *表示在每天上午9点到下午5点每半小时触发0 0 12 * * WED *表示在每个星期三中午12点触发 例如我的配置 到此完成了云函数配置 使用Github Actions 如果你没有腾讯云账户，也不想用腾讯云，这里提供另外一个方法，使用Github提供的Actions来实现; 首先你得有一个Github账号 如果没听说过GitHub就别想用自动化了，听说过但没有账号的强烈建议注册一个，为什么，百度去，说真的Github\"真香\" 然后在自己的GitHub账号下新建一个仓库（不会的去百度） 在本地下载的代码文件夹中，创建 .github文件夹，再在这个文件夹创建文件夹workflows，再在workflows下创建文件main.yml(这个文件名随意)，然后在 main.yml 添加如下代码： 123456789101112131415161718192021222324name: 自动运行仓库的index脚本on: schedule: - cron: &#x27;17 22 * * *&#x27;jobs: build: runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 - name: Set up Python 3.9 uses: actions/setup-python@v2 with: python-version: 3.9 - name: Install dependencies run: | python -m pip install --upgrade pip # pip install requests==2.24.0 beautifulsoup4==4.9.1 pytz if [ -f requirements.txt ]; then pip install -r requirements.txt; fi - name: Test run: | python index.py 如果不想自己设定定时执行时间（这里设定每天早上6:17分执行），就直接将全部文件 push到刚新建的仓库中即可 如果想自定义执行时间，则需修改第5行代码 cron 表达式的值（注意这个与在腾讯云部署时讲的不同，前面讲的那个是7位的，这个是5位） 12345name: 自动运行仓库的index脚本on: schedule: - cron: &#x27;17 22 * * *&#x27; # 该时间为UTC时间，22:17PM + 8:00 = 6:17AM cron表达式的5位从左到右分别表示 分 时 日 月 星期 ，用法与7位那个差不多，四个通配符【- , * /】也都可以用，用法一样 还不懂的可以去这个网站，自动生成cron表达式 注意这个时间是UTC标准时间，将北京时间换算成UTC时间要减去8小时，比如想要在北京时间9:12执行，则相应UTC时间为1:12这个定时时间并不是代码执行的时间，只是排队时间，因为用Github Actions的人太多了，当你定时时间到了后会进行排队等待执行（时间为十几分钟到一个小时甚至更久一些），因此需要自己估计好执行时间，不过疫情填报设定为每天早上执行一次不就行了😅？ 代码中的bug修复 有时程序在运行时会出错，如下 把以下代码注释掉 还有第64行最后面的 + notice 去掉 在我仓库中下载的可以忽略这个bug，因为我已经修改好了","categories":[{"name":"瞎折腾","slug":"瞎折腾","permalink":"https://blog.ajream.top/categories/%E7%9E%8E%E6%8A%98%E8%85%BE/"}],"tags":[{"name":"Github","slug":"Github","permalink":"https://blog.ajream.top/tags/Github/"},{"name":"自动化","slug":"自动化","permalink":"https://blog.ajream.top/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"},{"name":"云函数","slug":"云函数","permalink":"https://blog.ajream.top/tags/%E4%BA%91%E5%87%BD%E6%95%B0/"}]},{"title":"使用Gulp压缩代码","slug":"Hexo/使用Gulp压缩代码","date":"2021-09-20T03:02:35.000Z","updated":"2024-03-31T14:49:40.667Z","comments":true,"path":"posts/21a21930/","link":"","permalink":"https://blog.ajream.top/posts/21a21930/","excerpt":"","text":"注意现在是2023-09-14，本文章写于2021年，使用butterfly作为博客主题的时候，部分书写可能有些错误，请注意结合自己的实际情况，不过该文章介绍的方法与主题无关。 简介 使用gulp 能够帮助我们压缩静态资源，配合各类下属插件，能够压缩包括 css、js、html甚至是图片，这样可以让我们访问网站时加载这些文件的时间减少 用法 想看更加具体的请移步Akilar-Hexo博客静态资源加速 安装 Gulp 插件：在博客根目录 [Blogroot] 打开终端，输入： 12npm install --global gulp-cli #全局安装gulp指令集npm install gulp --save #安装gulp插件 安装各个下属插件以实现对各类静态资源的压缩。 12345678910# 压缩htmlnpm install gulp-htmlclean --save-devnpm install gulp-html-minifier-terser --save-dev# 用gulp-html-minifier-terser可以压缩HTML中的ES6语法# 压缩cssnpm install gulp-clean-css --save-dev# 压缩js，本站用gulp-tersernpm install gulp-terser --save-dev 在博客根目录 [Blogroot] 下新建 gulpfile.js, 打开 [Blogroot]\\gulpfile.js, 输入以下内容： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//用到的各个插件var gulp = require(&#x27;gulp&#x27;);var cleanCSS = require(&#x27;gulp-clean-css&#x27;);var htmlmin = require(&#x27;gulp-html-minifier-terser&#x27;);var htmlclean = require(&#x27;gulp-htmlclean&#x27;);// gulp-testervar terser = require(&#x27;gulp-terser&#x27;);// 压缩jsgulp.task(&#x27;compress&#x27;, () =&gt; gulp.src([&#x27;./public/**/*.js&#x27;, &#x27;!./public/**/*.min.js&#x27;]) .pipe(terser()) .pipe(gulp.dest(&#x27;./public&#x27;)))//压缩cssgulp.task(&#x27;minify-css&#x27;, () =&gt; &#123; return gulp.src([&#x27;./public/**/*.css&#x27;]) .pipe(cleanCSS(&#123; compatibility: &#x27;ie11&#x27; &#125;)) .pipe(gulp.dest(&#x27;./public&#x27;));&#125;);//压缩htmlgulp.task(&#x27;minify-html&#x27;, () =&gt; &#123; return gulp.src(&#x27;./public/**/*.html&#x27;) .pipe(htmlclean()) .pipe(htmlmin(&#123; removeComments: true, //清除html注释 collapseWhitespace: true, //压缩html collapseBooleanAttributes: true, //省略布尔属性的值，例如：&lt;input checked=&quot;true&quot;/&gt; ==&gt; &lt;input /&gt; removeEmptyAttributes: true, //删除所有空格作属性值，例如：&lt;input id=&quot;&quot; /&gt; ==&gt; &lt;input /&gt; removeScriptTypeAttributes: true, //删除&lt;script&gt;的type=&quot;text/javascript&quot; removeStyleLinkTypeAttributes: true, //删除&lt;style&gt;和&lt;link&gt;的 type=&quot;text/css&quot; minifyJS: true, //压缩页面 JS minifyCSS: true, //压缩页面 CSS minifyURLs: true //压缩页面URL &#125;)) .pipe(gulp.dest(&#x27;./public&#x27;))&#125;);// 运行gulp命令时依次执行以下任务gulp.task(&#x27;default&#x27;, gulp.parallel( &#x27;compress&#x27;, &#x27;minify-css&#x27;, &#x27;minify-html&#x27;)) 在每次运行完 hexo generate 生成静态页面后，运行 gulp 对其进行压缩。指令流程如下： 1234hexo cleanhexo generategulphexo server 或 hexo deploy","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://blog.ajream.top/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://blog.ajream.top/tags/Hexo/"}]},{"title":"背景整体修改","slug":"Hexo/背景样式修改","date":"2021-09-19T15:48:35.000Z","updated":"2024-03-31T14:49:40.667Z","comments":true,"path":"posts/be66f85d/","link":"","permalink":"https://blog.ajream.top/posts/be66f85d/","excerpt":"","text":"注意现在是2023-09-14，本文章写于2021年，使用butterfly作为博客主题的时候，部分书写可能有些错误，请注意结合自己的实际情况。 整体修改 图片背景渐变背景背景使用图片，添加css 123456789/*背景，使用图片*/#web_bg &#123; /* background: linear-gradient(90deg, rgba(247, 149, 51, .1), rgba(243, 112, 85, .1) 15%, rgba(239, 78, 123, .1) 30%, rgba(161, 102, 171, .1) 44%, rgba(80, 115, 184, .1) 58%, rgba(16, 152, 173, .1) 72%, rgba(7, 179, 155, .1) 86%, rgba(109, 186, 130, .1)) */ background: url(/img/web_bg.png)!important; /*重新定义background会导致原有定位属性失效，所以也需要再声明一次加权的定位属性*/ background-position: center !important; background-size: cover !important; background-repeat: no-repeat !important;&#125;如果背景不使用图片，使用渐变，则修改为： 1234567891011#recent-posts&gt;.recent-post-item,.layout_page&gt;div:first-child:not(.recent-posts),.layout_post&gt;#page,.layout_post&gt;#post,.read-mode .layout_post&gt;#post &#123; background: var(--light_bg_color)&#125;#aside-content .card-widget &#123; background: var(--light_bg_color)&#125;#web_bg &#123; background: linear-gradient(90deg,rgba(247,149,51,.1),rgba(243,112,85,.1) 15%,rgba(239,78,123,.1) 30%,rgba(161,102,171,.1) 44%,rgba(80,115,184,.1) 58%,rgba(16,152,173,.1) 72%,rgba(7,179,155,.1) 86%,rgba(109,186,130,.1))&#125; 文章透明度修改 1234567/*文章页透明度*/#content-inner &#123; --light_bg_color: rgb(255,255,255 ,90%); /*侧边栏页面*/ --dark_bg_color: rgba(18, 18, 18, 0.8); --light_page_color: rgb(255,255,255 ,90%); /*文章页面*/ --dark_page_color: rgba(18, 18, 18, 0.8);&#125; 顶部图 123456789/*顶部图透明*/#page-header&#123; background: transparent!important;&#125;/*顶部图遮罩*/#page-header.post-bg:before &#123; background-color: rgba(0, 0, 0, 0.4)!important;&#125; 页脚透明 12345678910111213141516171819202122/*页脚透明*/#footer&#123; background: transparent !important;&#125;/* 页脚遮罩透明 */#footer::before &#123; background: rgba(255, 255, 255, 0);&#125;/*夜间模式伪类遮罩层透明*/[data-theme=&quot;dark&quot;] #footer::before&#123; background: transparent!important; &#125;[data-theme=&quot;dark&quot;] #page-header::before&#123; background: transparent!important; /* color: #d4ddeb, #79b8ff, #79b8ff; */ &#125; 加载动画 Akilar-糖果屋 步骤 修改 [Blogroot]\\themes\\butterfly\\layout\\includes\\loading\\loading.pug，直接复制以下代码替换所有原代码。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374if theme.preloader.enable #loading-box .loading-left-bg .loading-right-bg case theme.preloader.load_style when &#x27;wizard&#x27; .wizard-scene .wizard-objects .wizard-square .wizard-circle .wizard-triangle .wizard .wizard-body .wizard-right-arm .wizard-right-hand .wizard-left-arm .wizard-left-hand .wizard-head .wizard-beard .wizard-face .wizard-adds .wizard-hat .wizard-hat-of-the-hat .wizard-four-point-star.--first .wizard-four-point-star.--second .wizard-four-point-star.--third when &#x27;ironheart&#x27; .iron-container.iron-circle .iron-box1.iron-circle.iron-center .iron-box2.iron-circle.iron-center .iron-box3.iron-circle.iron-center .iron-box4.iron-circle.iron-center .iron-box5.iron-circle.iron-center .iron-box6.iron-circle .iron-coil(style=&#x27;--i: 0&#x27;) .iron-coil(style=&#x27;--i: 1&#x27;) .iron-coil(style=&#x27;--i: 2&#x27;) .iron-coil(style=&#x27;--i: 3&#x27;) .iron-coil(style=&#x27;--i: 4&#x27;) .iron-coil(style=&#x27;--i: 5&#x27;) .iron-coil(style=&#x27;--i: 6&#x27;) .iron-coil(style=&#x27;--i: 7&#x27;) when &#x27;scarecrow&#x27; .scarecrow .scarecrow__hat .scarecrow__ribbon .scarecrow__head .scarecrow__eye .scarecrow__eye .scarecrow__mouth .scarecrow__pipe .scarecrow__body .scarecrow__glove.scarecrow__glove--l .scarecrow__sleeve.scarecrow__sleeve--l .scarecrow__bow .scarecrow__shirt .scarecrow__coat .scarecrow__waistcoat .scarecrow__sleeve.scarecrow__sleeve--r .scarecrow__glove.scarecrow__glove--r .scarecrow__coattails .scarecrow__pants .scarecrow__arms .scarecrow__leg when &#x27;image&#x27; - var loadimage = theme.preloader.load_image ? theme.preloader.load_image : theme.error_img.post_page img.load-image(src=url_for(loadimage) alt=&#x27;&#x27;) default .spinner-box .configure-border-1 .configure-core .configure-border-2 .configure-core .loading-word= _p(&#x27;loading&#x27;)修改 [Blogroot]\\themes\\butterfly\\source\\css\\_layout\\loading.styl，复制以下代码替换全部内容。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980981982983984985986987988989990991992993994995996997998999100010011002100310041005100610071008100910101011101210131014101510161017101810191020102110221023102410251026102710281029103010311032103310341035103610371038103910401041104210431044104510461047104810491050105110521053105410551056105710581059106010611062106310641065106610671068106910701071107210731074107510761077107810791080108110821083108410851086108710881089109010911092109310941095109610971098109911001101110211031104110511061107110811091110111111121113111411151116111711181119112011211122112311241125112611271128112911301131113211331134113511361137113811391140114111421143114411451146114711481149115011511152115311541155115611571158115911601161116211631164116511661167116811691170117111721173117411751176117711781179118011811182118311841185118611871188118911901191119211931194119511961197119811991200120112021203120412051206120712081209121012111212121312141215121612171218121912201221122212231224122512261227122812291230123112321233123412351236123712381239124012411242124312441245124612471248124912501251125212531254125512561257125812591260126112621263126412651266126712681269127012711272127312741275127612771278127912801281128212831284128512861287128812891290129112921293129412951296129712981299130013011302130313041305130613071308130913101311131213131314131513161317131813191320132113221323132413251326132713281329133013311332133313341335133613371338133913401341134213431344134513461347134813491350135113521353135413551356135713581359136013611362136313641365136613671368136913701371137213731374137513761377137813791380138113821383138413851386138713881389139013911392139313941395139613971398139914001401140214031404140514061407140814091410141114121413141414151416141714181419142014211422142314241425142614271428142914301431143214331434if hexo-config(&#x27;preloader.enable&#x27;) .loading-bg position fixed z-index 1000 width 50% height 100% background var(--preloader-bg) #loading-box .loading-left-bg @extend .loading-bg left 0 .loading-right-bg @extend .loading-bg right 0 &amp;.loaded z-index -1000 .loading-left-bg transition all 1.0s transform translate(-100%, 0) .loading-right-bg transition all 1.0s transform translate(100%, 0) if hexo-config(&#x27;preloader.load_style&#x27;) == &#x27;wizard&#x27; #loading-box position fixed z-index 1000 display -webkit-box display flex -webkit-box-align center align-items center -webkit-box-pack center justify-content center -webkit-box-orient vertical -webkit-box-direction normal flex-direction column flex-wrap wrap width 100vw height 100vh overflow hidden &amp;.loaded .wizard-scene display none .wizard-scene position fixed z-index 1001 display -webkit-box display flex .wizard position relative width 190px height 240px .wizard-body position absolute bottom 0 left 68px height 100px width 60px background #3f64ce &amp;::after content &quot;&quot; position absolute bottom 0 left 20px height 100px width 60px background #3f64ce -webkit-transform skewX(14deg) transform skewX(14deg) .wizard-right-arm position absolute bottom 74px left 110px height 44px width 90px background #3f64ce border-radius 22px -webkit-transform-origin 16px 22px transform-origin 16px 22px -webkit-transform rotate(70deg) transform rotate(70deg) -webkit-animation right_arm 10s ease-in-out infinite animation right_arm 10s ease-in-out infinite .right-hand position absolute right 8px bottom 8px width 30px height 30px border-radius 50% background #f1c5b4 -webkit-transform-origin center center transform-origin center center -webkit-transform rotate(-40deg) transform rotate(-40deg) -webkit-animation right_hand 10s ease-in-out infinite animation right_hand 10s ease-in-out infinite .wizard-right-hand &amp;::after content &quot;&quot; position absolute right 0px top -8px width 15px height 30px border-radius 10px background #f1c5b4 -webkit-transform translateY(16px) transform translateY(16px) -webkit-animation right_finger 10s ease-in-out infinite animation right_finger 10s ease-in-out infinite .wizard-left-arm position absolute bottom 74px left 26px height 44px width 70px background #3f64ce border-bottom-left-radius 8px -webkit-transform-origin 60px 26px transform-origin 60px 26px -webkit-transform rotate(-70deg) transform rotate(-70deg) -webkit-animation left_arm 10s ease-in-out infinite animation left_arm 10s ease-in-out infinite .wizard-left-hand position absolute left -18px top 0 width 18px height 30px border-top-left-radius 35px border-bottom-left-radius 35px background #f1c5b4 &amp;::after content &quot;&quot; position absolute right 0 top 0 width 30px height 15px border-radius 20px background #f1c5b4 -webkit-transform-origin right bottom transform-origin right bottom -webkit-transform scaleX(0) transform scaleX(0) -webkit-animation left_finger 10s ease-in-out infinite animation left_finger 10s ease-in-out infinite .wizard-head position absolute top 0 left 14px width 160px height 210px -webkit-transform-origin center center transform-origin center center -webkit-transform rotate(-3deg) transform rotate(-3deg) -webkit-animation head 10s ease-in-out infinite animation head 10s ease-in-out infinite .wizard-beard position absolute bottom 0 left 38px height 106px width 80px border-bottom-right-radius 55% background #ffffff &amp;::after content &quot;&quot; position absolute top 16px left -10px width 40px height 20px border-radius 20px background #ffffff .wizard-face position absolute bottom 76px left 38px height 30px width 60px background #f1c5b4 &amp;::before content &quot;&quot; position absolute top 0px left 40px width 20px height 40px border-bottom-right-radius 20px border-bottom-left-radius 20px background #f1c5b4 &amp;::after content &quot;&quot; position absolute top 16px left -10px width 50px height 20px border-radius 20px border-bottom-right-radius 0px background #ffffff .wizard-adds position absolute top 0px left -10px width 40px height 20px border-radius 20px background #f1c5b4 &amp;::after content &quot;&quot; position absolute top 5px left 80px width 15px height 20px border-bottom-right-radius 20px border-top-right-radius 20px background #f1c5b4 .wizard-hat position absolute bottom 106px left 0 width 160px height 20px border-radius 20px background #3f64ce &amp;::before content &quot;&quot; position absolute top -70px left 50% -webkit-transform translatex(-50%) transform translatex(-50%) width 0 height 0 border-style solid border-width 0 34px 70px 50px border-color transparent transparent #3f64ce transparent &amp;::after content &quot;&quot; position absolute top 0 left 0 width 160px height 20px background #3f64ce border-radius 20px .wizard-hat-of-the-hat position absolute bottom 78px left 79px width 0 height 0 border-style solid border-width 0 25px 25px 19px border-color transparent transparent #3f64ce transparent &amp;::after content &quot;&quot; position absolute top 6px left -4px width 35px height 10px border-radius 10px border-bottom-left-radius 0px background #3f64ce -webkit-transform rotate(40deg) transform rotate(40deg) .wizard-four-point-star position absolute width 12px height 12px &amp;::after -webkit-transform rotate(156.66deg) skew(45deg) transform rotate(156.66deg) skew(45deg) &amp;.--first bottom 28px left 46px &amp;.--second bottom 40px left 80px &amp;.--third bottom 15px left 108px .wizard-head .wizard-hat .wizard-four-point-star::after, .wizard-head .wizard-hat .wizard-four-point-star::before content &quot;&quot; position absolute background #ffffff display block left 0 width 141.4213% top 0 bottom 0 border-radius 10% -webkit-transform rotate(66.66deg) skewX(45deg) transform rotate(66.66deg) skewX(45deg) .wizard-objects position relative width 200px height 240px .wizard-square position absolute bottom -60px left -5px width 120px height 120px border-radius 50% -webkit-transform rotate(-360deg) transform rotate(-360deg) -webkit-animation path_square 10s ease-in-out infinite animation path_square 10s ease-in-out infinite &amp;::after content &quot;&quot; position absolute top 10px left 0 width 50px height 50px background #9ab3f5 .wizard-circle position absolute bottom 10px left 0 width 100px height 100px border-radius 50% -webkit-transform rotate(-360deg) transform rotate(-360deg) -webkit-animation path_circle 10s ease-in-out infinite animation path_circle 10s ease-in-out infinite &amp;::after content &quot;&quot; position absolute bottom -10px left 25px width 50px height 50px border-radius 50% background #c56183 .wizard-triangle position absolute bottom -62px left -10px width 110px height 110px border-radius 50% -webkit-transform rotate(-360deg) transform rotate(-360deg) -webkit-animation path_triangle 10s ease-in-out infinite animation path_triangle 10s ease-in-out infinite &amp;::after content &quot;&quot; position absolute top 0 right -10px width 0 height 0 border-style solid border-width 0 28px 48px 28px border-color transparent transparent #89beb3 transparent /** 10s animation - 10% = 1s */ @-webkit-keyframes right_arm 0% -webkit-transform rotate(70deg) transform rotate(70deg) 10% -webkit-transform rotate(8deg) transform rotate(8deg) 15% -webkit-transform rotate(20deg) transform rotate(20deg) 20% -webkit-transform rotate(10deg) transform rotate(10deg) 25% -webkit-transform rotate(26deg) transform rotate(26deg) 30% -webkit-transform rotate(10deg) transform rotate(10deg) 35% -webkit-transform rotate(28deg) transform rotate(28deg) 40% -webkit-transform rotate(9deg) transform rotate(9deg) 45% -webkit-transform rotate(28deg) transform rotate(28deg) 50% -webkit-transform rotate(8deg) transform rotate(8deg) 58% -webkit-transform rotate(74deg) transform rotate(74deg) 62% -webkit-transform rotate(70deg) transform rotate(70deg) @keyframes right_arm 0% -webkit-transform rotate(70deg) transform rotate(70deg) 10% -webkit-transform rotate(8deg) transform rotate(8deg) 15% -webkit-transform rotate(20deg) transform rotate(20deg) 20% -webkit-transform rotate(10deg) transform rotate(10deg) 25% -webkit-transform rotate(26deg) transform rotate(26deg) 30% -webkit-transform rotate(10deg) transform rotate(10deg) 35% -webkit-transform rotate(28deg) transform rotate(28deg) 40% -webkit-transform rotate(9deg) transform rotate(9deg) 45% -webkit-transform rotate(28deg) transform rotate(28deg) 50% -webkit-transform rotate(8deg) transform rotate(8deg) 58% -webkit-transform rotate(74deg) transform rotate(74deg) 62% -webkit-transform rotate(70deg) transform rotate(70deg) @-webkit-keyframes left_arm 0% -webkit-transform rotate(-70deg) transform rotate(-70deg) 10% -webkit-transform rotate(6deg) transform rotate(6deg) 15% -webkit-transform rotate(-18deg) transform rotate(-18deg) 20% -webkit-transform rotate(5deg) transform rotate(5deg) 25% -webkit-transform rotate(-18deg) transform rotate(-18deg) 30% -webkit-transform rotate(5deg) transform rotate(5deg) 35% -webkit-transform rotate(-17deg) transform rotate(-17deg) 40% -webkit-transform rotate(5deg) transform rotate(5deg) 45% -webkit-transform rotate(-18deg) transform rotate(-18deg) 50% -webkit-transform rotate(6deg) transform rotate(6deg) 58% -webkit-transform rotate(-74deg) transform rotate(-74deg) 62% -webkit-transform rotate(-70deg) transform rotate(-70deg) @keyframes left_arm 0% -webkit-transform rotate(-70deg) transform rotate(-70deg) 10% -webkit-transform rotate(6deg) transform rotate(6deg) 15% -webkit-transform rotate(-18deg) transform rotate(-18deg) 20% -webkit-transform rotate(5deg) transform rotate(5deg) 25% -webkit-transform rotate(-18deg) transform rotate(-18deg) 30% -webkit-transform rotate(5deg) transform rotate(5deg) 35% -webkit-transform rotate(-17deg) transform rotate(-17deg) 40% -webkit-transform rotate(5deg) transform rotate(5deg) 45% -webkit-transform rotate(-18deg) transform rotate(-18deg) 50% -webkit-transform rotate(6deg) transform rotate(6deg) 58% -webkit-transform rotate(-74deg) transform rotate(-74deg) 62% -webkit-transform rotate(-70deg) transform rotate(-70deg) @-webkit-keyframes right_hand 0% -webkit-transform rotate(-40deg) transform rotate(-40deg) 10% -webkit-transform rotate(-20deg) transform rotate(-20deg) 15% -webkit-transform rotate(-5deg) transform rotate(-5deg) 20% -webkit-transform rotate(-60deg) transform rotate(-60deg) 25% -webkit-transform rotate(0deg) transform rotate(0deg) 30% -webkit-transform rotate(-60deg) transform rotate(-60deg) 35% -webkit-transform rotate(0deg) transform rotate(0deg) 40% -webkit-transform rotate(-40deg) transform rotate(-40deg) 45% -webkit-transform rotate(-60deg) transform rotate(-60deg) 50% -webkit-transform rotate(10deg) transform rotate(10deg) 60% -webkit-transform rotate(-40deg) transform rotate(-40deg) @keyframes right_hand 0% -webkit-transform rotate(-40deg) transform rotate(-40deg) 10% -webkit-transform rotate(-20deg) transform rotate(-20deg) 15% -webkit-transform rotate(-5deg) transform rotate(-5deg) 20% -webkit-transform rotate(-60deg) transform rotate(-60deg) 25% -webkit-transform rotate(0deg) transform rotate(0deg) 30% -webkit-transform rotate(-60deg) transform rotate(-60deg) 35% -webkit-transform rotate(0deg) transform rotate(0deg) 40% -webkit-transform rotate(-40deg) transform rotate(-40deg) 45% -webkit-transform rotate(-60deg) transform rotate(-60deg) 50% -webkit-transform rotate(10deg) transform rotate(10deg) 60% -webkit-transform rotate(-40deg) transform rotate(-40deg) @-webkit-keyframes right_finger 0% -webkit-transform translateY(16px) transform translateY(16px) 10% -webkit-transform none transform none 50% -webkit-transform none transform none 60% -webkit-transform translateY(16px) transform translateY(16px) @keyframes right_finger 0% -webkit-transform translateY(16px) transform translateY(16px) 10% -webkit-transform none transform none 50% -webkit-transform none transform none 60% -webkit-transform translateY(16px) transform translateY(16px) @-webkit-keyframes left_finger 0% -webkit-transform scaleX(0) transform scaleX(0) 10% -webkit-transform scaleX(1) rotate(6deg) transform scaleX(1) rotate(6deg) 15% -webkit-transform scaleX(1) rotate(0deg) transform scaleX(1) rotate(0deg) 20% -webkit-transform scaleX(1) rotate(8deg) transform scaleX(1) rotate(8deg) 25% -webkit-transform scaleX(1) rotate(0deg) transform scaleX(1) rotate(0deg) 30% -webkit-transform scaleX(1) rotate(7deg) transform scaleX(1) rotate(7deg) 35% -webkit-transform scaleX(1) rotate(0deg) transform scaleX(1) rotate(0deg) 40% -webkit-transform scaleX(1) rotate(5deg) transform scaleX(1) rotate(5deg) 45% -webkit-transform scaleX(1) rotate(0deg) transform scaleX(1) rotate(0deg) 50% -webkit-transform scaleX(1) rotate(6deg) transform scaleX(1) rotate(6deg) 58% -webkit-transform scaleX(0) transform scaleX(0) @keyframes left_finger 0% -webkit-transform scaleX(0) transform scaleX(0) 10% -webkit-transform scaleX(1) rotate(6deg) transform scaleX(1) rotate(6deg) 15% -webkit-transform scaleX(1) rotate(0deg) transform scaleX(1) rotate(0deg) 20% -webkit-transform scaleX(1) rotate(8deg) transform scaleX(1) rotate(8deg) 25% -webkit-transform scaleX(1) rotate(0deg) transform scaleX(1) rotate(0deg) 30% -webkit-transform scaleX(1) rotate(7deg) transform scaleX(1) rotate(7deg) 35% -webkit-transform scaleX(1) rotate(0deg) transform scaleX(1) rotate(0deg) 40% -webkit-transform scaleX(1) rotate(5deg) transform scaleX(1) rotate(5deg) 45% -webkit-transform scaleX(1) rotate(0deg) transform scaleX(1) rotate(0deg) 50% -webkit-transform scaleX(1) rotate(6deg) transform scaleX(1) rotate(6deg) 58% -webkit-transform scaleX(0) transform scaleX(0) @-webkit-keyframes head 0% -webkit-transform rotate(-3deg) transform rotate(-3deg) 10% -webkit-transform translatex(10px) rotate(7deg) transform translatex(10px) rotate(7deg) 50% -webkit-transform translatex(0px) rotate(0deg) transform translatex(0px) rotate(0deg) 56% -webkit-transform rotate(-3deg) transform rotate(-3deg) @keyframes head 0% -webkit-transform rotate(-3deg) transform rotate(-3deg) 10% -webkit-transform translatex(10px) rotate(7deg) transform translatex(10px) rotate(7deg) 50% -webkit-transform translatex(0px) rotate(0deg) transform translatex(0px) rotate(0deg) 56% -webkit-transform rotate(-3deg) transform rotate(-3deg) /** 10s animation - 10% = 1s */ @-webkit-keyframes path_circle 0% -webkit-transform translateY(0) transform translateY(0) 10% -webkit-transform translateY(-100px) rotate(-5deg) transform translateY(-100px) rotate(-5deg) 55% -webkit-transform translateY(-100px) rotate(-360deg) transform translateY(-100px) rotate(-360deg) 58% -webkit-transform translateY(-100px) rotate(-360deg) transform translateY(-100px) rotate(-360deg) 63% -webkit-transform rotate(-360deg) transform rotate(-360deg) @keyframes path_circle 0% -webkit-transform translateY(0) transform translateY(0) 10% -webkit-transform translateY(-100px) rotate(-5deg) transform translateY(-100px) rotate(-5deg) 55% -webkit-transform translateY(-100px) rotate(-360deg) transform translateY(-100px) rotate(-360deg) 58% -webkit-transform translateY(-100px) rotate(-360deg) transform translateY(-100px) rotate(-360deg) 63% -webkit-transform rotate(-360deg) transform rotate(-360deg) @-webkit-keyframes path_square 0% -webkit-transform translateY(0) transform translateY(0) 10% -webkit-transform translateY(-155px) translatex(-15px) rotate(10deg) transform translateY(-155px) translatex(-15px) rotate(10deg) 55% -webkit-transform translateY(-155px) translatex(-15px) rotate(-350deg) transform translateY(-155px) translatex(-15px) rotate(-350deg) 57% -webkit-transform translateY(-155px) translatex(-15px) rotate(-350deg) transform translateY(-155px) translatex(-15px) rotate(-350deg) 63% -webkit-transform rotate(-360deg) transform rotate(-360deg) @keyframes path_square 0% -webkit-transform translateY(0) transform translateY(0) 10% -webkit-transform translateY(-155px) translatex(-15px) rotate(10deg) transform translateY(-155px) translatex(-15px) rotate(10deg) 55% -webkit-transform translateY(-155px) translatex(-15px) rotate(-350deg) transform translateY(-155px) translatex(-15px) rotate(-350deg) 57% -webkit-transform translateY(-155px) translatex(-15px) rotate(-350deg) transform translateY(-155px) translatex(-15px) rotate(-350deg) 63% -webkit-transform rotate(-360deg) transform rotate(-360deg) @-webkit-keyframes path_triangle 0% -webkit-transform translateY(0) transform translateY(0) 10% -webkit-transform translateY(-172px) translatex(10px) rotate(-10deg) transform translateY(-172px) translatex(10px) rotate(-10deg) 55% -webkit-transform translateY(-172px) translatex(10px) rotate(-365deg) transform translateY(-172px) translatex(10px) rotate(-365deg) 58% -webkit-transform translateY(-172px) translatex(10px) rotate(-365deg) transform translateY(-172px) translatex(10px) rotate(-365deg) 63% -webkit-transform rotate(-360deg) transform rotate(-360deg) @keyframes path_triangle 0% -webkit-transform translateY(0) transform translateY(0) 10% -webkit-transform translateY(-172px) translatex(10px) rotate(-10deg) transform translateY(-172px) translatex(10px) rotate(-10deg) 55% -webkit-transform translateY(-172px) translatex(10px) rotate(-365deg) transform translateY(-172px) translatex(10px) rotate(-365deg) 58% -webkit-transform translateY(-172px) translatex(10px) rotate(-365deg) transform translateY(-172px) translatex(10px) rotate(-365deg) 63% -webkit-transform rotate(-360deg) transform rotate(-360deg) else if hexo-config(&#x27;preloader.load_style&#x27;) == &#x27;ironheart&#x27; #loading-box position fixed z-index 1000 display -webkit-box display flex -webkit-box-align center align-items center -webkit-box-pack center justify-content center -webkit-box-orient vertical -webkit-box-direction normal flex-direction column flex-wrap wrap width 100vw height 100vh overflow hidden &amp;.loaded .iron-container display none .iron-circle border-radius 50% .iron-center position absolute top 50% left 50% transform translate(-50%, -50%) .iron-container z-index 1001 position relative width 300px height 300px border 1px solid rgb(18, 20, 20) background-color #384c50 box-shadow 0 0 32px 8px rgb(18, 20, 20), 0 0 4px 1px rgb(18, 20, 20) inset .iron-box1 width 238px height 238px background-color rgb(22, 26, 27) box-shadow 0 0 4px 1px #52fefe .iron-box2 width 220px height 220px background-color #fff box-shadow 0 0 5px 1px #52fefe, 0 0 5px 4px #52fefe inset .iron-box3 width 180px height 180px background-color #073c4b box-shadow 0 0 5px 4px #52fefe, 0 0 6px 2px #52fefe inset .iron-box4 width 120px height 120px border 1px solid #52fefe background-color #fff box-shadow 0 0 2px 1px #52fefe, 0 0 10px 5px #52fefe inset .iron-box5 width 70px height 70px border 5px solid #1b4e5f box-shadow 0 0 7px 5px #52fefe, 0 0 10px 10px #52fefe inset .iron-box6 position relative width 100% height 100% animation ironrotate 3s linear infinite .iron-coil position absolute width 30px height 20px top calc(50% - 110px) left calc(50% - 15px) background-color #073c4b box-shadow 0 0 5px #52fefe inset transform rotate(calc(var(--i) * 45deg)) transform-origin center 110px @keyframes ironrotate 0% transform rotate(0) 100% transform rotate(360deg) else if hexo-config(&#x27;preloader.load_style&#x27;) == &#x27;scarecrow&#x27; #loading-box position fixed z-index 1000 display -webkit-box display flex -webkit-box-align center align-items center -webkit-box-pack center justify-content center -webkit-box-orient vertical -webkit-box-direction normal flex-direction column flex-wrap wrap width 100vw height 100vh overflow hidden &amp;.loaded .scarecrow display none .scarecrow z-index 1001 position relative animation hop 0.2s ease-in alternate infinite .scarecrow__hat position relative border-top-left-radius 5px border-top-right-radius 5px border-top 45px solid #515559 border-left 1px solid transparent border-right 1px solid transparent width 55px margin 0 auto -3px z-index 1 &amp;:before content &quot;&quot; position absolute top -87px right -23px background-color #515559 width 9px height 55px border-radius 100% transform rotate(50deg) &amp;:after content &quot;&quot; position absolute top 12px left -15px background-color #515559 width 85px height 10px border-radius 40% 40% 70% 70% .scarecrow__ribbon width 55px height 12px background-color #d996b5 margin 0 auto .scarecrow__head position relative background-color #f2f2f2 width 70px height 55px margin 0 auto border-radius 50% display flex justify-content space-around flex-flow row wrap .scarecrow__eye width 6px height 6px background-color #000 border-radius 50% margin 20px 5px 0 .scarecrow__mouth width 45px height 15px background-color #fff border-radius 50% .scarecrow__pipe position absolute top 40px left 60px width 40px height 2px background-color #8c8070 &amp;:before content &quot;&quot; position absolute width 9px height 17px background-color #8c8070 border-radius 3px left 40px top -7px .scarecrow__body position relative width 250px z-index 1 .scarecrow__coat position absolute top 15px left 0 right 0 margin-left auto margin-right auto border-top 100px solid #515559 border-left 5px solid transparent border-right 5px solid transparent width 75px .scarecrow__bow position absolute top 20px left 0 right 0 margin-left auto margin-right auto background-color #3a485d width 10px height 10px z-index 3 border-radius 2px &amp;:before content &quot;&quot; position absolute top -10px left -25px width 0 height 10px border-top 10px solid transparent border-left 25px solid #5a6b8c border-bottom 10px solid transparent border-radius 8px &amp;:after content &quot;&quot; position absolute top -10px right -25px width 0 height 10px border-top 10px solid transparent border-right 25px solid #5a6b8c border-bottom 10px solid transparent border-radius 8px .scarecrow__shirt position absolute top 8px left 0 right 0 margin-left auto margin-right auto width 30px height 35px z-index 2 &amp;:before content &quot;&quot; position absolute top 0 left -5px height 100% width 70% background-color #dbb2c2 transform skew(1deg, 35deg) border-bottom-left-radius 90px border-top-left-radius 15px border-bottom-right-radius 15px border-top-right-radius 10px &amp;:after content &quot;&quot; position absolute top 0 right -5px height 100% width 70% background-color #dbb2c2 transform skew(-1deg, -35deg) border-top-right-radius 15px border-bottom-right-radius 90px border-bottom-left-radius 15px border-top-left-radius 10px .scarecrow__waistcoat position absolute top 15px left -1px right 0 margin-left auto margin-right auto width 35px height 50px &amp;:before content &quot;&quot; position absolute top 0 left -4px height 100% width 65% background-color #83a6bc transform skew(0deg, 40deg) border-bottom-left-radius 90px border-top-left-radius 90px border-bottom-right-radius 15px &amp;:after content &quot;&quot; position absolute top 0 right -5px height 100% width 65% background-color #83a6bc transform skew(0deg, -40deg) border-top-right-radius 90px border-bottom-right-radius 90px border-bottom-left-radius 15px .scarecrow__coattails position absolute top 105px left 0 right 0 margin-left auto margin-right auto width 75px height 120px z-index 1 &amp;:before content &quot;&quot; position absolute top 0 left 8px height 100% width 60% background-color #515559 transform-origin top transform skew(-25deg, 30deg) rotate(0deg) border-bottom-left-radius 50px border-bottom-right-radius 5px animation coattails-left 0.2s ease-in alternate infinite &amp;:after content &quot;&quot; position absolute top 0 right 8px height 100% width 60% background-color #515559 transform-origin top transform skew(25deg, -30deg) rotate(0deg) border-bottom-right-radius 50px border-bottom-left-radius 5px animation coattails-right 0.2s ease-in alternate infinite .scarecrow__pants position absolute top 115px left 0 right 0 margin-left auto margin-right auto width 50px height 150px &amp;:before content &quot;&quot; position absolute top 0 left -8px height 100% width 60% background-color #393c3e transform rotate(0deg) transform-origin top animation pants 0.5s linear alternate infinite &amp;:after content &quot;&quot; position absolute top 0 right -8px height 100% width 60% background-color #393c3e transform rotate(0deg) transform-origin top animation pants 0.3s linear alternate infinite .scarecrow__sleeve position absolute top 15px background-color #515559 width 80px height 25px .scarecrow__sleeve--l left 10px &amp;:before content &quot;&quot; position absolute top -3px left -22px width 0 height 25px border-top 3px solid transparent border-left 25px solid #515559 border-bottom 3px solid transparent border-radius 3px .scarecrow__sleeve--r right 10px &amp;:before content &quot;&quot; position absolute top -3px right -22px width 0 height 25px border-top 3px solid transparent border-right 25px solid #515559 border-bottom 3px solid transparent border-radius 3px .scarecrow__glove position absolute top 12px width 0px height 12px &amp;:before content &quot;&quot; position absolute top -7px border-radius 100% background-color #f2f2f2 width 35px height 15px .scarecrow__glove--l border-top 3px solid transparent border-right 20px solid #f2f2f2 border-bottom 3px solid transparent left -50px &amp;:before transform-origin right left -30px transform rotate(0deg) animation glove-l 0.2s linear alternate infinite .scarecrow__glove--r border-top 3px solid transparent border-left 20px solid #f2f2f2 border-bottom 3px solid transparent right -50px &amp;:before transform-origin left right -30px transform rotate(0deg) animation glove-r 0.2s linear alternate infinite .scarecrow__arms position absolute left 50% transform translate(-50%, -50%) background-color #8c8070 width 350px height 8px border-radius 5px margin 20px auto .scarecrow__leg position relative background-color #8c8070 width 8px height 380px border-bottom-left-radius 5px border-bottom-right-radius 5px margin 0 auto @keyframes hop 0% transform translateY(-10px) 100% transform translateY(10px) @keyframes coattails-left 0% transform skew(-25deg, 30deg) rotate(-3deg) 100% transform skew(-25deg, 30deg) rotate(3deg) @keyframes coattails-right 0% transform skew(25deg, -30deg) rotate(3deg) 100% transform skew(25deg, -30deg) rotate(-3deg) @keyframes pants 0% transform rotate(3deg) 100% transform rotate(-3deg) @keyframes glove-l 0% transform rotate(-50deg) 100% transform rotate(-30deg) @keyframes glove-r 0% transform rotate(50deg) 100% transform rotate(30deg) else if hexo-config(&#x27;preloader.load_style&#x27;) == &#x27;image&#x27; #loading-box position fixed z-index 1000 display -webkit-box display flex -webkit-box-align center align-items center -webkit-box-pack center justify-content center -webkit-box-orient vertical -webkit-box-direction normal flex-direction column flex-wrap wrap width 100vw height 100vh overflow hidden .load-image position fixed z-index 1001 display flex &amp;.loaded .load-image display none else #loading-box .spinner-box position fixed z-index 1001 display flex justify-content center align-items center width 100% height 100vh .configure-border-1 position absolute padding 3px width 115px height 115px background #ffab91 animation configure-clockwise 3s ease-in-out 0s infinite alternate .configure-border-2 left -115px padding 3px width 115px height 115px background rgb(63, 249, 220) transform rotate(45deg) animation configure-xclockwise 3s ease-in-out 0s infinite alternate .loading-word position absolute color var(--preloader-color) font-size .8rem .configure-core width 100% height 100% background-color var(--preloader-bg) &amp;.loaded .spinner-box display none @keyframes configure-clockwise 0% transform rotate(0) 25% transform rotate(90deg) 50% transform rotate(180deg) 75% transform rotate(270deg) 100% transform rotate(360deg) @keyframes configure-xclockwise 0% transform rotate(45deg) 25% transform rotate(-45deg) 50% transform rotate(-135deg) 75% transform rotate(-225deg) 100% transform rotate(-315deg)修改 [Blogroot]\\themes\\butterfly\\layout\\includes\\layout.pug，以适配接下来需要添加的配置项。主题版本&gt;=3.6.01234 body- if theme.preloader+ if theme.preloader.enable !=partial(&#x27;includes/loading/loading&#x27;, &#123;&#125;, &#123;cache: true&#125;)修改 [Blogroot]\\themes\\butterfly\\source\\css\\var.styl，添加自定义修改背景色的配置项。(大概 98 行的位置)1234 // preloader- $preloader-bg = #37474f+ $preloader-bg = hexo-config(&#x27;preloader.enable&#x27;) &amp;&amp; hexo-config(&#x27;preloader.load_color&#x27;) ? convert(hexo-config(&#x27;preloader.load_color&#x27;)) : #37474f $preloader-word-color = #fff修改 [Blogroot]\\_config.butterfly.yml 的 preloader 配置项。1234567 # Loading Animation (加載動畫)- preloader: true+ preloader:+ enable: true # true|false+ load_color: &#x27;#000000&#x27; # &#x27;#37474f&#x27;+ load_style: wizard # # spinner-box|wizard|ironheart|scarecrow|image+ load_image: # url","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://blog.ajream.top/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://blog.ajream.top/tags/Hexo/"}]},{"title":"Github Actions自动部署","slug":"Hexo/github Actions自动部署","date":"2021-09-13T12:13:46.000Z","updated":"2024-03-31T14:49:40.667Z","comments":true,"path":"posts/88ad757/","link":"","permalink":"https://blog.ajream.top/posts/88ad757/","excerpt":"","text":"写在前面 注意现在是2023-09-14，本文章写于2021年，使用butterfly作为博客主题的时候，部分书写可能有些错误，请注意结合自己的实际情况，不过该文章介绍的方法与主题无关。 没用过Actions的建议细看，好好理解其工作原理和流程 本文大部分参考 [糖果屋] 的教程，详见糖果屋-使用Github Action实现全自动部署, 感谢大佬！ Github Actions简介 Github Actions 可以理解为一个自动化脚本，当它检测到某个仓库发生变化后，自动执行脚本语句 在这里可以让脚本自动执行 hexo cl &amp;&amp; hexo g -d 三连操作 获取令牌(Token) 为了确保交由 Github Action 来持续部署时，Github Action 具备足够的权限来进行 hexo deploy 操作[因为远程服务器的git不能使用ssh方式推送]，需要先获取 Token，博主分别在 Github、Gitee、Coding 处部署了静态页面，所以也就需要获取这三处的 Token。 当我们获取了token后，在 _config.yml文件的 deploy 项就可以使用了 👉Github👉Gitee👉coding访问 Github-&gt; 头像（右上角）-&gt;Settings-&gt;Developer Settings-&gt;Personal access tokens-&gt;generate new token, 创建的 Token 名称随意，但必须勾选 repo 项。 token 只会显示这一次，之后将无法查看，所以务必保证你已经记录下了 Token。之后如果忘记了就只能重新生成重新配置了。访问 Gitee-&gt; 头像（右上角）-&gt; 设置 -&gt; 私人令牌 -&gt; 生成新令牌 token 只会显示这一次，之后将无法查看，所以务必保证你已经记录下了 Token。之后如果忘记了就只能重新生成重新配置了。访问 Coding-&gt; 头像（右上角）-&gt; 个人账户设置 -&gt; 访问令牌 -&gt; 新建令牌。 注意coding平台与Github、Gitee不同，它生成的令牌还有【令牌用户名】，并且只会显示这一次，之后将无法查看，所以务必保证你已经记录下了 Token和令牌用户名。之后如果忘记了就只能重新生成重新配置了。 创建存放源码的私有仓库 展开 我们需要创建一个用来存放 Hexo 博客源码的私有仓库 [SourceRepo]，这点在 Win10 的 Hexo 博客搭建教程中有提到。为了保持教程的连贯，此处再写一遍。创建完成后，需要把博客的源码 push 到这里。首先获取远程仓库地址，此处虽然 SSH 和 HTTPS 均可。SSH 在绑定过 ssh key 的设备上无需再输入密码，HTTPS 则需要输入密码，但是 SSH 偶尔会遇到端口占用的情况。请自主选择。这里之所以是私有仓库，是因为在接下来的配置中会用到 Token，如果 Token 被盗用，别人可以肆意操作你的 github 仓库内容，为了避免这一风险，才选择的博客源码闭源。 配置 deploy 项 打开站点配置文件 [Blogroot]/_config.yml, 找到 deploy 配置项，使用之前生成的 [SiteToken] 和各个站点仓库 URL 来组装地址。 12345678deploy:- type: git repo: gitHub: https://[GithubUsername]:[GithubToken]@github.com/[GithubUsername]/[GithubBlogRepo].git[,branch] gitee: https://[Gitee用户名]:[GiteeToken]@gitee.com/[GiteeUsername]/[GiteeBlogRepo].git[,branch] coding: https://[令牌用户名]:[CodingToken]@e.coding.net/[CodingUsername]/[CodingBlogRepo].git[,branch] # [,branch]为可选项，表示部署的分支 #2020年10月后github新建仓库默认分支改为main，注意更改 注意：Gitee的用户名如果含有大写字母，要改为小写； coding的【令牌用户名】是生成令牌时显示出来的，如果没有注意，要重新生成一次 参考我个人的写法： 123456deploy: type: git repo: github: https://aJream:XXXXXXXXXXXXXXXXXXXXXXXXXXXX@github.com/aJream/aJream.github.io.git,master gitee: https://ajream:XXXXXXXXXXXXXXXXXXXXXXXXXXXX@gitee.com/ajream/ajream.git,master coding: https://xxxxxxxxxx:XXXXXXXXXXXXXXXXXXXXXXXXXXXX@e.coding.net/ajream/page/blog1.git,master 配置 Github Action 在 [Blogroot] 新建.github 文件夹，注意开头是有个. 的。然后在.github 内新建 workflows 文件夹，再在 workflows 文件夹内新建 autodeploy.yml, 在 [Blogroot]/.github/workflows/autodeploy.yml 里面输入 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657# 当有改动推送到master分支时，启动Actionname: 自动部署on: push: branches: - master #2020年10月后github新建仓库默认分支改为main，注意更改 release: types: - publishedjobs: deploy: runs-on: ubuntu-latest steps: - name: 检查分支 uses: actions/checkout@v2 with: ref: master #2020年10月后github新建仓库默认分支改为main，注意更改 - name: 安装 Node uses: actions/setup-node@v1 with: node-version: &quot;12.x&quot; - name: 安装 Hexo run: | export TZ=&#x27;Asia/Shanghai&#x27; npm install hexo-cli -g - name: 缓存 Hexo uses: actions/cache@v1 id: cache with: path: node_modules key: $&#123;&#123;runner.OS&#125;&#125;-$&#123;&#123;hashFiles(&#x27;**/package-lock.json&#x27;)&#125;&#125; - name: 安装依赖 if: steps.cache.outputs.cache-hit != &#x27;true&#x27; run: | npm install --save - name: 生成静态文件 run: | hexo clean hexo generate - name: 部署 run: | git config --global user.name &quot;[GithubUsername]&quot; git config --global user.email &quot;[GithubEmail]&quot; git clone https://github.com/[GithubUsername]/[GithubBlogRepo].git .deploy_git # 此处务必用HTTPS链接。SSH链接可能有权限报错的隐患 # =====注意.deploy_git前面有个空格===== # 这行指令的目的是clone博客静态文件仓库，防止Hexo推送时覆盖整个静态文件仓库，而是只推送有更改的文件 hexo deploy 注意看代码里面的注释 重新设置远程仓库和分支 🍬曾经用git管理过博源码🍬第一次用git管理博客源码 添加屏蔽项 因为能够使用指令进行安装的内容不包括在需要提交的源码内，所有我们需要将这些内容添加到屏蔽项，表示不上传到 github 上。这样可以显著减少需要提交的文件量和加快提交速度。 打开 [Blogroot]/.gitignore, 输入以下内容： 12345678910.DS_StoreThumbs.dbdb.json*.lognode_modules/public/.deploy*/.deploy_git*/.ideathemes/butterfly/.git 如果不是 butterfly 主题，记得替换最后一行内容为你自己当前使用的主题 提交源码到刚才新建的私有仓库 在博客根目录 [Blogroot] 下启动终端，使用 git 指令重设仓库地址。这样在新建仓库，我们仍旧可以保留珍贵的 commit history，便于版本回滚。 12345678910git remote rm origin # 删除原有仓库链接git remote add origin git@github.com:[Github用户名]/[私有仓库名].git #[SourceRepo]为新的存放源码的github私有仓库git checkout -b master # 切换到master分支，#2020年10月后github新建仓库默认分支改为main，注意更改# 如果不是，后面的所有设置的分支记得保持一致git add .git commit -m &quot;github action update&quot;git push origin master#2020年10月后github新建仓库默认分支改为main，注意更改 可能遇到的 bug 因为 butterfly 主题文件夹下的.git 文件夹的存在，那么主题文件夹会被识别子项目。从而无法被上传到源码仓库。若是遇到添加屏蔽项，但是还是无法正常上传主题文件夹的情况。请先将本地源码中的 themes 文件夹移动到别的目录下。然后 commit 一次。接着将 themes 文件夹移动回来，再 commit 一次。 删除或者先把 [Blogroot]/themes/butterfly/.git 移动到非博客文件夹目录下，原因是主题文件夹下的.git 文件夹的存在会导致其被识别成子项目，从而无法被上传到源码仓库。 在博客根目录 [Blogroot] 路径下运行指令 12345git init #初始化git remote add origin git@github.com:[Github用户名]/[私有仓库名].git #[SourceRepo]为存放源码的github私有仓库git checkout -b master # 切换到master分支，#2020年10月后github新建仓库默认分支改为main，注意更改# 如果不是，后面的所有设置的分支记得保持一致 添加屏蔽项 因为能够使用指令进行安装的内容不包括在需要提交的源码内，所有我们需要将这些内容添加到屏蔽项，表示不上传到 github 上。这样可以显著减少需要提交的文件量和加快提交速度。 打开 [Blogroot]/.gitignore, 输入以下内容： 12345678910.DS_StoreThumbs.dbdb.json*.lognode_modules/public/.deploy*/.deploy_git*/.ideathemes/butterfly/.git # 如果不是 butterfly 主题，记得替换最后一行内容为你自己当前使用的主题 完成后就可以用git指令进行提交到Github源码仓库，Actions监测到仓库发生改变会自动部署 1234git add .git commit -m &quot;github action update&quot;git push origin master#2020年10月后github新建仓库默认分支改为main，注意更改 此时你的主题文件夹若已经被正常上传，并且你也添加了主题文件夹下的.git 文件夹的屏蔽项。那可以考虑把第二步移走或删除的.git 放回来，用作以后升级。（不禁怀疑真的有人会去用这个方式来升级吗） 查看部署情况 点击正在运行的workflow就可以查看部署情况 我遇到的Bug Bug： Spawn Failed 原因主要就是配置deploy项时仓库的git链接没有正确配置，比如 ： gitee仓库的用户名使用大写就不行，要改为小写（平台上的用户名不用改，只需要改链接中的） 配置coding时没有仔细看教程，用户名必须要使用生成 token 时系统同时生成的令牌用户名 看板娘不能显示 删除 BlogRoot/themes/butterfly/source/live2d-widget 下的 .git 文件 然后执行： 1234git rm --cached /themes/butterfly/source/live2d-widgetgit add .git commit -m &quot;修复看板娘不能正常显示&quot;git push origin master","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://blog.ajream.top/categories/Hexo/"}],"tags":[{"name":"Github","slug":"Github","permalink":"https://blog.ajream.top/tags/Github/"},{"name":"Hexo","slug":"Hexo","permalink":"https://blog.ajream.top/tags/Hexo/"}]},{"title":"Hexo添加百度统计分析","slug":"Hexo/Hexo添加百度统计分析","date":"2021-08-29T02:20:29.000Z","updated":"2024-03-31T14:49:40.667Z","comments":true,"path":"posts/c8eb4af9/","link":"","permalink":"https://blog.ajream.top/posts/c8eb4af9/","excerpt":"","text":"注意现在是2023-09-14，本文章写于2021年，使用butterfly作为博客主题的时候，部分书写可能有些错误，请注意判断以下方法是否适用于自己的主题。 注册登录 登录百度统计的官方网站 添加网站，填写相关信息 获取代码 将上面这串字符填在主题的配置文件_config.butterfly.yml中： 1234# Baidu Analytics# https://tongji.baidu.com/web/welcome/loginbaidu_analytics: #填在这里","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://blog.ajream.top/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://blog.ajream.top/tags/Hexo/"}]},{"title":"Hello World","slug":"hello-world","date":"2021-05-08T04:32:44.000Z","updated":"2024-03-31T14:49:40.667Z","comments":true,"path":"posts/4a17b156/","link":"","permalink":"https://blog.ajream.top/posts/4a17b156/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new &quot;My New Post&quot; More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment 公式示例 设函数f(x,y)f(x,y)f(x,y)的全微分为df(x,y)=(2ax+by)dx+(2by+ax)dydf(x,y)=(2ax+by)dx+(2by+ax)dydf(x,y)=(2ax+by)dx+(2by+ax)dy,(aaa,bbb为常数),且f(0,0)=−3,fx′(1,1)=3f(0,0)=-3,f_{x}^{&#x27;}(1,1)=3f(0,0)=−3,fx′​(1,1)=3,求f(x,y)f(x,y)f(x,y) 本题给的是全微分,但是可以看成两个偏微分,并且较为基础,所以放在第一题 ∂f∂x=2ax+by,∂f∂y=2by+ax\\frac{∂f}{∂x}=2ax+by,\\frac{∂f}{∂y}=2by+ax ∂x∂f​=2ax+by,∂y∂f​=2by+ax 直接对两个偏微分求不定积分,可以得到原函数.注意对x积分时,将y看作常数,因此最后的+C+C+C实际上应该写作+g(y)+g(y)+g(y) f(x,y)=ax2+bxy+g(y)=by2+axy+h(x)f(x,y)=ax^{2}+bxy+g(y)=by^{2}+axy+h(x) f(x,y)=ax2+bxy+g(y)=by2+axy+h(x) 显然两者是同一个函数,因此对应的项的系数也相同,即a=ba=ba=b,对x求偏导,得到fx′(1,1)=2a+b=3f_{x}^{&#x27;}(1,1)=2a+b=3fx′​(1,1)=2a+b=3,故f(x,y)=x2+xy+y2−3f(x,y)=x^2+xy+y^2-3f(x,y)=x2+xy+y2−3","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://blog.ajream.top/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://blog.ajream.top/tags/Hexo/"}]}],"categories":[{"name":"开发环境搭建","slug":"开发环境搭建","permalink":"https://blog.ajream.top/categories/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"name":"瞎折腾","slug":"瞎折腾","permalink":"https://blog.ajream.top/categories/%E7%9E%8E%E6%8A%98%E8%85%BE/"},{"name":"算法题","slug":"算法题","permalink":"https://blog.ajream.top/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"考研","slug":"考研","permalink":"https://blog.ajream.top/categories/%E8%80%83%E7%A0%94/"},{"name":"编程基础","slug":"编程基础","permalink":"https://blog.ajream.top/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"},{"name":"娱乐","slug":"娱乐","permalink":"https://blog.ajream.top/categories/%E5%A8%B1%E4%B9%90/"},{"name":"Hexo","slug":"Hexo","permalink":"https://blog.ajream.top/categories/Hexo/"},{"name":"简历","slug":"简历","permalink":"https://blog.ajream.top/categories/%E7%AE%80%E5%8E%86/"},{"name":"课程考试","slug":"课程考试","permalink":"https://blog.ajream.top/categories/%E8%AF%BE%E7%A8%8B%E8%80%83%E8%AF%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://blog.ajream.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://blog.ajream.top/tags/C-C/"},{"name":"ESP32","slug":"ESP32","permalink":"https://blog.ajream.top/tags/ESP32/"},{"name":"Python","slug":"Python","permalink":"https://blog.ajream.top/tags/Python/"},{"name":"AcWing","slug":"AcWing","permalink":"https://blog.ajream.top/tags/AcWing/"},{"name":"高数","slug":"高数","permalink":"https://blog.ajream.top/tags/%E9%AB%98%E6%95%B0/"},{"name":"节日","slug":"节日","permalink":"https://blog.ajream.top/tags/%E8%8A%82%E6%97%A5/"},{"name":"leetcode","slug":"leetcode","permalink":"https://blog.ajream.top/tags/leetcode/"},{"name":"stellar","slug":"stellar","permalink":"https://blog.ajream.top/tags/stellar/"},{"name":"简历","slug":"简历","permalink":"https://blog.ajream.top/tags/%E7%AE%80%E5%8E%86/"},{"name":"vercel","slug":"vercel","permalink":"https://blog.ajream.top/tags/vercel/"},{"name":"pages","slug":"pages","permalink":"https://blog.ajream.top/tags/pages/"},{"name":"Gitee","slug":"Gitee","permalink":"https://blog.ajream.top/tags/Gitee/"},{"name":"图床","slug":"图床","permalink":"https://blog.ajream.top/tags/%E5%9B%BE%E5%BA%8A/"},{"name":"通信原理","slug":"通信原理","permalink":"https://blog.ajream.top/tags/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/"},{"name":"补码","slug":"补码","permalink":"https://blog.ajream.top/tags/%E8%A1%A5%E7%A0%81/"},{"name":"概率论","slug":"概率论","permalink":"https://blog.ajream.top/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/"},{"name":"傅里叶","slug":"傅里叶","permalink":"https://blog.ajream.top/tags/%E5%82%85%E9%87%8C%E5%8F%B6/"},{"name":"数字信号处理","slug":"数字信号处理","permalink":"https://blog.ajream.top/tags/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"},{"name":"链表","slug":"链表","permalink":"https://blog.ajream.top/tags/%E9%93%BE%E8%A1%A8/"},{"name":"Hexo","slug":"Hexo","permalink":"https://blog.ajream.top/tags/Hexo/"},{"name":"Github","slug":"Github","permalink":"https://blog.ajream.top/tags/Github/"},{"name":"技巧","slug":"技巧","permalink":"https://blog.ajream.top/tags/%E6%8A%80%E5%B7%A7/"},{"name":"自动化","slug":"自动化","permalink":"https://blog.ajream.top/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"},{"name":"云函数","slug":"云函数","permalink":"https://blog.ajream.top/tags/%E4%BA%91%E5%87%BD%E6%95%B0/"}]}